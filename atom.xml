<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lomo | 朱幸民</title>
  
  <subtitle>on the way</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zhuxingmin.com/"/>
  <updated>2021-03-03T09:02:04.097Z</updated>
  <id>https://www.zhuxingmin.com/</id>
  
  <author>
    <name>Lomo 朱幸民</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS事件流</title>
    <link href="https://www.zhuxingmin.com/2021/03/03/JS%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <id>https://www.zhuxingmin.com/2021/03/03/JS事件流/</id>
    <published>2021-03-03T06:55:03.000Z</published>
    <updated>2021-03-03T09:02:04.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>首先看一个相关问题，点击<code>span</code>元素，输出什么？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"yeyeELe"</span>&gt;</span>    </span><br><span class="line">    爷爷在此    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"parEle"</span>&gt;</span>        </span><br><span class="line">        我是父元素        </span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"sonEle"</span>&gt;</span>我是子元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sonEle = <span class="built_in">document</span>.getElementById(<span class="string">'sonEle'</span>);</span><br><span class="line"><span class="keyword">var</span> parEle = <span class="built_in">document</span>.getElementById(<span class="string">'parEle'</span>);</span><br><span class="line"><span class="keyword">var</span> yeyeELe = <span class="built_in">document</span>.getElementById(<span class="string">'yeyeELe'</span>);</span><br><span class="line"></span><br><span class="line">yeyeELe.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'爷爷 冒泡'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">sonEle.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子级 捕获'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line">parEle.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父级 捕获'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line">yeyeELe.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'爷爷 捕获'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line">parEle.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父级 冒泡'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">sonEle.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子级 冒泡'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>想搞清楚最终的输出顺序，就不得不从<code>事件流</code>说起。</p><a id="more"></a><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流需要从事件讲起。</p><p>JavaScript 与 HTML 之间的交互是通过<strong>事件</strong>实现的。</p><blockquote><p><code>事件</code>就是文档或者浏览器窗口中发生的一些特定的交互瞬间。可以使用<code>侦听器</code>（或处理程序）来预订事件，以便事件发生时执行相应代码。</p></blockquote><p>而事件流描述的是<strong>从页面接收事件的顺序。</strong></p><p>有意思的是，当时不同的开发团队对于事件流提出了完全相反的概念，主要分为IE事件流——冒泡，Netscape Communicator事件流——捕获。</p><h3 id="1-事件冒泡"><a href="#1-事件冒泡" class="headerlink" title="1. 事件冒泡"></a>1. 事件冒泡</h3><blockquote><p>IE的事件流叫做<strong>事件冒泡</strong>，即时间最开始由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。</p></blockquote><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>事件流<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ele"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当你点击了页面中的 <code>div</code> 元素，那么这个 click 事件的传播顺序如下：</p><ol><li>div</li><li>body</li><li>html</li><li>document</li></ol><p>也就是说，click 事件首先在元素 <code>div</code> 上发生，然后 click 事件沿 DOM 树向上传播，每一级的节点上都会发生，直至传播到 document 对象。如下图：</p><p><img src="/images/posts/event_01.png" alt="事件冒泡" title="事件冒泡"></p><h3 id="2-事件捕获"><a href="#2-事件捕获" class="headerlink" title="2. 事件捕获"></a>2. 事件捕获</h3><blockquote><p>Netscape Communicator 团队提出的事件流则为<strong>事件捕获</strong>，事件捕获的思想是不太具体的节点更早的收到事件，而最具体的节点最后接收到事件。</p></blockquote><p><strong>事件捕获的用意在于事件达到预定目标之前捕获它。</strong></p><p>如 <code>1.</code> 中所述案例，则单击 <code>div</code> 元素后，事件触发顺序如下：</p><ol><li>document</li><li>html</li><li>body</li><li>div</li></ol><p>也就是在事件捕获过程中，document 对象首先接收到 click 事件，然后事件沿 DOM 树向下依次传播，直到传播事件的实际目标，即 div 元素。过程如图：</p><p><img src="/images/posts/event_02.png" alt="事件捕获" title="事件捕获"></p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>虽然事件捕获是 Netscape Communicator 唯一支持的事件流模型，但是 IE9、Safari、Chrome、Opera 和 Firefox 等目前也都支持这种事件流模型。由于版本兼容性问题，事件捕获还是较少使用。当然，建议依然是 <strong>放心使用事件冒泡，在有特殊需要时再使用事件捕获。</strong></p><h3 id="3-DOM-事件流"><a href="#3-DOM-事件流" class="headerlink" title="3. DOM 事件流"></a>3. DOM 事件流</h3><p>“DOM2级事件”规定的事件流包括三个阶段：</p><ol><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ol><p>首先发生的是事件捕获，为截获事件提供了机会，然后实际目标接收到事件，最后阶段是冒泡阶段，此阶段可以对事件作出响应。</p><p>还以上述代码为例，单击 <code>div</code> 元素后的触发顺序则是：</p><p><img src="/images/posts/event_03.png" alt="DOM事件流" title="DOM事件流"></p><p>在 DOM 事件流中，<strong>实际目标（div）在捕获阶段不会接收到事件</strong>，意味着在捕获阶段事件从 document 到 html 再到 body 就会停止。下一阶段是处于目标阶段，于是事件在 div 上发生，并在事件处理中被看成冒泡的一部分。最后，冒泡阶段发生，事件传播回文档。</p><h2 id="回顾问题"><a href="#回顾问题" class="headerlink" title="回顾问题"></a>回顾问题</h2><p>开篇提出的问题，仿佛在此可以得出结论：</p><p><img src="/images/posts/event_answer.png" alt="输出结果" title="输出结果"></p><p>可是，当我们将子级的冒泡和捕获在js中位置调换后，输出的则是……子级先冒泡，再捕获！如下：</p><p><img src="/images/posts/event_answer2.png" alt="输出结果2" title="输出结果2"></p><p>这是什么原因呢？？</p><p>下期——事件处理顺序，进一步揭晓。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; title=&quot;问题引入&quot;&gt;&lt;/a&gt;问题引入&lt;/h2&gt;&lt;p&gt;首先看一个相关问题，点击&lt;code&gt;span&lt;/code&gt;元素，输出什么？&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;yeyeELe&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    爷爷在此    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;parEle&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        我是父元素        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;sonEle&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;我是子元素&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sonEle = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;sonEle&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; parEle = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;parEle&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; yeyeELe = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;yeyeELe&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yeyeELe.addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;爷爷 冒泡&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sonEle.addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;子级 捕获&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;parEle.addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;父级 捕获&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yeyeELe.addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;爷爷 捕获&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;parEle.addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;父级 冒泡&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sonEle.addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;子级 冒泡&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;想搞清楚最终的输出顺序，就不得不从&lt;code&gt;事件流&lt;/code&gt;说起。&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="https://www.zhuxingmin.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>git 基础操作</title>
    <link href="https://www.zhuxingmin.com/2021/03/02/git-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>https://www.zhuxingmin.com/2021/03/02/git-基础操作/</id>
    <published>2021-03-02T09:34:55.000Z</published>
    <updated>2021-03-02T10:10:13.963Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/posts/git_01.png" alt="git" title="git"></p><h2 id="为什么学习git"><a href="#为什么学习git" class="headerlink" title="为什么学习git"></a>为什么学习git</h2><ul><li>工作必备</li><li>提升团队协作效率</li><li>面试加分项</li></ul><a id="more"></a><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>安装、使用</li><li>对文件的基础操作</li><li>对分支的基础操作</li><li>git相关插件使用（chrome插件）</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>学习常见使用场景</li><li>学习基础操作，不深究原理</li></ul><h2 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h2><ul><li><code>git config --global user.name &#39;name&#39;</code> // 配置用户名</li><li><code>git config --global user.email &#39;email&#39;</code>  // 配置email</li><li><code>git config --global --list</code>  // 查看配置</li></ul><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><ul><li><code>git add</code> . // 把本地所有untrack的文件都加入暂存区，并且会根据.gitignore做过滤</li><li><code>git commit -m &quot;说明&quot;</code>  // 提交暂存区的文件</li><li><code>git log</code>  // 查看所有记录</li><li><code>git log --author=&quot;name&quot;</code>  // 查看某个人提交记录</li><li><code>git status</code>  // 查看状态</li><li><code>git rm [filename]</code>  // 删除文件</li><li><code>git mv [oldname] [newname]</code> // 重命名</li><li><code>git checkout -- [file/filename]</code>  // 还原到上次修改(还为提交)</li><li><code>git reset HEAD [file/filename]</code>  // 撤销提交(已提交到暂存区)</li><li><code>git reset --hard HEAD ^^</code>  // 回退两个版本，一个^代表一个版本</li><li><code>git reset --hard [id]</code>  // 回退到指定版本，id随便几位或者全部位数都可以</li><li><code>git checkout [id] -- [filename]</code>  // 指定文件回退到指定版本。id:指定版本；filename：指定文件</li><li><code>git push origin master</code>  // 推送代码到远程仓库主分支</li><li><code>git tag [v1.1.0]</code>  // 添加标签，标签默认添加在最新一次提交上</li><li><code>git tag [v1.1.0] [id]</code>  // 添加标签，标签添加在指定版本id上</li><li><code>git tag -d [v1.1.0]</code>  // 删除指定标签</li><li><code>git push origin [v1.1.0]</code>  // 推送标签版本</li><li><code>git fetch</code>  // 拉取所有远程仓库</li><li><code>git branch -av</code>  // 查看分支</li></ul><h2 id="关于分支"><a href="#关于分支" class="headerlink" title="关于分支"></a>关于分支</h2><h3 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h3><ul><li>多人协作</li><li>支线任务不会影响主线任务</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><code>git branch [name]</code></li><li><code>git branch</code>  // 检查分支</li></ul><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><ul><li><code>git checkout [name]</code></li></ul><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><ol><li><code>git branch -d [name]</code>  // 不能删除当前所在分支，不能删除有提交的分支</li><li><code>git branch -D [name]</code>  // 强制删除某个分支，即使有提交记录也可删除</li></ol><h3 id="创建分支并切换到此分支"><a href="#创建分支并切换到此分支" class="headerlink" title="创建分支并切换到此分支"></a>创建分支并切换到此分支</h3><ul><li><code>git checkout -b [name]</code></li></ul><h2 id="关于合并分支"><a href="#关于合并分支" class="headerlink" title="关于合并分支"></a>关于合并分支</h2><h3 id="正确的合并分支流程"><a href="#正确的合并分支流程" class="headerlink" title="正确的合并分支流程"></a>正确的合并分支流程</h3><ul><li><code>git checkout master</code>  // 切换到主分支</li><li><code>git merge [name]</code>  // 将分支[name]的代码合并到主分支</li></ul><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><h4 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h4><p><strong>多分支处理同一段代码提交合并后，冲突报错</strong></p><h4 id="两种方案"><a href="#两种方案" class="headerlink" title="两种方案"></a>两种方案</h4><ol><li><p>忽略其他分支代码保留当前分支代码</p><p><code>git merge --abort</code></p></li></ol><ol start="2"><li>手动修改</li></ol><p>修改完毕后：</p><ul><li><code>git add .</code></li><li><code>git commit</code>  // 进入可编辑界面</li><li><code>按esc，写[:wq]，可退出编辑</code></li><li><code>git commit -m</code>  // 即可</li></ul><h3 id="不同人查看版本路线操作"><a href="#不同人查看版本路线操作" class="headerlink" title="不同人查看版本路线操作"></a>不同人查看版本路线操作</h3><ul><li><code>git log</code>  // 查看所有日志</li><li><code>git log --oneline</code> // 日志简写</li><li><code>git log --oneline --graph</code>  // 查看当前版本路线</li></ul><h3 id="不同人想要删除不想要的分支如何操作"><a href="#不同人想要删除不想要的分支如何操作" class="headerlink" title="不同人想要删除不想要的分支如何操作"></a>不同人想要删除不想要的分支如何操作</h3><ul><li>拉取所有远程仓库 <code>git fetch</code></li><li>查看所有分支 <code>git branch -av</code></li><li>删除指定分支 <code>git push origin --delete [name]</code></li></ul><p><strong>【注意：】</strong></p><ul><li>保证该分支确定不需要了</li><li>该分支代码是否合并到了主分支</li></ul><h3 id="不同人修改了不同文件如何处理"><a href="#不同人修改了不同文件如何处理" class="headerlink" title="不同人修改了不同文件如何处理"></a>不同人修改了不同文件如何处理</h3><p><strong>目的：解决不同人修改不同文件时的冲突。</strong></p><p><strong>解决方案：</strong></p><ul><li><code>git branch -av</code></li><li><code>git merge [fileurl]</code></li><li><code>插入信息，[esc]+[:wq]退出</code></li><li><code>git push</code></li></ul><h3 id="不同人修改了相同文件如何处理"><a href="#不同人修改了相同文件如何处理" class="headerlink" title="不同人修改了相同文件如何处理"></a>不同人修改了相同文件如何处理</h3><ul><li><code>git fetch</code>  // 拉取所有仓库列表</li><li><code>git branch -av</code>  // 查看所有分支</li><li><code>git checkout -b [name] remotes/origin/test</code>  // 拉取所需要分支代码</li><li>修改代码，然后继续提交：</li><li><code>git add .</code></li><li><code>git commit -m &#39;xxxx&#39;</code></li><li><code>git push</code></li></ul><h2 id="github-chrome插件"><a href="#github-chrome插件" class="headerlink" title="github chrome插件"></a>github chrome插件</h2><ol><li><strong>Octotree</strong> ：左侧树结构目录——见下图左侧目录</li></ol><p><img src="/images/posts/git_02.png" alt="git" title="Octotree &amp; Enhanced"></p><ol start="2"><li><strong>Enhanced GitHub</strong>: 显示文件大小——见上图中间可下载区域显示文件大小</li><li><strong>GitZip for github</strong>: 下载单个文件夹内容<br> 从上图的某一个文件夹上双击，会显示如下图的下载图标，点击即可下载单个目录的内容。<br><img src="/images/posts/git_03.png" alt="git" title="GitZip for github"></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/posts/git_01.png&quot; alt=&quot;git&quot; title=&quot;git&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么学习git&quot;&gt;&lt;a href=&quot;#为什么学习git&quot; class=&quot;headerlink&quot; title=&quot;为什么学习git&quot;&gt;&lt;/a&gt;为什么学习git&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;工作必备&lt;/li&gt;
&lt;li&gt;提升团队协作效率&lt;/li&gt;
&lt;li&gt;面试加分项&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="git" scheme="https://www.zhuxingmin.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>小程序之生命周期</title>
    <link href="https://www.zhuxingmin.com/2021/02/19/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://www.zhuxingmin.com/2021/02/19/小程序之生命周期/</id>
    <published>2021-02-19T09:20:25.000Z</published>
    <updated>2021-02-19T11:08:33.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1. 生命周期"></a>1. 生命周期</h2><h3 id="1-1-什么是生命周期？"><a href="#1-1-什么是生命周期？" class="headerlink" title="1.1 什么是生命周期？"></a>1.1 什么是生命周期？</h3><blockquote><p><strong>生命周期</strong>就是指一个对象的生老病死。<br>基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave）的整个过程。</p></blockquote><p><img src="/images/posts/小程序生命周期.png" alt="小程序生命周期" title="小程序生命周期"></p><a id="more"></a><h3 id="1-2-用途"><a href="#1-2-用途" class="headerlink" title="1.2 用途"></a>1.2 用途</h3><p>在技术中心，我们可以理解生命周期为从一个应用从创建到销毁的过程。在项目层面，我们每一个完整的项目中都会在不同时间不同位置处理不同问题及不同需求，也就是<strong>在特点时间执特定函数</strong>。</p><h2 id="2-小程序的生命周期"><a href="#2-小程序的生命周期" class="headerlink" title="2. 小程序的生命周期"></a>2. 小程序的生命周期</h2><p>根据官网介绍，小程序生命周期包含7个阶段：</p><table><thead><tr><th>阶段</th><th>类型</th><th>最低版本</th><th>说明</th></tr></thead><tbody><tr><td>onLaunch</td><td>function</td><td>/</td><td>监听小程序初始化</td></tr><tr><td>onShow</td><td>function</td><td>/</td><td>监听小程序启动或切前台</td></tr><tr><td>onHide</td><td>function</td><td>/</td><td>监听小程序切后台</td></tr><tr><td>onError</td><td>function</td><td>/</td><td>错误监听函数</td></tr><tr><td>onPageNotFound</td><td>function</td><td>1.9.90</td><td>页面不存在监听函数</td></tr><tr><td>onUnhandleRejection</td><td>function</td><td>2.10.0</td><td>未处理的 Promise 拒绝事件监听函数</td></tr><tr><td>onThemeChange</td><td>function</td><td>2.11.0</td><td>监听系统主题变化</td></tr></tbody></table><p><strong><em>注:</em></strong></p><p><em>接受一个 Object 参数，其指定小程序的生命周期回调等。</em></p><p><strong>App() 必须在 app.js 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。</strong></p><h3 id="2-1-onLaunch"><a href="#2-1-onLaunch" class="headerlink" title="2.1 onLaunch"></a>2.1 onLaunch</h3><p><strong>触发时机：</strong></p><p>小程序一启动时触发，被隐藏重新打开不触发，被销毁再打开才会触发。</p><p><strong>作用：</strong></p><ul><li>做初始化使用</li><li>云开发的初始化</li><li>发送请求获取用户个人信息</li><li>获取本地存储数据等</li></ul><p><strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    <span class="comment">// 小程序一启动时触发，被隐藏重新打开不触发，被销毁再打开才会触发</span></span><br><span class="line">    onLaunch (options) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'触发了 onLaunch'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-2-onShow"><a href="#2-2-onShow" class="headerlink" title="2.2 onShow"></a>2.2 onShow</h3><p><strong>触发时机：</strong></p><p>与 onHide 是一对，当应用重新被显示的时候或者第一次启动时都会触发</p><p><strong>作用：</strong></p><ul><li>重新启动定时器等执行类模块</li><li>重新出发异步请求获取最新数据</li><li>重新启动播放器等</li></ul><p><strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    <span class="comment">// 当应用重新被显示的时候或者第一次启动时都会触发</span></span><br><span class="line">    onShow (options) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'触发了 onShow'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-3-onHide"><a href="#2-3-onHide" class="headerlink" title="2.3 onHide"></a>2.3 onHide</h3><p><strong>触发时机：</strong></p><p>当整个小程序隐藏时会触发，如切换到其他APP</p><p><strong>作用：</strong></p><ul><li>可以停止一些正在执行操作，如暂停定时器、暂停音视频播放等</li></ul><p><strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    <span class="comment">// 当整个小程序隐藏时会触发，如切换到其他APP</span></span><br><span class="line">    onHide (options) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'触发了 onHide'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-4-onError"><a href="#2-4-onError" class="headerlink" title="2.4 onError"></a>2.4 onError</h3><p><strong>触发时机：</strong></p><p>小程序运行出错时触发</p><p><strong>作用：</strong></p><ul><li>收集错误信息，发送至后台，进行错误日志的记录</li><li>进行程序出错后的操作，例如弹窗提醒等</li></ul><p><strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    <span class="comment">// 小程序运行出错时触发</span></span><br><span class="line">    onError (options) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'触发了 onError'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-5-onPageNotFound"><a href="#2-5-onPageNotFound" class="headerlink" title="2.5 onPageNotFound"></a>2.5 onPageNotFound</h3><p><strong>触发时机：</strong></p><p>页面不存在时触发</p><p><strong>举例：</strong></p><ul><li>扫二维码进入小程序</li><li>二维码指定路径为index</li><li>后面程序中删除了index页面，修改其他页面（如home）作主页</li><li>此时用户扫码，提示页面不存在，触发该周期</li></ul><p><strong>作用：</strong></p><ul><li>监听报错，处理后续操作，如提示用户或者跳转新页面</li></ul><p><strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    <span class="comment">// 页面不存在时触发</span></span><br><span class="line">    onPageNotFound (options) &#123;</span><br><span class="line">        wx.redirectTo(&#123;</span><br><span class="line">            url: <span class="string">'pages/...'</span></span><br><span class="line">        &#125;) <span class="comment">// 如果是 tabbar 页面，请使用 wx.switchTab</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-5-onPageNotFound-1"><a href="#2-5-onPageNotFound-1" class="headerlink" title="2.5 onPageNotFound"></a>2.5 onPageNotFound</h3><p><strong>触发时机：</strong></p><p>页面不存在时触发</p><p><strong>举例：</strong></p><ul><li>扫二维码进入小程序</li><li>二维码指定路径为index</li><li>后面程序中删除了index页面，修改其他页面（如home）作主页</li><li>此时用户扫码，提示页面不存在，触发该周期</li></ul><p><strong>作用：</strong></p><ul><li>监听报错，处理后续操作，如提示用户或者跳转新页面</li></ul><p><strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    <span class="comment">// 页面不存在时触发</span></span><br><span class="line">    onPageNotFound (options) &#123;</span><br><span class="line">        wx.redirectTo(&#123;</span><br><span class="line">            url: <span class="string">'pages/...'</span></span><br><span class="line">        &#125;) <span class="comment">// 如果是 tabbar 页面，请使用 wx.switchTab</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-6-onUnhandledRejection"><a href="#2-6-onUnhandledRejection" class="headerlink" title="2.6 onUnhandledRejection"></a>2.6 onUnhandledRejection</h3><p><strong>触发时机：</strong></p><p>promise中的reject未被捕获处理时触发</p><p><strong>作用：</strong></p><ul><li>用于统一捕获处理，可以在该生命周期中处理错误情况，一般由于异步代码出错导致</li><li><em>提示：如果自己捕获了reject那么此生命周期不会触发</em></li></ul><p><strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    <span class="comment">// onLaunch</span></span><br><span class="line">    onLaunch() &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 触发reject </span></span><br><span class="line">            reject(&#123;<span class="string">"msg"</span>:<span class="string">"错误提示"</span>&#125;)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// catch了 reject 那么 onUnhandledRejection 就不会触发了</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"捕获reject"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// promise中的reject未被捕获处理时触发</span></span><br><span class="line">    onUnhandledRejection(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"onUnhandledRejection 当发现未被捕获的reject时触发"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-7-onThemeChange"><a href="#2-7-onThemeChange" class="headerlink" title="2.7 onThemeChange"></a>2.7 onThemeChange</h3><p><strong>触发时机：</strong></p><p>手机系统的主题模式（如黑夜模式）切换时触发</p><p><strong>作用：</strong></p><ul><li>小程序可以随系统主题切换主题或者更换UI风格</li></ul><p><strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    <span class="comment">// promise中的reject未被捕获处理时触发</span></span><br><span class="line">    onThemeChange(theme)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(theme); <span class="comment">// 'dark' | 'light'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-生命周期&quot;&gt;&lt;a href=&quot;#1-生命周期&quot; class=&quot;headerlink&quot; title=&quot;1. 生命周期&quot;&gt;&lt;/a&gt;1. 生命周期&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是生命周期？&quot;&gt;&lt;a href=&quot;#1-1-什么是生命周期？&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是生命周期？&quot;&gt;&lt;/a&gt;1.1 什么是生命周期？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;生命周期&lt;/strong&gt;就是指一个对象的生老病死。&lt;br&gt;基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave）的整个过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/小程序生命周期.png&quot; alt=&quot;小程序生命周期&quot; title=&quot;小程序生命周期&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="小程序" scheme="https://www.zhuxingmin.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="生命周期" scheme="https://www.zhuxingmin.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>js处理微信分享配置</title>
    <link href="https://www.zhuxingmin.com/2021/02/08/js%E5%A4%84%E7%90%86%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.zhuxingmin.com/2021/02/08/js处理微信分享配置/</id>
    <published>2021-02-08T09:05:27.000Z</published>
    <updated>2021-02-09T08:14:50.103Z</updated>
    
    <content type="html"><![CDATA[<p><em>整理一下通过h5做微信分享相关配置。</em></p><h2 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h2><ol><li>公众号配置（AppID、IP白名单、JS接口安全域名）</li><li>网页授权</li><li>JSSDK配置使用</li></ol><h2 id="1-公众号配置"><a href="#1-公众号配置" class="headerlink" title="1. 公众号配置"></a>1. 公众号配置</h2><p>登录微信公众号，<code>获取AppID</code>，<code>配置白名单</code>，然后<code>配置JS接口安全域名</code>。</p><h3 id="1-1-获取AppID"><a href="#1-1-获取AppID" class="headerlink" title="1.1 获取AppID"></a>1.1 获取AppID</h3><p>登录公众号后，左侧菜单栏选择：开发 =&gt; 基本配置，直接复制开发者ID(AppID)即可：</p><p><img src="/images/posts/wx_01.jpg" alt="AppID" title="AppID"></p><a id="more"></a><h3 id="1-2-配置白名单"><a href="#1-2-配置白名单" class="headerlink" title="1.2 配置白名单"></a>1.2 配置白名单</h3><p><strong>注意使用公网IP</strong></p><p><img src="/images/posts/wx_02.jpg" alt="配置白名单" title="配置白名单"></p><h3 id="1-3-配置JS接口安全域名"><a href="#1-3-配置JS接口安全域名" class="headerlink" title="1.3 配置JS接口安全域名"></a>1.3 配置JS接口安全域名</h3><p>左侧菜单栏选择：设置 =&gt; 公众号设置：</p><p><img src="/images/posts/wx_03.jpg" alt="JS接口安全域名" title="JS接口安全域名"></p><h2 id="2-网页授权"><a href="#2-网页授权" class="headerlink" title="2. 网页授权"></a>2. 网页授权</h2><p><em>网页授权主要是获取微信openId使用，如果只是用分享操作，本步可以略过。</em></p><p><em><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html" target="_blank" rel="noopener">网页授权介绍</a></em> </p><p>大致步骤是：</p><ol><li>跳微信网页授权链接</li><li>获取code值</li><li>传给后端，后端操作，得到用户openId</li></ol><h3 id="2-1-网页授权链接"><a href="#2-1-网页授权链接" class="headerlink" title="2.1 网页授权链接"></a>2.1 网页授权链接</h3><p>在配置完前面AppId、白名单及安全域名后，开始处理网页授权。<br>网页授权这一块儿内容主要是后端需要处理的内容较多，前端还是很简单的，仅需要跳入微信链接即可。为什么要走这一步呢因为有些操作，例如微信支付、播放微信录音、获取微信地址、微信卡券、商品、小店等等许多功能必须在微信浏览器汇总打开操作才可以，因此需要跳入微信浏览器及微信链接来处理后续操作。当配置后，链接便只有在微信浏览器中打开才会生效了，不然会提示：</p><p><img src="/images/posts/wx_04.png" alt="提示" title="提示"></p><p>链接如下：</p><p><code>https://open.weixin.qq.com/connect/oauth2/authorize?appid={$appId}&amp;redirect_uri=={$URL}&amp;response_type=code&amp;scope=snsapi_base#wechat_redirect</code></p><p><strong>参数分解</strong></p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">appid</td><td style="text-align:left">appid值</td><td style="text-align:left">公众号的唯一标识</td></tr><tr><td style="text-align:left">redirect_uri</td><td style="text-align:left">urlEncode</td><td style="text-align:left">授权后重定向的回调链接地址， 请使用 urlEncode 对链接进行处理,要与1.3中配置的域名对应</td></tr><tr><td style="text-align:left">response_type</td><td style="text-align:left">code</td><td style="text-align:left">应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息 ）</td></tr><tr><td style="text-align:left">scope</td><td style="text-align:left">snsapi_base</td><td style="text-align:left">重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节</td></tr><tr><td style="text-align:left">#wechat_redirect</td><td style="text-align:left">后缀</td><td style="text-align:left">固定填写即可,无论直接打开还是做页面302重定向时候，必须带此参数</td></tr></tbody></table><p>可见，上面需要填入的变量有二，一个是前面回去的AppId，另外一个则是url，需要写的是与配置域名所对应域名下的url，并且要进行urlEncode编码处理使用。</p><h3 id="2-2-获取code值"><a href="#2-2-获取code值" class="headerlink" title="2.2 获取code值"></a>2.2 获取code值</h3><p>在拿到上述完整链接后，通过<code>window.location.href = ${url}</code>进行网页授权即可。在授权成功后，页面会重定向到自己设置的url页面去，然后在该连接上会有code值，取出即可：</p><p><img src="/images/posts/wx_05.jpg" alt="code值" title="code值"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出code值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="built_in">window</span>.location.search;   <span class="comment">// 从问号 (?) 开始的 URL（查询部分</span></span><br><span class="line">    <span class="keyword">let</span> str = url.substring(<span class="number">1</span>,url.length);  <span class="comment">// 去掉问号</span></span><br><span class="line">    <span class="keyword">let</span> arr = str.split(<span class="string">'&amp;'</span>);   <span class="comment">// 以'&amp;'分割为数组</span></span><br><span class="line">    <span class="comment">// 将所有参数搞成键值对形式放入obj对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i ++)&#123;</span><br><span class="line">        obj[arr[i].split(<span class="string">"="</span>)[<span class="number">0</span>]] = <span class="built_in">unescape</span>(arr[i].split(<span class="string">"="</span>)[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(obj.code) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">getCode();</span><br></pre></td></tr></table></figure><h3 id="2-3-换取openId"><a href="#2-3-换取openId" class="headerlink" title="2.3 换取openId"></a>2.3 换取openId</h3><p>将拿到的code值传给后端即可，看具体需求决定是否前端使用openId，如果非必要则不在前端获取保存或者由后端加密后传给前端使用。</p><h2 id="3-JSSDK配置使用"><a href="#3-JSSDK配置使用" class="headerlink" title="3. JSSDK配置使用"></a>3. JSSDK配置使用</h2><p>大致分为五个步骤：</p><ol><li>绑定域名</li><li>引入JS文件</li><li>通过config接口注入权限验证配置</li><li>通过ready接口处理成功验证</li><li>通过error接口处理失败验证</li></ol><h3 id="3-1-绑定域名"><a href="#3-1-绑定域名" class="headerlink" title="3.1 绑定域名"></a>3.1 绑定域名</h3><p>在步骤 1.3 中已经配置。</p><h3 id="3-2-引入JS文件"><a href="#3-2-引入JS文件" class="headerlink" title="3.2 引入JS文件"></a>3.2 引入JS文件</h3><p>在需要调用JS接口的页面引入如下JS文件：<code>https://res.wx.qq.com/open/js/jweixin-1.6.0.js</code></p><p><em>备注：支持使用 AMD/CMD 标准模块加载方法加载</em></p><h3 id="3-3-通过config接口注入权限验证配置"><a href="#3-3-通过config接口注入权限验证配置" class="headerlink" title="3.3 通过config接口注入权限验证配置"></a>3.3 通过config接口注入权限验证配置</h3><p>配置需要如下几个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">    debug: <span class="literal">true</span>,    <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">    appId: <span class="string">''</span>,  <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">    timestamp: <span class="string">''</span>,  <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">    nonceStr: <span class="string">''</span>,   <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">    signature: <span class="string">''</span>,  <span class="comment">// 必填，签名</span></span><br><span class="line">    jsApiList: [],  <span class="comment">// 必填，需要使用的JS接口列表</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那这些参数从哪儿来呢？依旧不用担心，依然是交给后端处理，后端返回时间戳、随机串及签名，其他的自己配置即可。</p><p>通过后端获取需要进行一个小交互，将此时的链接地址(window.location.href)传给后端即可。</p><p>于是就有了上述的除了最后一个以外的所有参数。最后一个<code>jsApiList</code>则是写分享接口，如我们想要分享到朋友圈、QQ、腾讯微博这3个，那就写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">    debug: <span class="literal">true</span>,    <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">    appId: <span class="string">'xxx'</span>,  <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">    timestamp: <span class="string">'xxx'</span>,  <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">    nonceStr: <span class="string">'xxx'</span>,   <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">    signature: <span class="string">'xxx'</span>,  <span class="comment">// 必填，签名</span></span><br><span class="line">    jsApiList: [<span class="string">'checkJsApi,'</span><span class="string">'updateTimelineShareData'</span>,<span class="string">'updateAppMessageShareData'</span>,<span class="string">'onMenuShareWeibo'</span>],  <span class="comment">// 必填，需要使用的JS接口列表</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以发现，我们其实多配置了一个<code>checkJsApi</code>，这个是一个判断配置，可以判断当前客户端版本是否支持指定JS接口。</p><p><em><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#62" target="_blank" rel="noopener">签名算法</a></em><br><em><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#63" target="_blank" rel="noopener">所有JS接口列表</a></em></p><h3 id="3-4-通过ready接口处理成功验证"><a href="#3-4-通过ready接口处理成功验证" class="headerlink" title="3.4 通过ready接口处理成功验证"></a>3.4 通过ready接口处理成功验证</h3><p>接下来就可以写分享信息配置了。配置信息一般都是通过<code>wx.ready</code>处理的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例如我们要分享到朋友圈，配置则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需在用户可能点击分享按钮前就先调用，在不影响资源处理的情况下尽早配置即可</span></span><br><span class="line">wx.ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;   </span><br><span class="line">    wx.updateAppMessageShareData(&#123; </span><br><span class="line">        title: <span class="string">''</span>, <span class="comment">// 分享标题</span></span><br><span class="line">        desc: <span class="string">''</span>, <span class="comment">// 分享描述</span></span><br><span class="line">        link: <span class="string">''</span>, <span class="comment">// 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致</span></span><br><span class="line">        imgUrl: <span class="string">''</span>, <span class="comment">// 分享图标</span></span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 操作成功后要做的事儿</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>注意：不要出现<a href="https://kf.qq.com/faq/161223JfINJV1612237buYri.html" target="_blank" rel="noopener">诱导分享</a></strong></p><h3 id="3-5-通过error接口处理失败验证"><a href="#3-5-通过error接口处理失败验证" class="headerlink" title="3.5 通过error接口处理失败验证"></a>3.5 通过error接口处理失败验证</h3><p>同样，一般都是通过<code>wx.error</code>处理失败相关信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.error(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实微信分享（地理位置、扫一扫、卡券等微信各类接口）都是通过上述步骤配置的，可举一反三，在面对不同需求时通过微信开发文档来进行更为复杂的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;整理一下通过h5做微信分享相关配置。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;流程介绍&quot;&gt;&lt;a href=&quot;#流程介绍&quot; class=&quot;headerlink&quot; title=&quot;流程介绍&quot;&gt;&lt;/a&gt;流程介绍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;公众号配置（AppID、IP白名单、JS接口安全域名）&lt;/li&gt;
&lt;li&gt;网页授权&lt;/li&gt;
&lt;li&gt;JSSDK配置使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-公众号配置&quot;&gt;&lt;a href=&quot;#1-公众号配置&quot; class=&quot;headerlink&quot; title=&quot;1. 公众号配置&quot;&gt;&lt;/a&gt;1. 公众号配置&lt;/h2&gt;&lt;p&gt;登录微信公众号，&lt;code&gt;获取AppID&lt;/code&gt;，&lt;code&gt;配置白名单&lt;/code&gt;，然后&lt;code&gt;配置JS接口安全域名&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;1-1-获取AppID&quot;&gt;&lt;a href=&quot;#1-1-获取AppID&quot; class=&quot;headerlink&quot; title=&quot;1.1 获取AppID&quot;&gt;&lt;/a&gt;1.1 获取AppID&lt;/h3&gt;&lt;p&gt;登录公众号后，左侧菜单栏选择：开发 =&amp;gt; 基本配置，直接复制开发者ID(AppID)即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/wx_01.jpg&quot; alt=&quot;AppID&quot; title=&quot;AppID&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="https://www.zhuxingmin.com/tags/js/"/>
    
      <category term="微信" scheme="https://www.zhuxingmin.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>css书写规范</title>
    <link href="https://www.zhuxingmin.com/2021/01/12/css%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/"/>
    <id>https://www.zhuxingmin.com/2021/01/12/css书写规范/</id>
    <published>2021-01-12T08:22:37.000Z</published>
    <updated>2021-01-15T04:06:07.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>在前端领域，<code>CSS</code>(层叠样式表:Cascading Style Sheets)是绕不过的话题。</p><blockquote><p>样式表定义如何显示 HTML 元素，就像 HTML 中的字体标签和颜色属性所起的作用那样。样式通常保存在外部的 <code>.css</code> 文件中。我们只需要编辑一个简单的 CSS 文档就可以改变所有页面的布局和外观。</p></blockquote><p>虽然CSS初学者易于上手，且趣味性十足，但是作为一项工程而言，还是需要有一定规范约束的。这里简单介绍下关于css的一些规范。</p><h2 id="1-书写顺序"><a href="#1-书写顺序" class="headerlink" title="1. 书写顺序"></a>1. 书写顺序</h2><p>一般而言css都有一定的书写顺序，而不是想起来什么属性写说明属性。一般css的书写顺序为：</p><ol><li>位置（z-index position top display float …）</li><li>大小边距（width padding margin …）</li><li>文字（font line-height letter-spacing color …）</li><li>背景（background border …）</li><li>其他（animation transtion …）</li></ol><a id="more"></a><p>例如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示例 */</span></span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f6f6f6</span>;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">5px</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 规范示例 */</span></span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">999</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">5px</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f6f6f6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-注意缩写"><a href="#2-注意缩写" class="headerlink" title="2. 注意缩写"></a>2. 注意缩写</h2><p>缩写，就是属性名及属性值，能缩写则缩写。例如属性名、属性值、颜色、去掉小数点前的0等：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示例 */</span></span><br><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">0.9rem</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1.2rem</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">0.8rem</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">1.2rem</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: serif;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.2</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 规范示例 */</span></span><br><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">9rem</span> <span class="number">1.2rem</span> .<span class="number">8rem</span>;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">100%</span>/<span class="number">1.2</span> serif;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-命名规范"><a href="#3-命名规范" class="headerlink" title="3. 命名规范"></a>3. 命名规范</h2><p>命名规范两个注意点：</p><ol><li>不要乱使用“<code>id</code>”<br> 这是因为id在js中具有唯一性，防止多次使用而对脚本编写带来影响。而class类则可重复使用。另外id与class权重不同，优先级不同，id得按需使用。</li><li>长命名尽量使用中横线“<code>-</code>”来做短词分割，如<code>main-cont</code><br> 用短横线而不用下划线分割有两点：1. 对浏览器解析更加兼容；2. js变量一般使用下划线命名，为做出良好区分，所以使用短横线。</li></ol><h2 id="4-常见css命名规则表"><a href="#4-常见css命名规则表" class="headerlink" title="4 常见css命名规则表"></a>4 常见css命名规则表</h2><p><strong><em>一般可用id来命名</em></strong></p><h3 id="4-1-页面结构"><a href="#4-1-页面结构" class="headerlink" title="4.1 页面结构"></a>4.1 页面结构</h3><table><thead><tr><th>css名</th><th>表示规则</th></tr></thead><tbody><tr><td>main</td><td>主体</td></tr><tr><td>container</td><td>容器</td></tr><tr><td>header</td><td>头</td></tr><tr><td>content</td><td>内容</td></tr><tr><td>footer</td><td>尾</td></tr><tr><td>sidebar</td><td>侧边栏</td></tr><tr><td>nav</td><td>导航</td></tr><tr><td>column</td><td>栏</td></tr><tr><td>wrapper</td><td>页面外围控制整体布局容器</td></tr></tbody></table><h3 id="4-2-导航"><a href="#4-2-导航" class="headerlink" title="4.2 导航"></a>4.2 导航</h3><table><thead><tr><th>css名</th><th>表示规则</th></tr></thead><tbody><tr><td>nav</td><td>导航</td></tr><tr><td>subnav</td><td>子导航</td></tr><tr><td>topnav</td><td>顶部导航</td></tr><tr><td>sidebar</td><td>侧边导航</td></tr><tr><td>menu</td><td>菜单</td></tr><tr><td>submenu</td><td>子菜单</td></tr><tr><td>title</td><td>一般指栏目标题</td></tr><tr><td>summary</td><td>摘要</td></tr></tbody></table><h3 id="4-3-功能"><a href="#4-3-功能" class="headerlink" title="4.3 功能"></a>4.3 功能</h3><table><thead><tr><th>css名</th><th>表示规则</th></tr></thead><tbody><tr><td>shop</td><td>功能区</td></tr><tr><td>loginbar</td><td>登录条</td></tr><tr><td>logo</td><td>标志</td></tr><tr><td>banner</td><td>广告位</td></tr><tr><td>hot</td><td>热点</td></tr><tr><td>news</td><td>新闻</td></tr><tr><td>like</td><td>赞</td></tr><tr><td>download</td><td>下载</td></tr><tr><td>search</td><td>搜索</td></tr><tr><td>menu</td><td>菜单</td></tr><tr><td>submenu</td><td>子菜单</td></tr><tr><td>friendlink</td><td>友情链接</td></tr><tr><td>scroll</td><td>滚动</td></tr><tr><td>tags</td><td>标签</td></tr><tr><td>article</td><td>文章</td></tr><tr><td>list</td><td>列表</td></tr><tr><td>msg</td><td>指需要传达的信息</td></tr><tr><td>info</td><td>承载信息的简讯</td></tr><tr><td>copyright</td><td>版权</td></tr><tr><td>tips</td><td>提示</td></tr><tr><td>title</td><td>标题</td></tr><tr><td>joinus</td><td>加入我们</td></tr><tr><td>guide</td><td>指南</td></tr><tr><td>service</td><td>服务</td></tr><tr><td>register</td><td>注册</td></tr><tr><td>status</td><td>状态</td></tr><tr><td>vote</td><td>投票</td></tr><tr><td>partner</td><td>合作</td></tr><tr><td>btn</td><td>按钮</td></tr><tr><td>current</td><td>当前</td></tr><tr><td>icon</td><td>图标</td></tr><tr><td>note</td><td>注释</td></tr></tbody></table><p><em>注意，用id选择器命名时，需要注意以下几点：</em></p><ul><li>使用英文</li><li>小写</li><li>不添加连接符，如<code>-</code>或<code>_</code></li><li>除大众广知的（如：msg、btn）尽量不缩写</li></ul><h2 id="5-常见css文件命名表"><a href="#5-常见css文件命名表" class="headerlink" title="5. 常见css文件命名表"></a>5. 常见css文件命名表</h2><table><thead><tr><th>css名</th><th>表示规则</th></tr></thead><tbody><tr><td>base.css</td><td>基础样式表</td></tr><tr><td>common.css</td><td>公用</td></tr><tr><td>themes.css</td><td>主题</td></tr><tr><td>reset.css</td><td>重设</td></tr><tr><td>font.css</td><td>文字</td></tr><tr><td>layout.css</td><td>版面</td></tr><tr><td>module.css</td><td>模块</td></tr><tr><td>column.css</td><td>专栏</td></tr><tr><td>…</td><td>等等</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;在前端领域，&lt;code&gt;CSS&lt;/code&gt;(层叠样式表:Cascading Style Sheets)是绕不过的话题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;样式表定义如何显示 HTML 元素，就像 HTML 中的字体标签和颜色属性所起的作用那样。样式通常保存在外部的 &lt;code&gt;.css&lt;/code&gt; 文件中。我们只需要编辑一个简单的 CSS 文档就可以改变所有页面的布局和外观。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然CSS初学者易于上手，且趣味性十足，但是作为一项工程而言，还是需要有一定规范约束的。这里简单介绍下关于css的一些规范。&lt;/p&gt;
&lt;h2 id=&quot;1-书写顺序&quot;&gt;&lt;a href=&quot;#1-书写顺序&quot; class=&quot;headerlink&quot; title=&quot;1. 书写顺序&quot;&gt;&lt;/a&gt;1. 书写顺序&lt;/h2&gt;&lt;p&gt;一般而言css都有一定的书写顺序，而不是想起来什么属性写说明属性。一般css的书写顺序为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;位置（z-index position top display float …）&lt;/li&gt;
&lt;li&gt;大小边距（width padding margin …）&lt;/li&gt;
&lt;li&gt;文字（font line-height letter-spacing color …）&lt;/li&gt;
&lt;li&gt;背景（background border …）&lt;/li&gt;
&lt;li&gt;其他（animation transtion …）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="css" scheme="https://www.zhuxingmin.com/tags/css/"/>
    
      <category term="规范" scheme="https://www.zhuxingmin.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>JS来一个极简的每日毒鸡汤</title>
    <link href="https://www.zhuxingmin.com/2020/12/14/JS%E6%9D%A5%E4%B8%80%E4%B8%AA%E6%9E%81%E7%AE%80%E7%9A%84%E6%AF%8F%E6%97%A5%E6%AF%92%E9%B8%A1%E6%B1%A4/"/>
    <id>https://www.zhuxingmin.com/2020/12/14/JS来一个极简的每日毒鸡汤/</id>
    <published>2020-12-14T13:12:38.000Z</published>
    <updated>2020-12-21T00:41:32.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现了基于node的一个发送邮件的小插件，逛论坛看别人用它做了一些有意思的东西，也模仿着搞一个分享下~<br>重在分享，重在分享！</p><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><h3 id="1-目标"><a href="#1-目标" class="headerlink" title="1. 目标"></a>1. 目标</h3><p>使用基于nodeJs的<code>nodemailer</code>定时发送<code>随机文案</code>给指定人。</p><p><img src="/images/posts/nodemailer.gif" alt="展示" title="展示"></p><a id="more"></a><h3 id="2-场景"><a href="#2-场景" class="headerlink" title="2. 场景"></a>2. 场景</h3><ul><li>定时发送情话给对象</li><li>每日发送给自己朋友圈文案内容</li><li>…</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1-所需技术"><a href="#1-所需技术" class="headerlink" title="1. 所需技术"></a>1. 所需技术</h3><ul><li>基础js即可</li></ul><h3 id="2-所需环境-插件"><a href="#2-所需环境-插件" class="headerlink" title="2. 所需环境/插件"></a>2. 所需环境/插件</h3><ul><li>nodeJs (环境)</li><li>nodemailer(发送邮件插件)</li><li>axios(获取邮件内容，如朋友圈文案、毒鸡汤等)</li><li>schedule(定时任务插件)</li></ul><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><p>除上述内容，我们需要有邮件相关信息:自己邮箱和对方邮箱、邮箱服务器地址及端口号、自己邮箱的授权码等。下面会有比较详细的介绍。</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="1-node环境安装"><a href="#1-node环境安装" class="headerlink" title="1. node环境安装"></a>1. node环境安装</h3><p>首先安装及配置node环境，官网下载安装即可。<a href="http://nodejs.cn/" title="node中文网" target="_blank" rel="noopener">node中文网</a></p><h3 id="2-插件安装"><a href="#2-插件安装" class="headerlink" title="2. 插件安装"></a>2. 插件安装</h3><p>自己按照需求安装即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodemailer：必须</span></span><br><span class="line">npm i nodemailer</span><br><span class="line"></span><br><span class="line"><span class="comment">// axios：获取随机鸡汤（毒鸡汤）作为邮件内容；非必须</span></span><br><span class="line">npm i axios</span><br><span class="line"></span><br><span class="line"><span class="comment">// schedule：定时任务；非必须</span></span><br><span class="line">npm i schedule</span><br></pre></td></tr></table></figure><h3 id="3-项目配置"><a href="#3-项目配置" class="headerlink" title="3. 项目配置"></a>3. 项目配置</h3><ol><li>新建个空目录作为项目目录</li><li>在终端（或者cmd模式）—— <code>npm init</code></li><li>项目目录下新建<code>index.js</code></li></ol><h3 id="4-index详细配置"><a href="#4-index详细配置" class="headerlink" title="4. index详细配置"></a>4. index详细配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">'nodemailer'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">default</span>: Axios &#125; = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"><span class="keyword">const</span> schedule = <span class="built_in">require</span>(<span class="string">'node-schedule'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文案</span></span><br><span class="line"><span class="keyword">const</span> getMsg = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 提供几个文案获取接口,随便选即可。</span></span><br><span class="line">    <span class="comment">// 毒鸡汤： https://du.shadiao.app/api.php</span></span><br><span class="line">    <span class="comment">// 朋友圈： https://pyq.shadiao.app/api.php</span></span><br><span class="line">    <span class="comment">// 彩虹屁： https://chp.shadiao.app/api.php</span></span><br><span class="line">    <span class="comment">// 骂人宝典： https://nmsl.shadiao.app/api.php</span></span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">'https://du.shadiao.app/api.php'</span>; </span><br><span class="line">    <span class="keyword">return</span> Axios.get(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送邮件函数</span></span><br><span class="line"><span class="keyword">const</span> sendEmail = <span class="keyword">async</span> msg =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> myEmail = <span class="string">"xxxxxx@163.com"</span>;  <span class="comment">// 用户(自己)邮箱</span></span><br><span class="line">    <span class="keyword">let</span> passCode = <span class="string">"xxxxxx"</span>;  <span class="comment">// 用户(自己)邮箱授权码</span></span><br><span class="line">    <span class="keyword">let</span> mailTo = <span class="string">"xxxxxx@xxx.xxx"</span>;    <span class="comment">// 对方邮箱</span></span><br><span class="line">    <span class="comment">// 用户账号信息,以163邮箱为例</span></span><br><span class="line">    <span class="keyword">let</span> transporter = nodemailer.createTransport(&#123;</span><br><span class="line">        host: <span class="string">'smtp.163.com'</span>,   <span class="comment">// 服务器地址</span></span><br><span class="line">        port: <span class="number">25</span>,   <span class="comment">// 协议端口号</span></span><br><span class="line">        auth: &#123;</span><br><span class="line">            user: myEmail,  <span class="comment">// 用户邮箱</span></span><br><span class="line">            pass: passCode  <span class="comment">// 授权码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 发送内容编辑</span></span><br><span class="line">    <span class="keyword">let</span> mailMsg = <span class="keyword">await</span> transporter.sendMail(&#123;</span><br><span class="line">        <span class="keyword">from</span>: myEmail,   <span class="comment">// 发件人(自己)</span></span><br><span class="line">        to: mailTo,   <span class="comment">// 收件人</span></span><br><span class="line">        subject: <span class="string">'mailer测试：毒鸡汤文案'</span>,   <span class="comment">// 标题</span></span><br><span class="line">        text: msg</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 成功后打印下~</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`发送成功，发送内容为：<span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时发送 每天中午12:30（自己随便改） 发送自己“喜欢”的内容给指定人</span></span><br><span class="line">schedule.scheduleJob(&#123;</span><br><span class="line">    hour: <span class="number">12</span>,</span><br><span class="line">    minute: <span class="number">30</span></span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`启动任务：<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>`</span>);</span><br><span class="line">    getMsg().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        sendEmail(res.data);    <span class="comment">// 发送邮件</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="comment">// console.log(`启动任务：$&#123;new Date()&#125;`);</span></span><br><span class="line"><span class="comment">// getMsg().then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     sendEmail(res.data);    // 发送邮件</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上述代码，完成简易的每日毒鸡汤发送给相应邮箱。但我们可以看出，这只是基于node的一些个小插件的使用而已。虽然简单，但是发挥一下，在合适的时间用在合适的地方还是会有一些效果出现的~</p><p>喜欢的可以关注公众号【流眸】回复【201219】获取该项目代码~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近发现了基于node的一个发送邮件的小插件，逛论坛看别人用它做了一些有意思的东西，也模仿着搞一个分享下~&lt;br&gt;重在分享，重在分享！&lt;/p&gt;
&lt;h2 id=&quot;期望&quot;&gt;&lt;a href=&quot;#期望&quot; class=&quot;headerlink&quot; title=&quot;期望&quot;&gt;&lt;/a&gt;期望&lt;/h2&gt;&lt;h3 id=&quot;1-目标&quot;&gt;&lt;a href=&quot;#1-目标&quot; class=&quot;headerlink&quot; title=&quot;1. 目标&quot;&gt;&lt;/a&gt;1. 目标&lt;/h3&gt;&lt;p&gt;使用基于nodeJs的&lt;code&gt;nodemailer&lt;/code&gt;定时发送&lt;code&gt;随机文案&lt;/code&gt;给指定人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/nodemailer.gif&quot; alt=&quot;展示&quot; title=&quot;展示&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="node" scheme="https://www.zhuxingmin.com/tags/node/"/>
    
      <category term="nodemailer" scheme="https://www.zhuxingmin.com/tags/nodemailer/"/>
    
      <category term="axios" scheme="https://www.zhuxingmin.com/tags/axios/"/>
    
      <category term="schedule" scheme="https://www.zhuxingmin.com/tags/schedule/"/>
    
  </entry>
  
  <entry>
    <title>vue首页白屏清除缓存解决方案</title>
    <link href="https://www.zhuxingmin.com/2020/12/03/vue%E9%A6%96%E9%A1%B5%E7%99%BD%E5%B1%8F%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://www.zhuxingmin.com/2020/12/03/vue首页白屏清除缓存解决方案/</id>
    <published>2020-12-03T09:37:29.000Z</published>
    <updated>2020-12-07T02:40:32.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>近期vue项目在构建完成上线之后，每次往线上更新版本，总会收到一部分反馈——web页面白屏，需要清除缓存数据重新加载才能正常访问。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>首先排除掉了<code>publicPath设置</code>问题，因为大部分用户能正常访问到页面，无报错。其次排除首页加载过慢问题，因为白屏无论多久都不会渲染页面。最终定位到<code>缓存问题</code>，产生原因如下：</p><blockquote><p>在首次上线项目时，build生成的资源文件直接放到服务端上线即可。但是当第n（n&gt;1）次上线后，由于在用户端会默认缓存index.html入口文件，而由于vue打包生成的css/js都是哈希值，跟上次的文件名都不同，因此会出现找不到css/js的情况，导致白屏的产生。</p></blockquote><a id="more"></a><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="1-meta标签"><a href="#1-meta标签" class="headerlink" title="1. meta标签"></a>1. meta标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-cache, no-store, must-revalidate"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Expires"</span> <span class="attr">content</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-时间戳区分"><a href="#2-时间戳区分" class="headerlink" title="2. 时间戳区分"></a>2. 时间戳区分</h3><p>在项目的配置页面添加打包配置，根据vue脚手架不同分以下两种情况：</p><ol><li><p><a href="mailto:vue-cli@2.x" target="_blank" rel="noopener">vue-cli@2.x</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.conf.js</span></span><br><span class="line"><span class="keyword">const</span> Timestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">output: &#123;</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    filename: utils.assetsPath(<span class="string">'js/[name].[chunkhash].'</span> + Timestamp + <span class="string">'js'</span>),</span><br><span class="line">    chunkFilename: utils.assetsPath(<span class="string">'js/[id].[chunkhash].'</span> + Timestamp + <span class="string">'js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="mailto:vue-cli@3.x" target="_blank" rel="noopener">vue-cli@3.x</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> Timestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        config.output.filename = <span class="string">`js/[name].<span class="subst">$&#123;Timestamp&#125;</span>.js?t=[hash]`</span>;</span><br><span class="line">        config.output.chunkFilename = <span class="string">`js/[id].<span class="subst">$&#123;Timestamp&#125;</span>.js?t=[hash]`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">            <span class="comment">// 为生产环境修改配置...</span></span><br><span class="line">            config.plugin(<span class="string">'extract-css'</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> [&#123;</span><br><span class="line">                filename: <span class="string">`css/[name].<span class="subst">$&#123;Timestamp&#125;</span>.css`</span>,</span><br><span class="line">                chunkFilename: <span class="string">`css/[name].<span class="subst">$&#123;Timestamp&#125;</span>.css`</span></span><br><span class="line">            &#125;])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-服务端配置-nginx"><a href="#3-服务端配置-nginx" class="headerlink" title="3. 服务端配置(nginx)"></a>3. 服务端配置(nginx)</h3><p>这个有非常重要，需要跟服务端同事沟通，请他们在服务端配合配置nginx服务。<br>服务端配置主要解决：</p><ul><li>设置<code>index.html</code>在用户端不缓存，这样每次拉取的都是线上最新资源；</li><li>设置<code>css</code>和<code>js</code>文件一定的缓存期，合理利用缓存。</li></ul><p>这样配置的好处是，如果线上资源没有更新，我们合理的利用缓存对大体积资源（样式脚本等）缓存，如果更新了资源，那么<code>index.html</code>文件则实时更新，用户端所得到的html文件也是最新资源，样式及脚本资源都会重新获取服务器最新资源缓存到本地。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">90</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">22782</span>.s1.natapp.cc;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">          <span class="attribute">root</span> /apps/laikePay/;</span><br><span class="line">          <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">location</span><span class="regexp"> ^~</span> /beauty/&#123;</span><br><span class="line">                  <span class="attribute">alias</span> /apps/laikeBeauty/;</span><br><span class="line">        <span class="comment">#以下配置解决html不缓存，css和js分别缓存7天和30天</span></span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$request_filename</span> <span class="regexp">~* .*\.(?:htm|html)$)</span></span><br><span class="line"><span class="regexp"></span>            &#123;</span><br><span class="line">                  <span class="attribute">add_header</span> Cache-Control <span class="string">"private, no-store, no-cache"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$request_filename</span> <span class="regexp">~* .*\.(?:js|css)$)</span></span><br><span class="line"><span class="regexp"></span>            &#123;</span><br><span class="line">                  <span class="attribute">add_header</span> Cache-Control max-age=<span class="number">604800</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$request_filename</span> <span class="regexp">~* .*\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm)$)</span></span><br><span class="line"><span class="regexp"></span>            &#123;</span><br><span class="line">                  <span class="attribute">add_header</span> Cache-Control max-age=<span class="number">2592000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                  <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /beauty/index.html;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="attribute">location</span> <span class="regexp"> ^~</span> /beautyThemeChange/&#123;</span><br><span class="line">            <span class="attribute">alias</span> /apps/laikeBeautyThemeChange/;</span><br><span class="line">            <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /beautyThemeChange/index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp"> ^~</span> /retail/&#123;</span><br><span class="line">         <span class="comment">#   alias /apps/laikeRetail/;</span></span><br><span class="line">         <span class="comment">#   try_files $uri $uri/ /retail/index.html;</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://22782.s1.natapp.cc/beauty/;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">#location ^~ /merchantPhoneApp/ &#123;</span></span><br><span class="line">        <span class="comment">#alias /apps/merchantPhoneApp/;</span></span><br><span class="line">        <span class="comment">#try_files $uri $uri/ /merchantPhoneApp/index.html;</span></span><br><span class="line">      <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h2&gt;&lt;p&gt;近期vue项目在构建完成上线之后，每次往线上更新版本，总会收到一部分反馈——web页面白屏，需要清除缓存数据重新加载才能正常访问。&lt;/p&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h2&gt;&lt;p&gt;首先排除掉了&lt;code&gt;publicPath设置&lt;/code&gt;问题，因为大部分用户能正常访问到页面，无报错。其次排除首页加载过慢问题，因为白屏无论多久都不会渲染页面。最终定位到&lt;code&gt;缓存问题&lt;/code&gt;，产生原因如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在首次上线项目时，build生成的资源文件直接放到服务端上线即可。但是当第n（n&amp;gt;1）次上线后，由于在用户端会默认缓存index.html入口文件，而由于vue打包生成的css/js都是哈希值，跟上次的文件名都不同，因此会出现找不到css/js的情况，导致白屏的产生。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="https://www.zhuxingmin.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——JS打包工具</title>
    <link href="https://www.zhuxingmin.com/2020/10/28/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.zhuxingmin.com/2020/10/28/webpack实战——JS打包工具/</id>
    <published>2020-10-28T06:44:40.000Z</published>
    <updated>2020-10-29T10:20:31.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面篇章叙述了关于webpack的许多内容，从入门，打包第一个模块，到进阶，最后到本地、生产及打包的优化。本篇则提及一下在JavaScript社区中另外的一些类似的打包工具，它们有的更加轻量、简洁，有的则更专注于某类特定场景等。通过了解这些，希望会有助于我们开发时从更多的角度和方向来认识打包工具及其发展，进而选用更加适合我们项目的打包工具。</p><h2 id="1-Rollup"><a href="#1-Rollup" class="headerlink" title="1. Rollup"></a>1. Rollup</h2><blockquote><p>Rollup专注于JavaScript的打包。</p></blockquote><p>它当然也支持其他类型的模块，但是总体而言在通用性是不及webpack，但讨论专注性，Rollup则更像一把手术刀，能精准的瞄准于JavaScript。如果有项目需求仅仅是打包JavaScript，那么Rollup则更可能是我们的第一选择。</p><a id="more"></a><h3 id="1-1-配置"><a href="#1-1-配置" class="headerlink" title="1.1 配置"></a>1.1 配置</h3><p>简单示例下Rollup是如何工作的。</p><p>首先全局安装Rollup</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install rollup -g</span><br></pre></td></tr></table></figure><p>然后创建Rollup配置文件<code>rollup.config.js</code>以及需要打包的项目文件<code>app.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rollup.config.js</span></span><br><span class="line"><span class="built_in">module</span> exports = &#123;</span><br><span class="line">    input: <span class="string">'src/app.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        file: <span class="string">'dist/bundle.js'</span>,</span><br><span class="line">        format: <span class="string">'cjs'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'This is a App with Rollup ~'</span>);</span><br></pre></td></tr></table></figure><p>接下来执行指令进行打包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollup -c rollup.config.js</span><br></pre></td></tr></table></figure><p><em>其中，-c参数是告诉Rollup使用该配置文件。</em></p><p>打包结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'This is a App with Rollup ~'</span>);</span><br></pre></td></tr></table></figure><p>从上可以看出，打包出来的资源文件非常干净，Rollup没有添加额外代码，甚至连第一行的<code>use strict</code>都可以通过配置去掉。而如果我们使用webpack去打包处理，则会多出许多冗余产物，即使我们将上述的一行js进行打包，打包后资源文件也至少会有几十行代码存在。</p><p>显然，如果针对于JavaScript进行打包处理，Rollup更为符合我们的预期。</p><h3 id="1-2-tree-shaking"><a href="#1-2-tree-shaking" class="headerlink" title="1.2 tree shaking"></a>1.2 tree shaking</h3><p>上一篇也描述过关于tree shaking，用来检测和去除死代码。而实际上最初tree shaking这个特性是由Roolup实现的，然后被Webpack借鉴。</p><p>Rollup的tree shaking也是基于ES6 Modules的静态分析，找出没有被引用的模块，将其从最后生成的bundle中排除。</p><p>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">'./util.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`1 + 2 = <span class="subst">$&#123;add(<span class="number">1</span>, <span class="number">2</span>)&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在这个简单工程中，sub方法没有被引用。</p><p>执行命令对其打包后，发现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`1 + 2 = <span class="subst">$&#123;add(<span class="number">1</span>, <span class="number">2</span>)&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>从打包结果看，bundle也如我们所期望，输出的内容简洁，无任何附加代码，且sub函数也没有被打包进来。</p><h3 id="1-3-可选的输出格式"><a href="#1-3-可选的输出格式" class="headerlink" title="1.3 可选的输出格式"></a>1.3 可选的输出格式</h3><p>在webpack中，无法选择输出资源的模块形式，例如amd、esm、umd、system等，而在Rollup中可以通过配置output.format开发者选择输出资源的模块形式。</p><p>这个特性对于打包JavaScript库很有用，因为一个库往往需要支持多种不同的模块形式，而通过Rollup几个命令就可以将一份源代码打包为多份支持不同模式的资源文件。</p><p>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当output.format是cjs时（cjs:CommonJs），则输出是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(exports, <span class="string">'__esModule'</span>, &#123;<span class="attr">value</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">exports.add = add;</span><br><span class="line">exports.sub = sub;</span><br></pre></td></tr></table></figure><p>当时esm时（ES6 Modules），输出则是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; add, sub &#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-使用Rollup构建JavaScript库"><a href="#1-4-使用Rollup构建JavaScript库" class="headerlink" title="1.4 使用Rollup构建JavaScript库"></a>1.4 使用Rollup构建JavaScript库</h3><p>在实际使用中，Rollup经常被用于打包一些库或框架（例如Vue、React等）。在React团队的一篇文章中曾提到使用Rollup的获益：</p><ul><li>最低限度的附加代码</li><li>对ES6 Modules的良好支持</li><li>通过tree shaking去除开发环境代码</li><li>通过自定义插件来实现React的一些特殊的打包逻辑</li></ul><p>Rollup在设计之初就是主要偏向于JavaScript库的构建，以至于它并没有像Webpack那样对于应用开发有很大的支持，所以我们使用Rollup之前要斟酌下是否偏向自己的项目需求。</p><h2 id="2-Parcel"><a href="#2-Parcel" class="headerlink" title="2. Parcel"></a>2. Parcel</h2><p>Parcel在前端打包工具中属于后起之秀：2017年8月才在npm上有版本记录。而其出名的则是打包速度：“Parcel官网中宣称自己是零配置的，在有缓存的情况下其打包速度比webpack快近8倍。”它的出现，则是正好契合了当时开发者对于Webpack打包速度慢和配置复杂的抱怨，从而吸引许多用户转用Parcel。</p><h3 id="2-1-打包速度"><a href="#2-1-打包速度" class="headerlink" title="2.1 打包速度"></a>2.1 打包速度</h3><p>Parcel在打包速度的优化上主要做了3件事：</p><ul><li>利用worker来并行执行任务</li><li>文件系统缓存</li><li>资源编译处理流程优化</li></ul><p>这三点的前两点其实Webpack已经在做，在此不再详细分析。重点看第三点。</p><p>例如对于babel-loader的工作流程进行分析，大体为以下几步：</p><ol><li>将ES6形式的字符串内容解析为AST（抽象语法树）；</li><li>对AST进行语法转换；</li><li>生成ES5代码，并作为字符串返回。</li></ol><p>这是一个很正常的资源处理过程，但假设是多个loader一次对资源进行处理呢？</p><p>对此，Parcel的处理流程很简单，它并没有loader的概念，而是自己的一套体系处理：<strong>它在不同的编译处理流程之间可以用AST作为输入和输出，不需要转换为字符串处理</strong>。对于单个的每一步来说，如果前面已经解析过AST，那么直接使用上一步解析和转换好的AST就可以，只需要在最后一步输出的时候再将AST转回字符串即可。如此说来，中间的流程处理由多次变为了一次，能够节省的时间可不是一星半点！</p><h3 id="2-2-零配置"><a href="#2-2-零配置" class="headerlink" title="2.2 零配置"></a>2.2 零配置</h3><p>请看例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'Hello Parcel!'</span>);</span><br></pre></td></tr></table></figure><p>先全局安装parcel：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install parcel -g</span><br></pre></td></tr></table></figure><p>然后执行打包命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parcel index.html</span><br><span class="line"><span class="comment">// 如果要打包为文件，则执行如下：</span></span><br><span class="line">parcel build index.html</span><br></pre></td></tr></table></figure><p>如果不加build，则是开发模式，使用浏览器则可以观察：localhost:1234。</p><p>如果打包为文件，则会创建一个dist文件目录，资源会添加到该目录下。</p><p>其实对于一个正常的前端项目来说，一般都会有一些配置的，不然也就失去了定制性。虽然parcel并没有配置文件，但是本质上它还是把配置进行了切分，交给babel、postHTML、postCSS等一些特定的工具进行了管理。</p><p>与Webpack相比，Parcel优势在于快速和灵巧，如果针对于不需要深度定制并且要求短时间搭建，那么Parcel则也可以作为一个比较好的选择来作为备选。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇介绍了JavaScript社区中两个除了webpack之外比较主流的两个打包工具：Rollup和Parcel。</p><p>Rollup更专注于JavaScript的打包，本身附加的代码更少，具备tree shaking，可以输出多种形式的模块。</p><p>Parcel则在资源处理流程方面做了改进优化，以追求更快的打包速度。同时零配置的特性可以减少很多项目开发中花费在环境维护上的成本。</p><p>在进行技术选型的时候，我们不仅要结合目前工具特性，更是要选择出针对我们项目进行特定考察，以及对项目之后的扩展也要考虑在内，从而结合多方面选择对项目最有利的工具来使用。同时我们也要看此工具在社区中的生态，是否能保持良好的社区生态以及维护状况，亦是我们需要考虑在内的因素之一。</p><p>webpack实战系列内容到此结束~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面篇章叙述了关于webpack的许多内容，从入门，打包第一个模块，到进阶，最后到本地、生产及打包的优化。本篇则提及一下在JavaScript社区中另外的一些类似的打包工具，它们有的更加轻量、简洁，有的则更专注于某类特定场景等。通过了解这些，希望会有助于我们开发时从更多的角度和方向来认识打包工具及其发展，进而选用更加适合我们项目的打包工具。&lt;/p&gt;
&lt;h2 id=&quot;1-Rollup&quot;&gt;&lt;a href=&quot;#1-Rollup&quot; class=&quot;headerlink&quot; title=&quot;1. Rollup&quot;&gt;&lt;/a&gt;1. Rollup&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Rollup专注于JavaScript的打包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它当然也支持其他类型的模块，但是总体而言在通用性是不及webpack，但讨论专注性，Rollup则更像一把手术刀，能精准的瞄准于JavaScript。如果有项目需求仅仅是打包JavaScript，那么Rollup则更可能是我们的第一选择。&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——打包优化【下】</title>
    <link href="https://www.zhuxingmin.com/2020/10/27/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E3%80%90%E4%B8%8B%E3%80%91/"/>
    <id>https://www.zhuxingmin.com/2020/10/27/webpack实战——打包优化【下】/</id>
    <published>2020-10-27T06:47:16.000Z</published>
    <updated>2020-10-28T07:26:01.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是webpack打包优化【下】篇。前几篇针对性能要求高的项目从加快打包速度、减小资源体积方面入手，提出了一些优化政策，然后测试都可起到一定优化效果。本篇描述<code>死代码的检测与去除</code>。</p><h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h2><h3 id="1-死代码检测去除"><a href="#1-死代码检测去除" class="headerlink" title="1 死代码检测去除"></a>1 死代码检测去除</h3><p>首先抛出问题，什么是死代码？</p><blockquote><p>工程中没有被引用过的模块，这部分代码将永远无法被执行，称为“死代码”。</p></blockquote><a id="more"></a><p>那知道了什么是死代码，如何检测去除呢？</p><p>在前面我们介绍过，<strong>ES6 module 依赖关系的构建是在代码编译时而非运行时</strong>。基于这项特性webpack提供了tree shaking功能。这个功能便可以<strong>在打包过程中帮助我们检测没有被引用的模块，然后对这部分代码进行标记，并在资源压缩时将它们从最终的bundle中去掉</strong>。</p><p>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./util'</span>;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 没有被任何其他模块引用，因此属于死代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is bar'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在webpack打包时就会对bar()添加一个标记，在正常本地开发环境下它依然会存在，但是在生产环境压缩资源那一环节则会被移除掉。</p><p>tree shaking有时可以使得bundle资源体积显著减小，但需要一些前提条件。</p><h3 id="2-ES6-Module"><a href="#2-ES6-Module" class="headerlink" title="2 ES6 Module"></a>2 ES6 Module</h3><p><strong>tree shaking 只对ES6 Module生效。</strong> 有时候我们发现算只引用了某个库中的一个接口，却把整个库都加载了进来，使得bundle体积并没有什么变化，可能原因是该库是用CommonJS导出的，而不是ES6 Module。当然，为了更好地向下兼容，自然是使用CommonJS形式是库依然很多。而排开第三方库，在我们自己书写模块或者库时，可以尽可能的选择ES6 Module形式导出，这样tree shaking的效率会更高。</p><h3 id="3-使用webpack进行依赖关系构建"><a href="#3-使用webpack进行依赖关系构建" class="headerlink" title="3 使用webpack进行依赖关系构建"></a>3 使用webpack进行依赖关系构建</h3><p>一般我们都会在工程中使用到babel-loader，<strong>如果我们有使用到，那么一定要通过禁止它的模块依赖解析</strong>。原因是如果我们使用babel-loader来做依赖解析，那么webpack接收到的一般都是转化过的CommonJS形式的模块，那就无法对其进行tree shaking。</p><p>禁用babel-loader模块依赖解析配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        ryles: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            presets: [</span><br><span class="line">                                <span class="comment">// 在这里加上modules: false</span></span><br><span class="line">                                [@babel/preset-env, &#123; <span class="attr">modules</span>: <span class="literal">false</span> &#125;]</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用压缩工具去除死代码"><a href="#4-使用压缩工具去除死代码" class="headerlink" title="4. 使用压缩工具去除死代码"></a>4. 使用压缩工具去除死代码</h3><p>tree shaking本身只是为死代码添加上标记，而真正意义上去除死代码则是通过压缩工具来进行的，而此工具之前介绍过：<code>terser-webpack-plugin</code>。在此不再赘述。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过【上】【中】【下】三篇描述，介绍的一些打包优化的方案均可以对项目有不同程度的优化，无论是打包速度还是减小资源体积，都有涉及。然而我们更需要清楚地了解到每一种优化策略都有其使用场景，并不是任何一个点放在一切项目中都有效。</p><p>当然，我们更需要不断培养自己的能力，当发现性能问题时，根据现有情况自己多加思考，分析出原因，然后对症下药。</p><p>下一篇介绍更多的JavaScript打包工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是webpack打包优化【下】篇。前几篇针对性能要求高的项目从加快打包速度、减小资源体积方面入手，提出了一些优化政策，然后测试都可起到一定优化效果。本篇描述&lt;code&gt;死代码的检测与去除&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;tree-shaking&quot;&gt;&lt;a href=&quot;#tree-shaking&quot; class=&quot;headerlink&quot; title=&quot;tree shaking&quot;&gt;&lt;/a&gt;tree shaking&lt;/h2&gt;&lt;h3 id=&quot;1-死代码检测去除&quot;&gt;&lt;a href=&quot;#1-死代码检测去除&quot; class=&quot;headerlink&quot; title=&quot;1 死代码检测去除&quot;&gt;&lt;/a&gt;1 死代码检测去除&lt;/h3&gt;&lt;p&gt;首先抛出问题，什么是死代码？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;工程中没有被引用过的模块，这部分代码将永远无法被执行，称为“死代码”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——打包优化【中】</title>
    <link href="https://www.zhuxingmin.com/2020/10/19/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E3%80%90%E4%B8%AD%E3%80%91/"/>
    <id>https://www.zhuxingmin.com/2020/10/19/webpack实战——打包优化【中】/</id>
    <published>2020-10-19T11:20:29.000Z</published>
    <updated>2020-10-27T06:36:54.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇从<code>多线程打包</code>和<code>缩小打包作用域</code>两个方面入手，对webpack打包层面做出优化。本篇描述从<code>动态链接库思想</code>方面继续深入探究打包层面的深度优化。</p><h2 id="动态链接库与DLLPlugin"><a href="#动态链接库与DLLPlugin" class="headerlink" title="动态链接库与DLLPlugin"></a>动态链接库与DLLPlugin</h2><blockquote><p>动态链接库（Dynamic Link Library 或者 Dynamic-link Library，缩写为 DLL），是微软公司在微软Windows操作系统中，实现共享函数库概念的一种方式。这些库函数的扩展名是 ”.dll”、”.ocx”（包含ActiveX控制的库）或者 “.drv”（旧式的系统驱动程序）。</p></blockquote><a id="more"></a><p>当一段相同的子程序被多个程序调用时，为了减少内存消耗，可以将这段子程序存储为一个可执行文件，当被多个程序调用时只在内存中生成和使用同一个实例。</p><p>今天要介绍的主角“DLLPlugin”则借鉴了动态链接库的思路，对于第三方模块或者一些不常变化的模块预先进行编译和打包，然后再项目实际构建过程中直接取用。不过区别还是有的，DLLPlugin实际生成的文件是JS文件而不是动态链接库。在打包vendor的时候还会附加生成一份vendor的模块清单，这份清单将会在工程业务模块打包时起到链接和索引的作用。</p><h3 id="1-vendor配置"><a href="#1-vendor配置" class="headerlink" title="1 vendor配置"></a>1 vendor配置</h3><p>首先需要为动态链接库单独创建一个Webpack配置文件，例如：webpack.vendor.config.js，注意要与webpack.config.js区分开来。</p><p>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.vendor.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> dllAssetPath = path.join(__dirname, <span class="string">'dll'</span>);</span><br><span class="line"><span class="keyword">const</span> dllLibraryName = <span class="string">'dllExample'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: [<span class="string">'react'</span>],</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: dllAssetPath,</span><br><span class="line">        filename: <span class="string">'vendor.js'</span>,</span><br><span class="line">        library: dllLibraryName</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            name: dllLibraryName,</span><br><span class="line">            path: path.join(dllAssetPath, <span class="string">'manifest.json'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，entry指定了将哪些模块打包为vendor，plugins的部分引入了DLLPlugin，并有如下配置：</p><ul><li>name: 导出的dll library的名字，需要与output.library的值对应；</li><li>path: 资源清单的绝对路径，业务打包时将会使用这个清单进行模块索引；</li></ul><h3 id="2-vendor打包"><a href="#2-vendor打包" class="headerlink" title="2 vendor打包"></a>2 vendor打包</h3><p>接下来就要打包vendor并且生成资源清单。为后续方便操作，可以在package.json中配置一条运行指令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// pachage.json</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "scripts": &#123;</span><br><span class="line">        ...</span><br><span class="line">        "dll": "webpack --config webpack.vendor.config.js"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行<code>npm run dll</code>，会发现生成了一个dll目录，里面对应有两个文件：</p><ul><li>vendor.js： 库的代码</li><li>manifest.json： 资源清单</li></ul><p>感兴趣的可以打开这两个文件阅读一下。</p><h3 id="3-链接到业务代码"><a href="#3-链接到业务代码" class="headerlink" title="3 链接到业务代码"></a>3 链接到业务代码</h3><p>试过之后，我们就要考虑将vendor链接到项目中去了。这里推荐与DLLPlugin配套的插件“DLLReferencePlugin”，它起到索引和链接作用。在工程的webpack配置文件中（注意是webpack.config.js，不是vendor的配置文件），通过DLLReferencePlugin来获取刚才打包好的资源清单，然后在页面中添加vendor.js就可以引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.cinfig.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">            manifest: <span class="built_in">require</span>(path.join(__dirname, <span class="string">'dll/manifest.json'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 index.html 引入会即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dll/vendor.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置完毕后，当页面执行到vendor.js时，会声明全局变量dllExample，而manifest相当于注入app.js的资源地图，app.js会通过name字段找到名为DLLExample的library，再进一步获取其内部模块。</p><h3 id="4-潜在问题"><a href="#4-潜在问题" class="headerlink" title="4 潜在问题"></a>4 潜在问题</h3><p>细心的小伙伴或许已经发现了，在当前配置中会存在一个问题：当打开manifest.json文件后，可以发现每个模块都会有一个id，其值是按照数字顺序递增的，而业务代码在引用vendor中模块时也是引用这个数字id，当我们更vendor时这个数字id也会随之发生改变。</p><p>现假设我们工程目录中有如下资源文件，并每个资源都加上了chunk hash：</p><ul><li>vendor@[hasn].js</li><li>pageUser@[hasn].js</li><li>pageIndex@[hasn].js</li><li>util@[hasn].js</li></ul><p>现在vendor中you一些模块，例如包含了react，其id为5.当尝试添加更多模块到vendor中的时候，那么重新进行Dll构建时，moment.js可能出现在react之前，此时react的id会变为6.而pageUser和pageIndex是通过id进行引用的，因此他们的文件内容也发生了改变。此时我们会面临如下情况：</p><ol><li>两个页面的chunk hash均发生了改变。这是我们不希望看到的，因为他们本身并无变化，但是vendor的改变却驱使用户不得不重新下载所有资源。</li><li>两个页面chunk hash没有改变，但是这种情况更为糟糕：vendor中的模块id改变了，但是用户没有更新缓存，使用的还是旧版本的内容，而引用不到新的vendor模块，导致页面发生错误。并且对于开发者而言，这个错误却难以排查，因为开发环境下一切正常！</li></ol><p>针对上述的问题2，解决方法是在打包vendor时添加上HashedModuleIdsPlugin，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.vendor.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            name: dllLibraryName,</span><br><span class="line">            path: path.join(dllAssetPath, <span class="string">'manifest.json'</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">// 添加HashedModuleIdsPlugin</span></span><br><span class="line">        <span class="keyword">new</span> webpack.HashedModuleIdsPlugin();</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>HashedModuleIdsPlugin是webpack3中被引入进来的，主要就是为了解决数字id的问题。HashedModuleIdsPlugin可以把id的生成算法修改为根据模块的引用路径生成一个字符串hash。</p></blockquote><p><em>注：从webpack3开始，模块id不仅可以是数字，也可以是字符串。</em></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇从动态链接库思想着手，介绍了DLLPlugin与其配套插件DLLReferencePlugin使用，将第三方库与一些不常改动的模块编译打包，处理为类似于动态链接库的JS文件，以此来节约服务器资源。<br>下一篇介绍打包优化最后一个环节：死代码检测与去除。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上篇从&lt;code&gt;多线程打包&lt;/code&gt;和&lt;code&gt;缩小打包作用域&lt;/code&gt;两个方面入手，对webpack打包层面做出优化。本篇描述从&lt;code&gt;动态链接库思想&lt;/code&gt;方面继续深入探究打包层面的深度优化。&lt;/p&gt;
&lt;h2 id=&quot;动态链接库与DLLPlugin&quot;&gt;&lt;a href=&quot;#动态链接库与DLLPlugin&quot; class=&quot;headerlink&quot; title=&quot;动态链接库与DLLPlugin&quot;&gt;&lt;/a&gt;动态链接库与DLLPlugin&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;动态链接库（Dynamic Link Library 或者 Dynamic-link Library，缩写为 DLL），是微软公司在微软Windows操作系统中，实现共享函数库概念的一种方式。这些库函数的扩展名是 ”.dll”、”.ocx”（包含ActiveX控制的库）或者 “.drv”（旧式的系统驱动程序）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——打包优化【上】</title>
    <link href="https://www.zhuxingmin.com/2020/10/10/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E3%80%90%E4%B8%8A%E3%80%91/"/>
    <id>https://www.zhuxingmin.com/2020/10/10/webpack实战——打包优化【上】/</id>
    <published>2020-10-10T07:23:20.000Z</published>
    <updated>2020-10-19T11:20:54.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇介绍一些webpack优化的配置方法，目的有二：</p><ol><li>打包速度更快</li><li>输出资源更小</li></ol><blockquote><p>注意：在软件工程领域有一条十分重要的功能经验，不要过早优化。在项目初期不要看到一个可以优化的点就去做优化，这样极有可能会增加尤其开发及维护的复杂度，并且从整体效果看，优化效果不会太理想。</p></blockquote><a id="more"></a><h2 id="1-HappyPack"><a href="#1-HappyPack" class="headerlink" title="1. HappyPack"></a>1. HappyPack</h2><blockquote><p>HappyPack是一个通过多线程来提升webpack打包速度的工具</p></blockquote><h3 id="1-1-工作原理"><a href="#1-1-工作原理" class="headerlink" title="1.1 工作原理"></a>1.1 工作原理</h3><p>在打工过程中，非常耗时的一个工作是<strong>使用loader将各种资源进行转译处理</strong>，例如常见的使用babel-loader将ES6+语法代码转译为ES5等。代码转移的工作流程如下：</p><ol><li>从配置中获取打包入口；</li><li>匹配loader规则，并对入口模块进行转译；</li><li>对转译后的模块进行依赖查找；</li><li>对新找到的模块重复步骤2)和3)，直到没有新的依赖模块。</li></ol><p>从上述步骤中可以看出，从步骤2)到步骤4)其实是一个递归的过程，webpack需要一步步地获取更下一级的资源然后逐个进行转译。为什么逐个？问题就在于webpack是单线程的。而HappyPack便将这里作为切入口，它的<strong>核心特性是可以开启多个线程，并行的对不同模块进行转译</strong>，这样便更加充分的利用计算机资源来提升打包速度。</p><h3 id="1-2-工程目标"><a href="#1-2-工程目标" class="headerlink" title="1.2 工程目标"></a>1.2 工程目标</h3><p><strong>HappyPack显然更加适用于转译任务比较繁重的工程</strong>，当我们把类似babel-loadre，ts-loader等迁移到HappyPack之上后，一般会有比较不错的效果，而对于sass-loader等本身消耗时间并不太多的功能则效果一般。</p><h3 id="1-3-单个loader优化"><a href="#1-3-单个loader优化" class="headerlink" title="1.3 单个loader优化"></a>1.3 单个loader优化</h3><p><strong>以babel-loader为例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [<span class="string">'react'</span>],</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用HappyPack：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用HappyPack：</span></span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                loader: <span class="string">'happypack/loader'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugin: [</span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">            loaders: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [<span class="string">'react'</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在module.rules中，我们使用happypack/loader替换掉了原来的babel-loader，而在plugins中添加了HappyPack插件，将原来的bebel-loader及其配置插入进去即可。</p><h3 id="1-4-多个loader优化"><a href="#1-4-多个loader优化" class="headerlink" title="1.4 多个loader优化"></a>1.4 多个loader优化</h3><p>在使用<strong>HappyPack对多个loader进行优化时，需要为每一个loader配置一个id，否则HappyPack无法知道rules与plugins的对应关系</strong>。</p><p><strong>这里以babel-loader及ts-loader为例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                loader: <span class="string">'happypack/loader?id=js'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                loader: <span class="string">'happypack/loader?id=ts'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugin: [</span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">            id: <span class="string">'js'</span>,</span><br><span class="line">            loaders: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        <span class="comment">// babel配置</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">            id: <span class="string">'ts'</span>,</span><br><span class="line">            loaders: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'ts-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        <span class="comment">// ts配置</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除上述配置之外，可以查阅官方文档查看更多的配置，例如线程数，debug模式等。</p><h2 id="2-缩小打包作用域"><a href="#2-缩小打包作用域" class="headerlink" title="2. 缩小打包作用域"></a>2. 缩小打包作用域</h2><p>从宏观角度看，提升性能的方式总结为两种：</p><ol><li>增加资源： 使用更多的CPU和内存，用更多的计算能力来缩短任务执行时间；</li><li>缩小范围： 针对任务本身，去除冗余流程，不做重复性工作或使其简单化；</li></ol><p>而上面我们所了解的HappyPack明显属于增加资源，那接下来介绍从缩小范围的几个方案。</p><h3 id="2-1-exclude-和-include"><a href="#2-1-exclude-和-include" class="headerlink" title="2.1 exclude 和 include"></a>2.1 exclude 和 include</h3><p>在前面章节（预处理器(loader)【上篇】）中，介绍过exclude和include，在配置loader的时候一般都会对其进行配置。对于JS来说，一般需要把node_modules目录排除掉，另外当exclude和include规则有重叠部分时，exclude优先级更高。</p><p>那对于此处，我们使用include让babel-loader只生效于源码目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        include: <span class="regexp">/src\/scripts/</span>,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-noParse"><a href="#2-2-noParse" class="headerlink" title="2.2 noParse"></a>2.2 noParse</h3><p>有些库我们希望webpack完全不要去解析，那此时可以使用noParse对其进行忽略，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    noParse: &#123;</span><br><span class="line">        <span class="comment">// fullPath是绝对路径，如 /User/me/app/webpack/noparse/lib/lodash.js</span></span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/lib/</span>.test(fullPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上配置将忽略所有lib目录下的资源解析。</p><h3 id="2-3-IgnorePlugin"><a href="#2-3-IgnorePlugin" class="headerlink" title="2.3 IgnorePlugin"></a>2.3 IgnorePlugin</h3><p>exclude和include是确定loader的规则范围，noParse是不去解析但仍会打包到bundle中，那接下来介绍一个插件——IgnorePlugin，他可以完全排除一些模块，被排除的模块即使被引用也不会被打包进资源文件中。一般作用于排除一些库相关文件。</p><p>一个由库产生的额外资源我们用不到但没办法去掉时，可以考虑使用此方法处理。</p><p>例，一个日期时间处理的相关插件Moment.js，为了做本地化会加载许多语言包，但一般我们只会用到本地的语言包而不会使用其他地区的语言包，而语言包会占用很大体积，这时可以使用IgnorePlugin来做处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.IgnorePlugin(&#123;</span><br><span class="line">        resourceRegexp: <span class="regexp">/^\.\/locale$/</span>, <span class="comment">// 匹配资源文件</span></span><br><span class="line">        contextRegExp: <span class="regexp">/moment$/</span>    <span class="comment">// 匹配检索目录</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="2-4-Cache"><a href="#2-4-Cache" class="headerlink" title="2.4 Cache"></a>2.4 Cache</h3><p>我们在使用某些loader时会有一个cache的配置项，用来在编译代码后同时保存一份缓存，在执行下一次编译前会优先检查源码文件是否有变化，没有则直接使用缓存结果，也就是上次编译的结果。这样一来，只有在发生变化时编译变化了的文件，对于整体而言也属于一种优化处理。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇从<code>多线程打包</code>和<code>缩小打包作用域</code>两个方面入手，对webpack打包层面做出优化。下一篇描述从<code>动态链接库思想</code>与<code>死代码检测</code>方面继续深入探究打包层面的深度优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇介绍一些webpack优化的配置方法，目的有二：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打包速度更快&lt;/li&gt;
&lt;li&gt;输出资源更小&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在软件工程领域有一条十分重要的功能经验，不要过早优化。在项目初期不要看到一个可以优化的点就去做优化，这样极有可能会增加尤其开发及维护的复杂度，并且从整体效果看，优化效果不会太理想。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——生产环境配置【下】</title>
    <link href="https://www.zhuxingmin.com/2020/09/18/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E3%80%90%E4%B8%8B%E3%80%91/"/>
    <id>https://www.zhuxingmin.com/2020/09/18/webpack实战——生产环境配置【下】/</id>
    <published>2020-09-18T06:24:56.000Z</published>
    <updated>2020-09-28T07:59:23.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是webpack实战系列第12篇。</p><p>上两篇中，描述了一些关于生产环境的配置：环境变量的使用、配置文件描述、source-map配置、资源压缩等，从这几个方面入手来对生产环境进行一定的配置。</p><p>本篇将从<code>缓存</code>和<code>资源bundle体积</code>开始，来对生产环境进行进一步的处理。</p><a id="more"></a><h2 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h2><blockquote><p>缓存是指重复利用浏览器已经获取过的资源。</p></blockquote><p>合理的使用缓存是提升客户端性能的一个关键因素。具体的缓存策略（如指定缓存时间）由服务器来决定，浏览器会在资源过期前一直使用本地缓存进行响应。但同时也带来一个新的问题，比如我们想要对代码进行一个bug fix（故障修正程序），并且立即更新到用户的浏览器中，而不要让他们使用旧的缓存资源应该怎么处理呢？那此时最好的办法便是更改资源的URL，这样可迫使所有客户端资源都去下载最新的资源。</p><h3 id="1-1-资源hash"><a href="#1-1-资源hash" class="headerlink" title="1.1 资源hash"></a>1.1 资源hash</h3><p>一个常用的方法是在每次打包的过程中对资源的内容计算一次hash，并作为版本号存放在文件名中，如<a href="mailto:*bundle@0sd5fd6fh8hf4g4d.js" target="_blank" rel="noopener">*bundle@0sd5fd6fh8hf4g4d.js</a>*。其中，bundle是文件本身的名字，而@后则跟随文件内容hash值，每当代码发生变化时，hash也会发生相应变化。</p><p>我们通常使用<strong>chunkhash</strong>来作为文件版本号，因为它会为每一个chunk单独计算一个hash值。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name]@[chunkhash].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'production'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打包结果：</strong></p><p><img src="/images/posts/webpack12-1.png" alt="打包结果"></p><h3 id="1-2-输出动态HTML"><a href="#1-2-输出动态HTML" class="headerlink" title="1.2 输出动态HTML"></a>1.2 输出动态HTML</h3><p>既然资源名字使用hash动态，那么也就意味着在HTML文件中引入的路径也会随之改变，而如果选择手动处理，不光是维护成本大，而且复杂程度相当高：如果有几十个文件变动……因此最理想的情况是打包结束后自动将最新的资源名字同步过去。此时，我们使用<strong>html-webpack-plugin</strong>来做到这一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name]@[chunkhash].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打包结果：</strong></p><p>打包后，可以看到除了js文件之外还多出来了一个HTML文件：</p><p><img src="/images/posts/webpack12-2.jpg" alt="打包结果"></p><p><strong>index.html 内容</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index%4061b65a6278687c007c6c.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从html内容可以看出，html-webpack-plugin会自动将我们打包出来的资源名放入index.html中，如上述的<code>src=&quot;index%4061b65a6278687c007c6c.js</code>(其中 <strong>%40是@的编码</strong> )，这样我们便不再需要手动的去更新资源url了。</p><p><strong>HTML模板</strong></p><p>虽然是我们通过html-webpack-plugin创建出来一个index.html文件，但是在大多数情况下，此种条件并不符合我们项目工程中的常规操作，因为我们需要在HTML中引入一些个性化的内容，这这是，我们可以传入一个已有的HTML模板，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>自定义配置模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>随便一些内容...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>webpack配置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'./index.html'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再次打包，结果如下：</p><p><img src="/images/posts/webpack12-3.jpg" alt="打包结果" title="HTML模板打包后产物"></p><h2 id="2-体积监控和分析"><a href="#2-体积监控和分析" class="headerlink" title="2. 体积监控和分析"></a>2. 体积监控和分析</h2><p>为保证良好的用户体验，我们可以对打包输出的bundle体积进行持续的监控，以防止不必要的冗余模块被添加进来。</p><p>介绍两个工具来协助我们对体积进行监控和分析。</p><h3 id="2-1-Import-Cost"><a href="#2-1-Import-Cost" class="headerlink" title="2.1 Import Cost"></a>2.1 Import Cost</h3><p>在VS Code中，安装插件<code>Import Cost</code>，这个插件可以帮助我们对引入的模块大小进行实时监测。每在我们代码中引入一个新的模块后，它会为我们计算该模块压缩后及gzip后将占用体积的大小。</p><p><img src="/images/posts/webpack12-4.jpg" alt="体积监测" title="体积监测"></p><p>当我们检测到引入的某些模块包过大时，我们可以想办法处理它，比如寻找一些更小的包或模块作为替代方案，或者引入其子模块而不是全局引入。</p><h3 id="2-2-webpack-bundle-analyzer"><a href="#2-2-webpack-bundle-analyzer" class="headerlink" title="2.2 webpack-bundle-analyzer"></a>2.2 webpack-bundle-analyzer</h3><blockquote><p>作用：分析一个bundle的构成。</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add webpack-bundle-analyzer</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">npm install webpack-bundle-analyzer --save-dev</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> WebpackBundleAnalyzer = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name]@[chunkhash].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> WebpackBundleAnalyzer()</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>执行打包命令，然后会从本地浏览器自动打开一个包体积监测的页面，如下：</p><p><img src="/images/posts/webpack12-5.png" alt="包体积分析" title="包体积分析"></p><p>从上图我们可以直观的看到生成的 <a href="mailto:index@hash.js" target="_blank" rel="noopener">index@hash.js</a> 文件中包含的各个模块及其占体积占比，这样我们也能直观的看出需要从某个模块进行优化。</p><h3 id="2-3-bundlesize-自动化监测"><a href="#2-3-bundlesize-自动化监测" class="headerlink" title="2.3 bundlesize 自动化监测"></a>2.3 bundlesize 自动化监测</h3><p>那刚才所描述的只是打包后查看，如果希望自动化的对资源体积进行监控呢？bundlesize 这个工具则可以协助我们做到。</p><p>同样，先安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add bundlesize</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">npm install bundlesize</span><br></pre></td></tr></table></figure><p>然后在 <strong>package.json</strong> 中配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"w1"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"bundlesize"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./src/index.js"</span>,</span><br><span class="line">      <span class="attr">"maxSize"</span>: <span class="string">"10 kB"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test:size"</span>: <span class="string">"bundlesize"</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我设置了 bundlesize 的路径及最大体积限制，然后在 scripts 中添加了一条脚本命令。然后在终端执行该脚本，如图：</p><p><img src="/images/posts/webpack12-6.png" alt="体积限制监控" title="体积限制监控"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对生产环境配置做个小结。</p><p>在开发环境中，我们注重打包速度，而生产环境中我们则关注资源输出体积大小及如何优化客户端缓存来缩短页面渲染时间，通过一系列配置可以优化，如：设置环境变量、代码压缩、资源体积检测监控等方法。我们也对缓存的控制有一定的了解，缓存的控制主要依赖于chunk内容生成hash作为版本号，并添加到资源文件名中，使得资源更新后客户端可以及时更新最新资源。</p><p>此外，source map主要用于线上问题的追溯，不过存在安全隐患，可以通过一些特殊的配置来兼顾追溯及安全问题。</p><p>描述完了生产环境配置，那么下一阶段来到打包优化问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是webpack实战系列第12篇。&lt;/p&gt;
&lt;p&gt;上两篇中，描述了一些关于生产环境的配置：环境变量的使用、配置文件描述、source-map配置、资源压缩等，从这几个方面入手来对生产环境进行一定的配置。&lt;/p&gt;
&lt;p&gt;本篇将从&lt;code&gt;缓存&lt;/code&gt;和&lt;code&gt;资源bundle体积&lt;/code&gt;开始，来对生产环境进行进一步的处理。&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——生产环境配置【中】</title>
    <link href="https://www.zhuxingmin.com/2020/09/07/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E3%80%90%E4%B8%AD%E3%80%91/"/>
    <id>https://www.zhuxingmin.com/2020/09/07/webpack实战——生产环境配置【中】/</id>
    <published>2020-09-07T12:23:20.000Z</published>
    <updated>2020-09-17T09:27:52.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇中，描述了一些关于生产环境的配置：环境变量的使用、配置文件描述、开启生产模式、环境变量自定义配置等，从这几个方面入手都可以对生产环境产生一些有利影响。</p><p>那么本篇，从<strong>source map</strong>和<strong>资源压缩</strong>方面入手，继续深入探究。</p><h2 id="1-source-map"><a href="#1-source-map" class="headerlink" title="1. source map"></a>1. source map</h2><blockquote><p>source map 指的是将编译、打包、压缩后的代码映射回源代码的过程。</p></blockquote><p>经过webpack打包压缩后的代码基本上已经不具备可读性，此时若是代码抛出错误，想要回溯它的调用栈是非常困难的，而有了source map，加上浏览器调试工具（dev tools），要做到这一点就会变得很容易。同时，它对于线上问题的追查也有一定帮助。</p><a id="more"></a><h3 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h3><p>工作原理：<strong>webpack对于工程源代码的每一步处理都有可能会改变代码的位置、结构、甚至是所处文件，因此每一步都需要生成对应的source map。</strong><br>如果我们启用了<code>devtool</code>配置，那么source map就会跟随源代码一步步被传递，直到生成最后的map文件。这个文件默认就是打包后的文件名字上加上后缀[.map]，例如bundle.js.map。</p><p>在生成map文件的同时，bundle文件中会追加一句注释来标识map文件的位置，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// bundle的内容</span></span><br><span class="line">    ...</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// # sourceMappingURL=bundle.js.map</span></span><br></pre></td></tr></table></figure><p>而当我们打开浏览器开发者工具后，其实map文件同时也会被加载进来，这时浏览器会使用它来对打包后的bundle文件来进行解析，分析出源代码的目录结构和内容。</p><p>亲自尝试过的朋友可能会发现，打包后，map文件会比较大，甚至超出源文件几倍的体积大小，不过不用担心，不打开开发者工具是不会加载这些map文件的，因此对于普通用户来讲没有什么影响。但是要注意的是，虽然普通用户看不到，不过有经验的“特殊人群”还是可以通过dev tools看到工程源码的。因此建议如果是生产环境，还是要解决一下。如何解决呢？下面会提到。</p><h3 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h3><p>在webpack.config.js中添加devtool即可完成对source map的配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    devtool: <span class="string">'source-map'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于CSS、SCSS及Less来说，则需要添加额外的source map配置项。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// scss</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'style-loader'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            sourceMap: <span class="literal">true</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            sourceMap: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack给出多种source map形式：</p><ul><li>source-map</li><li>cheap-source-map</li><li>eval-source-map</li><li>…</li></ul><p>在开发环境中，通常使用module-eval-source-map，因为在打包速度和源码信息还原程度都属于良好程度。</p><p>而在生产环境中，通常我们会对代码进行压缩，而最常见的压缩插件<code>UglifyjsWebpackPlugin</code>目前只支持source-map形式。</p><h3 id="1-3-安全"><a href="#1-3-安全" class="headerlink" title="1.3 安全"></a>1.3 安全</h3><p>在1.1中我们抛出一个安全问题，就是在开启source-map的时候任何人都可以通过浏览器的开发者工具devtool来看到工程源码，因此对于安全性来讲是一个极大的隐患。那么如何能在保持其功能的同时又能防止暴漏源码呢？</p><p>webpack提供了两种安全策略：</p><ol><li>hidden-source-map</li><li>nosources-source-map</li></ol><p><strong>hidden-source-map</strong></p><p>hidden-source-map意味着Webpack仍然会产出完整的map文件，但是不会在bundle文件中添加对于map文件的引用。这样当打开浏览器开发者工具时，是无法看到map文件的，自然也就无法解析。如果我们自己想要追溯源码，可使用一些第三方服务，将map文件上传到第三方服务中。目前比较流行的是<code>Sentry</code>（错误跟踪平台），有兴趣的可以自行搜索了解一下。</p><p><strong>nosources-source-map</strong></p><p>它对于安全性保护不如hidden-source-map，但是使用方式相对简单。当打包部署后，我们可以在浏览器开发者工具的sources选项卡中看到源码的目录结构，但是文件内容会被隐藏起来。这样，对于错误来讲，我们仍然可以在console控制台中查看源代码的错误栈，或者console日志的准确行数。对于追溯错误来说基本上够使用。</p><p>另外的方案则是服务端配合处理，例如正常打包出source map，服务端通过服务器的nginx配置，将.map文件只对固定的白名单（如公司内网）开放，这样其余用户就无法获取到它们了，也不失为一个小妙招。</p><h2 id="2-资源压缩"><a href="#2-资源压缩" class="headerlink" title="2. 资源压缩"></a>2. 资源压缩</h2><blockquote><p>资源在发布到生产环境之前，通常会进行代码压缩，也叫uglify，意思是移除多余的空格、换行、执行不到的代码块等，同时缩短变量名，在执行结果不变的前提下替换为更短的形式。</p></blockquote><p><strong>一般工程代码在被压缩后整个体积会显著缩小。</strong></p><p>但同时，<strong>uglify之后的代码基本上不具有可读性</strong>，从另一个层面讲，一定程度上提<strong>高了代码的安全性</strong>。</p><h3 id="2-1-压缩JavaScript"><a href="#2-1-压缩JavaScript" class="headerlink" title="2.1 压缩JavaScript"></a>2.1 压缩JavaScript</h3><p>压缩JS（JavaScript）的工具<code>terser(optomization)</code>在webpack中已集成（webpack4），并且支持ES6+的代码压缩，偏面向未来。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 压缩配置</span></span><br><span class="line">    optomization: &#123;</span><br><span class="line">        minimize: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-压缩CSS"><a href="#2-2-压缩CSS" class="headerlink" title="2.2 压缩CSS"></a>2.2 压缩CSS</h3><p>CSS文件的压缩前提是使用相关插件处理，先将样式提取出来，然后进行压缩。例如<em>常使用extract-text-webpack-plugin或mini-css-extract-plugin将样式提取，然后使用optimize-css-assets-webpack-plugin来进行压缩。</em>这个插件本质上使用的是压缩器cssnano，当然我们可以对其进行配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                    fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">                    use: <span class="string">'css-loader'</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// css 压缩</span></span><br><span class="line">    plugins: [<span class="keyword">new</span> ExtractTextPlugin(<span class="string">'style.css'</span>)];</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [<span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">            <span class="comment">// 生效范围，只压缩匹配到的资源</span></span><br><span class="line">            assetNameRegExp: <span class="regexp">/\.optimize\.css$/g</span>,</span><br><span class="line">            <span class="comment">// 压缩处理器指定，默认为 cssnano</span></span><br><span class="line">            cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>),</span><br><span class="line">            <span class="comment">// 压缩处理器配置</span></span><br><span class="line">            cssProcessorOptions: &#123;</span><br><span class="line">                discardComments: &#123;</span><br><span class="line">                    removeAll: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 是否打印log</span></span><br><span class="line">            canPrint: <span class="literal">true</span></span><br><span class="line">        &#125;)]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇介绍了关于生产环境配置中比较重量级的两种配置：source-map和资源压缩。</p><p>开发环境中我们关注打包速度，而在生产环境中我们关心的则是线上错误处理、输出资源的体积以及资源渲染等问题，而比较好的利用source-map和资源压缩都可以帮助我们处理处理或优化生产环境中的一些问题，因此比较重要，但同时也要注意解决所存在的安全隐患问题。</p><p>下一篇则从缓存和bundle体积监控入手继续描述生产环境配置的其他方面优化问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇中，描述了一些关于生产环境的配置：环境变量的使用、配置文件描述、开启生产模式、环境变量自定义配置等，从这几个方面入手都可以对生产环境产生一些有利影响。&lt;/p&gt;
&lt;p&gt;那么本篇，从&lt;strong&gt;source map&lt;/strong&gt;和&lt;strong&gt;资源压缩&lt;/strong&gt;方面入手，继续深入探究。&lt;/p&gt;
&lt;h2 id=&quot;1-source-map&quot;&gt;&lt;a href=&quot;#1-source-map&quot; class=&quot;headerlink&quot; title=&quot;1. source map&quot;&gt;&lt;/a&gt;1. source map&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;source map 指的是将编译、打包、压缩后的代码映射回源代码的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过webpack打包压缩后的代码基本上已经不具备可读性，此时若是代码抛出错误，想要回溯它的调用栈是非常困难的，而有了source map，加上浏览器调试工具（dev tools），要做到这一点就会变得很容易。同时，它对于线上问题的追查也有一定帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——生产环境配置【上】</title>
    <link href="https://www.zhuxingmin.com/2020/09/02/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E3%80%90%E4%B8%8A%E3%80%91/"/>
    <id>https://www.zhuxingmin.com/2020/09/02/webpack实战——生产环境配置【上】/</id>
    <published>2020-09-02T01:25:36.000Z</published>
    <updated>2020-09-02T08:10:39.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是<code>webpack实战</code>系列笔记的第10篇记录——<code>生产环境配置【上篇】</code>。</p><p>在前面的几篇中，介绍了webpack的大部分使用方法，使用其实就是为了上线，牵扯到生产环境，就会出现新的问题，比如：</p><ul><li>如何让用户更快的加载资源</li><li>如何压缩资源</li><li>如何添加环境变量优化打包</li><li>如何最大限度的利用缓存</li><li>…</li></ul><p>在生产环境配置篇中，将会一一介绍。本篇大致分为三个小篇，以上中下结构拆开描述。本篇描述：环境配置的封装、开启production模式、环境变量。</p><a id="more"></a><h2 id="1-环境变量的使用"><a href="#1-环境变量的使用" class="headerlink" title="1. 环境变量的使用"></a>1. 环境变量的使用</h2><p>在开发环境中，我们设置过mode模式，而生产环境中，我们这需要更多的配置，如：mode、环境变量、版本号等，webpack可以使用两种方式来按照不同环境采用不同配置。</p><h3 id="1-1-使用相同配置文件"><a href="#1-1-使用相同配置文件" class="headerlink" title="1.1 使用相同配置文件"></a>1.1 使用相同配置文件</h3><p>例如之前的<code>webpack.config.js</code>，可以在构建开始前将当前环境作为一个变量传进去，然后在js中通过判断来决定使用某个配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "scripts": &#123;</span><br><span class="line">        "dev": "ENV=development webpack-dev-server",</span><br><span class="line">        "build": "ENV=production webpack"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ENV = process.env.ENV;</span><br><span class="line"><span class="keyword">const</span> isProd = ENV === <span class="string">'production'</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: isProd ? <span class="string">'bundle@[chunkhash].js'</span> : <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: ENV,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上配置可以看出，首先通过npm脚本传入了一个ENV的环境变量，而后在输出时，webpack中用三元表达式判断环境，生产环境则添加哈希值为版本信息，本地则直接输出。</p><h3 id="1-2-多配置文件"><a href="#1-2-多配置文件" class="headerlink" title="1.2 多配置文件"></a>1.2 多配置文件</h3><p>顾名思义：为不同环境创建不同的配置信息文件。</p><p>例如，可以单独创建一个<strong>webpack.development.config.js</strong>来配置开发环境信息，再创建一个<strong>webpack.production.config.js</strong>来配置生产环境信息。然后在package.json中修改：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "scripts": &#123;</span><br><span class="line">        "dev": "webpack-dev-server --config=webpack.development.config.js",</span><br><span class="line">        "build": "webpack --config=webpack.prodection.config.js"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上述的json文件中，通过 <strong>–config</strong> 来指定了打包时用哪一个文件，但其实会有一些小问题，比如两个配置文件会有重复的内容，不利于维护等，这时可以将重复配置提取出来写成公共配置文件，比如再新建一个文件 <strong>webpack.common.config.js</strong> 来存放公共部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    <span class="comment">// 公共配置</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完之后，在开发与生产环境的webpack配置文件中，都引入该公共文件，然后加上自身的专属配置即可。</p><h2 id="2-production模式"><a href="#2-production模式" class="headerlink" title="2. production模式"></a>2. production模式</h2><p>在前面我们多次用到一个叫做<code>mode</code>的配置，其实这个配置时webpack4及之后才新添加的一个配置项，开发者可以直接使用这个配置来切换打包模式。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    mode: <span class="string">'production'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这便意味着当前模式处于生产环境，那么webpack则会自动添加许多适用于生产环境的配置项，减少手动操作配置。而目的也是为了提供更加有利的开发环境，更少的代码，更少的配置，做更多的事儿。</p><p>然而，多数情况下，仅仅配置mode是难以达到我们希望的需求的，因此还是需要用到其他与生产环境配置相关联的其他配置项。</p><h2 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3. 环境变量"></a>3. 环境变量</h2><p>通常，我们需要为生产环境和本地环境添加不同的环境变量，在webpack中可以试用DefinePlugin来进行设置。</p><h3 id="3-1-字符串类型"><a href="#3-1-字符串类型" class="headerlink" title="3.1 字符串类型"></a>3.1 字符串类型</h3><p>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:<span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'production'</span>,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            ENV: <span class="built_in">JSON</span>.stringify(<span class="string">'production'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(ENV);</span><br></pre></td></tr></table></figure><p>如上所示。通过配置DefinePlugin设置了ENV的环境变量，最终页控制台上打印的字符串会是<code>production</code>。</p><ul><li>注意<br>上面用到了JSON.stringify，因为DefinePlugin在替换环境变量时对于字符串类型的值是完全替换，如果不加的话，在替换后就会成为变量名而不是字符串。因此需要添加JSON.stringify。</li></ul><h3 id="3-2-其他类型"><a href="#3-2-其他类型" class="headerlink" title="3.2 其他类型"></a>3.2 其他类型</h3><p>在上面演示了字符串类型，当然也可以设置其他类型的环境变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            ENV: <span class="built_in">JSON</span>.stringify(<span class="string">'production'</span>),</span><br><span class="line">            IS_PRODUCTION: <span class="literal">true</span>,</span><br><span class="line">            ENV_ID: <span class="number">80808888</span>,</span><br><span class="line">            CONSTANTS: <span class="built_in">JSON</span>.stringify()&#123;</span><br><span class="line">                TYPES: [<span class="string">'foo'</span>, <span class="string">'bar'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-其他说明"><a href="#3-3-其他说明" class="headerlink" title="3.3 其他说明"></a>3.3 其他说明</h3><p>很多框架中都会采用<code>process.env.NODE_ENV</code>来作为一个区别开发环境和生产环境的变量。</p><ul><li>process.env是Node.js用于存放当前进程环境变量的对象</li><li>NODE_ENV则可以让开发者指定当前的运行时环境，值为production时代表生产环境。</li></ul><p>在上述中，当库和框架在打包时如果发现是生产环境，那么就会去掉一些开发环境中的代码和配置，如警告信息，日志打印，断点等，也有助于提升生产环境的代码运行速度，并且优化包体积。</p><p>具体配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            process.env.NODE_ENV: <span class="string">'production'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果启用了mode: production，那么webpack则已经设置好了process.env.NODE_ENV，自己则无需再手动操作</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇描述了关于生产环境的一些配置：环境变量的使用，配置文件描述，生产模式开启，环境变量自定义配置等。从这几个方面入手都可以对生产环境产生一些有利影响。</p><p>下一篇更新从 [source map] 方面和 [ 资源压缩 ] 方面进行配置和优化处理。</p><hr><p>更多关于webpack的基础讲解和进阶及性能调优方面欢迎关注公众号【流眸】回复关键词【webpack】获取~</p><p><img src="/images/qrcode.jpg" alt="流眸" title="流眸"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第10篇记录——&lt;code&gt;生产环境配置【上篇】&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在前面的几篇中，介绍了webpack的大部分使用方法，使用其实就是为了上线，牵扯到生产环境，就会出现新的问题，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何让用户更快的加载资源&lt;/li&gt;
&lt;li&gt;如何压缩资源&lt;/li&gt;
&lt;li&gt;如何添加环境变量优化打包&lt;/li&gt;
&lt;li&gt;如何最大限度的利用缓存&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在生产环境配置篇中，将会一一介绍。本篇大致分为三个小篇，以上中下结构拆开描述。本篇描述：环境配置的封装、开启production模式、环境变量。&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——代码分片</title>
    <link href="https://www.zhuxingmin.com/2020/08/27/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E5%88%86%E7%89%87/"/>
    <id>https://www.zhuxingmin.com/2020/08/27/webpack实战——代码分片/</id>
    <published>2020-08-27T07:51:39.000Z</published>
    <updated>2020-08-27T13:09:59.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是<code>webpack实战</code>系列笔记的第9篇记录——<code>代码分片</code>，前几篇记录如下：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li><li>资源输入与输出</li><li>一切皆模块</li><li>预处理器【上篇】</li><li>预处理器——常用loader【下篇】</li><li>样式文件分离</li><li>样式预处理</li></ul><h2 id="代码分片"><a href="#代码分片" class="headerlink" title="代码分片"></a>代码分片</h2><blockquote><p>实现高性能应用其中重要的一点就是尽可能的让用户每次只加载必要的资源，优先级不太高的资源则采用延迟加载（懒加载）等技术渐进式的获取，这样可以保证首屏页面加载的速度。<br>代码分片是Webpack作为打包工具所特有的一项技术，通过这项技术我们可以把代码按照特定的形式进行拆分，使用户按需加载。</p></blockquote><a id="more"></a><h2 id="通过入口划分代码"><a href="#通过入口划分代码" class="headerlink" title="通过入口划分代码"></a>通过入口划分代码</h2><p><em>通过入口配置进行一些简单有效的代码拆分。</em></p><p>对于web应用来说通常会有一些库和工具是不常变动的，可以将它们放在一个单独的入口中，由该入口产生的资源不会经常更新，因此可以有效地利用客户端缓存，让用户不必在每次请求页面时都让资源重新加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">entry:&#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    lib: [<span class="string">'lib-a'</span>, <span class="string">'lib-b'</span>, <span class="string">'lib-c'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/lib.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种拆分方法主要适用于那些将接口绑定在全局对象上的库，因为业务代码中的模块无法直接引用库中的模块，而这属于不同的依赖树。</p><p>但这样仍会带来新的问题：<strong>公共模块与业务模块处于不同依赖树的问题以及很多页面并不需要公共模块的问题。</strong> </p><h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><p>在webpack4之前，做代码切片使用的是<strong>CommonsChunkPlugin</strong>，而在4及之后，取而代之的是<strong>optimization</strong>。</p><blockquote><p><strong>optimization.SplitChunks</strong>简称optimization，是Webpack4为了改进CommonChunkPlugin而重新设计和实现的代码分片特性。</p></blockquote><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两种方式二选一</span></span><br><span class="line">yarn add optimization react</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">npm install optimization react</span><br></pre></td></tr></table></figure><h4 id="2-a-js-amp-b-js"><a href="#2-a-js-amp-b-js" class="headerlink" title="2. a.js &amp; b.js"></a>2. a.js &amp; b.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'a.js'</span>, React.version)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.js'</span>, React.version)</span><br></pre></td></tr></table></figure><h4 id="3-webpack配置"><a href="#3-webpack配置" class="headerlink" title="3. webpack配置"></a>3. webpack配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/a.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'a.js'</span>,</span><br><span class="line">        publicPath: <span class="string">'/dist/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">'all'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-打包"><a href="#4-打包" class="headerlink" title="4. 打包"></a>4. 打包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>结果如图所示：</p><p><img src="/images/posts/webpack9-1.png" alt="打包结果" title="打包结果"></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>首先观察上面的配置，从上面的配置项中可以看到：</p><ul><li>指定了chunks的值是all，含义是：SplitChunks将会对所有的chunks生效；</li><li>mode：之前也一直在用，其实是Webpack4中新增的配置项，可以针对当前是开发环境还是生产环境自动添加一些对应的Webpack配置。</li></ul><p>而从上图打包结果中看，可以看到三个文件包：<code>0.a.js</code>、<code>a.js</code>和<code>vendors~main.a.js</code>。其中，<code>vendors~main.a.js</code>则是将react提取到了里面。</p><h4 id="提取条件"><a href="#提取条件" class="headerlink" title="提取条件"></a>提取条件</h4><ul><li>提取后的chunk可悲共享或者来自node_modules目录。</li><li>提取后的JS chunk体积大于30kB（压缩和gzip前），CSS chunk体积大于50kB。</li><li>按需加载过程中，并行请求的资源最大值小于等于5。</li><li>首次加载时，并行请求的资源数最大值小于等于3。</li></ul><p>需要注意的是，默认提取方式为异步提取。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>分为四类：</p><ul><li>匹配模式<br>通过chunks可以配置Splitchunks的工作模式：async（默认），initial和all。async即只提取异步chunk，initial只对入口chunk生效，all则两种模式同时开启。</li><li>匹配条件<br>minSize、minChunks、maxAsyncRequests、maxInitialRequests都属于匹配条件。</li><li>命名<br>配置项name默认为true，意味着SplitChunks可以根据CacheGroups和作用范围自动为新生成的chunk命名，并且以automaticNameDelimiter分割。</li><li>CacheGroups<br>可以理解为分离chunks时的规则。</li></ul><h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        chunks: <span class="string">'async'</span>,</span><br><span class="line">        miSize: &#123;</span><br><span class="line">            javascript: <span class="number">30000</span>,</span><br><span class="line">            style: <span class="number">50000</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        maxSize: <span class="number">0</span>,</span><br><span class="line">        minChunks: <span class="number">1</span>,</span><br><span class="line">        maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">        maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">        automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">        name: <span class="literal">true</span>,</span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">            vendors: &#123;</span><br><span class="line">                test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">                priority: <span class="number">-10</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                minChunks: <span class="number">2</span>,</span><br><span class="line">                priority: <span class="number">-20</span>,</span><br><span class="line">                reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇了解了两种代码分片方式：</p><ul><li>入口规划</li><li>SplitChunks</li></ul><p>而借助这些方法，我们可以有效的缩小资源体积，更好的利用缓存，从而给用户更有好的体验度。</p><p>下一篇介绍生产环境优化中的一些配置，如环境配置封装、sourceMap等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第9篇记录——&lt;code&gt;代码分片&lt;/code&gt;，前几篇记录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;li&gt;资源输入与输出&lt;/li&gt;
&lt;li&gt;一切皆模块&lt;/li&gt;
&lt;li&gt;预处理器【上篇】&lt;/li&gt;
&lt;li&gt;预处理器——常用loader【下篇】&lt;/li&gt;
&lt;li&gt;样式文件分离&lt;/li&gt;
&lt;li&gt;样式预处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;代码分片&quot;&gt;&lt;a href=&quot;#代码分片&quot; class=&quot;headerlink&quot; title=&quot;代码分片&quot;&gt;&lt;/a&gt;代码分片&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;实现高性能应用其中重要的一点就是尽可能的让用户每次只加载必要的资源，优先级不太高的资源则采用延迟加载（懒加载）等技术渐进式的获取，这样可以保证首屏页面加载的速度。&lt;br&gt;代码分片是Webpack作为打包工具所特有的一项技术，通过这项技术我们可以把代码按照特定的形式进行拆分，使用户按需加载。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——样式预处理</title>
    <link href="https://www.zhuxingmin.com/2020/08/22/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%A0%B7%E5%BC%8F%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>https://www.zhuxingmin.com/2020/08/22/webpack实战——样式预处理/</id>
    <published>2020-08-22T03:28:36.000Z</published>
    <updated>2020-08-24T04:16:06.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是<code>webpack实战</code>系列笔记的第8篇记录——<code>样式与处理</code>，前几篇记录如下：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li><li>资源输入与输出</li><li>一切皆模块</li><li>预处理器【上篇】</li><li>预处理器——常用loader【下篇】</li><li>样式文件分离</li></ul><p>在目前的前端项目中，经常可以看到使用<code>SASS</code>和<code>LESS</code>来对CSS进行处理，那么在webpack中如何配置？</p><a id="more"></a><h2 id="样式预处理"><a href="#样式预处理" class="headerlink" title="样式预处理"></a>样式预处理</h2><blockquote><p>样式预处理，指的是在开发中使用到的一些预编译语言，如<strong>SCSS</strong>. <strong>LESS</strong>等，在项目打包过程中再将这些预编译语言<strong>转换为CSS</strong>。</p></blockquote><p>借助这些语言强大和便捷的特性，可以降低项目的开发及维护成本。</p><h3 id="1-Sass-与-SCSS"><a href="#1-Sass-与-SCSS" class="headerlink" title="1. Sass 与 SCSS"></a>1. Sass 与 SCSS</h3><h4 id="1-1-关系"><a href="#1-1-关系" class="headerlink" title="1.1 关系"></a>1.1 关系</h4><p>我们经常看到Sass与SCSS，但是有什么关系呢？我们怎么选择呢？</p><p>Sass是对CSS的语法增强，它有两种语法，现在使用的更多的是SCSS。如果你两者都使用过，那么可以发现无论是安装还是配置，都是使用 <strong>sass-loader</strong>，而编写保存的文件后缀却是：<strong>.scss</strong>。</p><p>一般而言，我们使用它需要配置以下几个loader搭配使用：</p><ul><li>sass-loader</li><li>css-loader</li><li>style-loader</li><li>node-sass</li></ul><p>如上，样式预处理器的安装好理解，那么为什么要安装<strong>node-loader</strong>呢？因为loader本身只是编译核心库与Webpack的连接器，因此这里我们除了Sass-loader以外还需安装node-sass，node-sass才是真正用来编译SCSS的，而sass-loader只是起到黏合作用。</p><h4 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种方式任选其一</span></span><br><span class="line">npm install sass-loader node-sass css-loader style-loader</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">yarn add sass-loader node-sass css-loader style-loader</span><br></pre></td></tr></table></figure><h4 id="1-3-webpack配置"><a href="#1-3-webpack配置" class="headerlink" title="1.3 webpack配置"></a>1.3 webpack配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h4><p>写一段scss测试一下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// style.scss</span></span><br><span class="line"><span class="variable">$default-color</span>: <span class="number">#f00</span>;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    &amp;_banner&#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="variable">$default-color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.scss'</span></span><br></pre></td></tr></table></figure><h4 id="1-5-查看结果"><a href="#1-5-查看结果" class="headerlink" title="1.5 查看结果"></a>1.5 查看结果</h4><p>从html中引入打包后的js，查看结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main_banner</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f00</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/posts/webpack8-1.png" alt="结果" title="结果"></p><h4 id="1-6-其他配置"><a href="#1-6-其他配置" class="headerlink" title="1.6 其他配置"></a>1.6 其他配置</h4><p>如果希望在浏览器的firebug里面查看及调试源码，则需要<strong>打开sourceMap</strong>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// scss</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'style-loader'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            sourceMap: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            sourceMap: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Less"><a href="#2-Less" class="headerlink" title="2. Less"></a>2. Less</h3><blockquote><p>Less也是对CSS的扩展。</p></blockquote><h4 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种方式任选其一</span></span><br><span class="line">npm install less-loader less css-loader style-loader</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">yarn add less-loader less css-loader style-loader</span><br></pre></td></tr></table></figure><h4 id="2-2-webpack配置"><a href="#2-2-webpack配置" class="headerlink" title="2.2 webpack配置"></a>2.2 webpack配置</h4><p>与SCSS配置比较类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.less/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="string">'style-loader'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            sourceMap: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            sourceMap: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// style.less</span><br><span class="line">@default-color: red;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    .title&#123;</span><br><span class="line">        <span class="selector-tag">color</span>: @<span class="keyword">default</span>-<span class="keyword">color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.less'</span></span><br></pre></td></tr></table></figure><h4 id="2-4-编译结果"><a href="#2-4-编译结果" class="headerlink" title="2.4 编译结果"></a>2.4 编译结果</h4><p>与SCSS一样，打包，引入，浏览器中查看结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> <span class="selector-class">.title</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇介绍了处理样式的预处理器工具以及相关配置，通过SCSS、less等编译语言来提高CSS的开发效率且降低代码复杂度。</p><p>下一篇开始接触与性能相关的问题——代码分片。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第8篇记录——&lt;code&gt;样式与处理&lt;/code&gt;，前几篇记录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;li&gt;资源输入与输出&lt;/li&gt;
&lt;li&gt;一切皆模块&lt;/li&gt;
&lt;li&gt;预处理器【上篇】&lt;/li&gt;
&lt;li&gt;预处理器——常用loader【下篇】&lt;/li&gt;
&lt;li&gt;样式文件分离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在目前的前端项目中，经常可以看到使用&lt;code&gt;SASS&lt;/code&gt;和&lt;code&gt;LESS&lt;/code&gt;来对CSS进行处理，那么在webpack中如何配置？&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——分离样式文件</title>
    <link href="https://www.zhuxingmin.com/2020/08/11/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%88%86%E7%A6%BB%E6%A0%B7%E5%BC%8F%E6%96%87%E4%BB%B6/"/>
    <id>https://www.zhuxingmin.com/2020/08/11/webpack实战——分离样式文件/</id>
    <published>2020-08-11T01:31:21.000Z</published>
    <updated>2020-08-13T04:05:23.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是<code>webpack实战</code>系列笔记的第7篇记录——<code>分离样式</code>，前几篇记录如下：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li><li>资源输入与输出</li><li>一切皆模块</li><li>预处理器【上篇】</li><li>预处理器——常用loader【下篇】</li></ul><p>在之前篇章里面主要是对js的打包应用和处理，而打包方面另外一个重要工作就是<code>样式处理</code>。</p><a id="more"></a><p>在实际工程中，如果项目具有一定规模，那么CSS的维护成本则会比较高昂，这个时候就需要更友好且更低价的方式来处理样式问题。本篇介绍webpack结合样式编辑器、转换器及相关插件来提升样式方面的开发效率。</p><h2 id="分离样式"><a href="#分离样式" class="headerlink" title="分离样式"></a>分离样式</h2><h3 id="1-分离样式文件概念"><a href="#1-分离样式文件概念" class="headerlink" title="1. 分离样式文件概念"></a>1. 分离样式文件概念</h3><p>在之前写的简单demo中，处理过关于CSS，并且在预处理器篇介绍过关于CSS的预处理器：style-loader和css-loader。通过JS引入CSS样式去打包，在编写阶段可以直观的描述出来模块之间的依赖关系。</p><p>但是问题随之而来：在打包后，我们对css样式的添加，是通过标签<code>&lt;style&gt;</code>来引入的，可<code>生产环境下，一般我们希望样式存在于CSS文件中而不是style标签中，因为文件更有利于客户端进行缓存</code>。那么我们怎么输出单独的CSS文件呢？</p><h3 id="2-mini-css-extract-plugin"><a href="#2-mini-css-extract-plugin" class="headerlink" title="2. mini-css-extract-plugin"></a>2. mini-css-extract-plugin</h3><blockquote><p>该插件主要是用于提取样式到CSS文件的。</p></blockquote><p>特性：</p><ul><li>可处理多样式文件</li><li>支持按需加载</li></ul><h3 id="3-安装"><a href="#3-安装" class="headerlink" title="3 安装"></a>3 安装</h3><p><em>两种方式 选择一种即可</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add mini-css-extract-plugin</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">npm install mini-css-extract-plugin</span><br></pre></td></tr></table></figure><h3 id="4-举例"><a href="#4-举例" class="headerlink" title="4. 举例"></a>4. 举例</h3><p>举个例子：</p><p><code>a.js</code>引入自身<code>a.css</code>样式，并引入<code>b.js</code>，而<code>b.js</code>也有自身相应的<code>b.css</code>样式，那么最终样式会被同步加载，通过<code>index.html</code>的link标签加载进来。</p><h4 id="a-js"><a href="#a-js" class="headerlink" title="a.js"></a>a.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./a.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./b.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'A.JS&lt;br/&gt;'</span>);</span><br></pre></td></tr></table></figure><h4 id="a-css"><a href="#a-css" class="headerlink" title="a.css"></a>a.css</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: deepskyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="b-js"><a href="#b-js" class="headerlink" title="b.js"></a>b.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./b.css'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'B.JS&lt;br/&gt;'</span>);</span><br></pre></td></tr></table></figure><h4 id="b-css"><a href="#b-css" class="headerlink" title="b.css"></a>b.css</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: thistle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/a.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: MiniCssExtractPlugin.loader,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            publicPath: <span class="string">'../'</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">'css-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],        </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'[name].css'</span>,</span><br><span class="line">            chunkFilename: <span class="string">'[id].css'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p><img src="/images/posts/webpack7-1.png" alt="build" title="build"> </p><h4 id="HTML引入"><a href="#HTML引入" class="headerlink" title="HTML引入"></a>HTML引入</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./dist/index.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>style<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>运行引入了脚本和样式的HTML文件，查看结果：</p><p><img src="/images/posts/webpack7-2.png" alt="结果" title="结果"> </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实本篇就是单独拎出来了一个loader预处理器来介绍：<code>mini-css-extract-plugin</code>。目的就是生产环境下，通过link引入样式存在于CSS文件中而不是style标签中，这样更有利于客户端进行缓存。</p><p>下一篇介绍<strong>样式预处理</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第7篇记录——&lt;code&gt;分离样式&lt;/code&gt;，前几篇记录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;li&gt;资源输入与输出&lt;/li&gt;
&lt;li&gt;一切皆模块&lt;/li&gt;
&lt;li&gt;预处理器【上篇】&lt;/li&gt;
&lt;li&gt;预处理器——常用loader【下篇】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在之前篇章里面主要是对js的打包应用和处理，而打包方面另外一个重要工作就是&lt;code&gt;样式处理&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
      <category term="样式分离" scheme="https://www.zhuxingmin.com/tags/%E6%A0%B7%E5%BC%8F%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——预处理器(loader)【下篇】</title>
    <link href="https://www.zhuxingmin.com/2020/08/03/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8loader/"/>
    <id>https://www.zhuxingmin.com/2020/08/03/webpack实战——常用loader/</id>
    <published>2020-08-03T09:56:01.000Z</published>
    <updated>2020-08-04T07:43:01.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是<code>webpack实战</code>系列笔记的第6篇记录，前几篇记录如下：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li><li>资源输入与输出</li><li>一切皆模块</li><li>预处理器【上篇】</li></ul><p>在上一篇中根据一切皆模块的思想，学习了解了loader：概述、引入、配置及使用。本篇接着上篇的话题，讲述常用loader。</p><p>在我们项目开发中，尤其是目前流行的单页面应用，一些新手经常会在loader配置中有一些疑问，比如：</p><ul><li>对于xx资源应该使用哪个loader？</li><li>实现xx功能配置哪个loader？</li><li>…</li></ul><a id="more"></a><h2 id="常用loader介绍"><a href="#常用loader介绍" class="headerlink" title="常用loader介绍"></a>常用loader介绍</h2><p>其实，在社区上每天都会有很多loader发布，开发者在选择loader的时候要多读一下loader文档，了解loader用法，优缺点，然后根据需求去挑选。接下来介绍几种常用loader。</p><h3 id="1-babel-loader"><a href="#1-babel-loader" class="headerlink" title="1. babel-loader"></a>1. babel-loader</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><blockquote><p>babel-loader是用来<strong>处理ES6+并将其编译为ES5</strong></p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure><p>看这条安装指令，有几个参数，代表着什么呢？</p><ul><li>babel-loader：它是使Babel与Webpack协同工作的模块</li><li>@babel/core：Babel编译器的核心模块</li><li>@babel/preset-env：Babel官方推荐的预置器，可根据用户设置的目标环境自动添加所需要的插件和补丁来编译ES6+代码</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>当然，知道了参数，也需要根据loader文档注意一些小细节，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                cacheDirectory: <span class="literal">true</span>,</span><br><span class="line">                presets: [</span><br><span class="line">                    [</span><br><span class="line">                        <span class="string">'env'</span>, &#123;</span><br><span class="line">                            modules: <span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li><code>babel-loader</code>一般对于js后缀文件生效， 而在<code>node_modules</code>中所有插件有大量的js后缀文件，因此需要使用<code>exclude</code>将其排除，避免打包时速度过慢；</li><li>可以看到上面配置中添加了<code>cacheDirectory: true</code>的配置，意味着会启用缓存机制，在多次打包时，如果没有做过改变的模块不会二次编译，打包时只重新编译更改的模块，以此来加快打包速度；</li><li>另外可以看到<code>@babel/presets-env</code>中配置为<code>modules: false</code>，原因是 <strong>@babel/presets-env会自动将ES6 Module转化为CommonJS形式，会导致Webpack中的tree-shaking特性失效，而将modules配置为false后悔禁用模块化语句的转化，将Module的语法交给Webpack本身去处理，来避免这一问题的发生。</strong></li><li>babel-loader支持从.babelrc文件读取Babel配置，因此也可以将presets和plugins从Webpack配置文件中提取出来，也能达到相同效果。</li></ol><h3 id="2-ts-loader"><a href="#2-ts-loader" class="headerlink" title="2. ts-loader"></a>2. ts-loader</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><blockquote><p>用于<strong>连接Webpack与TypeScript</strong>的模块</p></blockquote><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ts-loader typescript</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        use: <span class="string">'ts-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>学习或使用过typescript的开发者都知道，typescript的配置信息在工程目录下的<code>tsconfig.jsson</code>中，因此在<code>ts-loader</code>中不配置，直接对<code>tsconfig.json</code>进行配置即可。如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">        <span class="attr">"sourceMap"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-html-loader"><a href="#3-html-loader" class="headerlink" title="3. html-loader"></a>3. html-loader</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><blockquote><p>用于<strong>将HTML文件转化为字符串并进行格式化</strong>，这使得我们可以把一个HTML片段通过JS加载进来</p></blockquote><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-loader</span><br></pre></td></tr></table></figure><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        use: <span class="string">'html-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- header.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a Header.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./header.html'</span></span><br><span class="line"><span class="built_in">document</span>.write(Header)</span><br></pre></td></tr></table></figure><h3 id="4-vue-loader"><a href="#4-vue-loader" class="headerlink" title="4. vue-loader"></a>4. vue-loader</h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><blockquote><p>vue-loader用于<strong>处理.vue组件</strong>，类似如下示例形式，常与vue-template-compiler、css-loader配合使用。</p></blockquote><h4 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-loader vue vue-template-compiler css-loader</span><br></pre></td></tr></table></figure><p>包含有：</p><ul><li>vue</li><li>vue-loader</li><li>vue-template-compiler</li><li>css-loader</li></ul><h4 id="vue组件示例"><a href="#vue组件示例" class="headerlink" title="vue组件示例"></a>vue组件示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">'vue-loader'</span>,</span></span><br><span class="line"><span class="undefined">    data() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            msg: <span class="string">'vue-loader'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">h1&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#f00</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: <span class="string">'vue-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><em>此处展示基础vue-loader示例，更多配置可以参考vue-loader官网文档</em></p><h3 id="5-file-loader"><a href="#5-file-loader" class="headerlink" title="5. file-loader"></a>5. file-loader</h3><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><blockquote><p>用于打包文件类型的资源，并<strong>返回其PublicPath</strong></p></blockquote><h4 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader</span><br></pre></td></tr></table></figure><h4 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h4><p>以对图片（png、jpg、jepg、gif）为例来配置file-loader：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./index.js'</span>,</span><br><span class="line">    output<span class="string">" &#123;</span></span><br><span class="line"><span class="string">        path: path.join(__dirname, 'dist'),</span></span><br><span class="line"><span class="string">        filename: 'bundle.js'</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    module: &#123;</span></span><br><span class="line"><span class="string">        rules: [</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                test: /\.(png|jpg|jepg|gif)$/,</span></span><br><span class="line"><span class="string">                use: 'file-loader'</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js  测试</span></span><br><span class="line"><span class="keyword">import</span> testPng <span class="keyword">from</span> <span class="string">'./test.png'</span></span><br><span class="line"><span class="built_in">console</span>.log(testPng);   <span class="comment">// caj15a1123d2asf132c123cx132.jpg</span></span><br></pre></td></tr></table></figure><h3 id="6-url-loader"><a href="#6-url-loader" class="headerlink" title="6. url-loader"></a>6. url-loader</h3><h4 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h4><blockquote><p>与file-loader类似，不同之处在于用户可以<strong>设置一个文件大小的阈值，小于该阈值时，返回的文件以base64形式编码</strong>，大于该阈值时返回publicPath</p></blockquote><h4 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader</span><br></pre></td></tr></table></figure><h4 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|jepg|gif)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                limit: <span class="number">10240</span>,</span><br><span class="line">                name: <span class="string">'[name].[ext]'</span>,</span><br><span class="line">                publicPath: <span class="string">'./assets-path/'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如此，如果目标文件资源大小小于设置的阈值，那么目标资源将会转化为base64形式编码。 </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇着重接上一篇的loader配置，介绍了几种常用的loader及其作用和意义，如babel-loader、html-loader、vue-loader等，并配有简单地配置介绍，目的是对loader有基础的使用来促进更深的了解。回归本质，loader就是一个函数，能够处理相应功能的函数。第一个loader是源文件，之后所有loader是上一个loader的输出，最后一个loader则是输出给webpack。</p><p>除了JavaScript外，在打包方面另外一个重要工作就是<strong>样式处理</strong>。下一篇介绍webpack中对样式处理的模块。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第6篇记录，前几篇记录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;li&gt;资源输入与输出&lt;/li&gt;
&lt;li&gt;一切皆模块&lt;/li&gt;
&lt;li&gt;预处理器【上篇】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上一篇中根据一切皆模块的思想，学习了解了loader：概述、引入、配置及使用。本篇接着上篇的话题，讲述常用loader。&lt;/p&gt;
&lt;p&gt;在我们项目开发中，尤其是目前流行的单页面应用，一些新手经常会在loader配置中有一些疑问，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于xx资源应该使用哪个loader？&lt;/li&gt;
&lt;li&gt;实现xx功能配置哪个loader？&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
      <category term="loader" scheme="https://www.zhuxingmin.com/tags/loader/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——预处理器(loader)【上篇】</title>
    <link href="https://www.zhuxingmin.com/2020/07/23/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-loader/"/>
    <id>https://www.zhuxingmin.com/2020/07/23/webpack实战——预处理器-loader/</id>
    <published>2020-07-23T07:22:35.000Z</published>
    <updated>2020-07-28T01:49:07.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是<code>webpack实战</code>系列笔记的第5篇记录，前几篇记录如下：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li><li>资源输入与输出</li><li>一切皆模块</li></ul><p>上一篇简单描述了<strong>一切皆模块</strong>的思想，学以致用，来实践下~</p><a id="more"></a><h2 id="1-关于-loader"><a href="#1-关于-loader" class="headerlink" title="1. 关于 loader"></a>1. 关于 loader</h2><p>每个loader本质上都是一个函数，可用公式表达其本质：</p><blockquote><p><strong><em>output = loader(input)</em></strong></p></blockquote><ul><li>input可能是工程源文件的字符串，也可能是上一个loader转化后的结果，包含：<ul><li>字符串（转化后的结果）</li><li>source map</li><li>AST对象（抽象语法树）</li></ul></li><li>output同样包含上述几种信息。<code>如果是最后一个loader，其结果直接被送到webpack中做后续处理；否则作为下一个loader的input向后传递</code>。</li></ul><p><strong>举个例子</strong></p><p>当使用 <em>babel-loader</em> 将 ES6+ 代码转化为 ES5 时，带入公式：</p><blockquote><p><strong><em>ES5 = babel-loader(ES6+)</em></strong></p></blockquote><p>上述描述说过，loader本身是一个函数那么loader是如何工作的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">loader</span> (<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">    <span class="keyword">var</span> result = handler(content, map, meta);</span><br><span class="line">    callback(</span><br><span class="line">        <span class="literal">null</span>,   <span class="comment">// error</span></span><br><span class="line">        result.content, <span class="comment">// 转换后的内容</span></span><br><span class="line">        result.map, <span class="comment">// 转换source-map</span></span><br><span class="line">        result.meta <span class="comment">// 转换后的AST</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，该函数对接受到的内容进行转换，然后返回转换后的结果。</p><h2 id="2-loader配置"><a href="#2-loader配置" class="headerlink" title="2. loader配置"></a>2. loader配置</h2><p>那在应用层面应该如何实施呢？</p><p>在<code>一切皆模块</code>中说过静态资源的类型是各式各样的，比如静态HTML/CSS/JS、图片字体音视频等，webpack如何处理这各类资源呢？ok，loader的应用场景来了。</p><p>loader，字面意思是装载器，但在webpack中实际用途则是预处理器：<strong>webpack本身只认识JavaScript，对于其他类型的资源必须先定义一个或多个loader对其进行转译，输出为webpack能够接收的形式再继续进行，因此loader做的实际上是一个预处理的工作。</strong></p><h3 id="2-1-引入"><a href="#2-1-引入" class="headerlink" title="2.1 引入"></a>2.1 引入</h3><p>那loader到底应该如何使用呢？举例要在js中引入css文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./assets/common/css'</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* common.css */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">background</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok,现在我们执行打包操作，build一下，会发现在终端报错：</p><p><img src="/images/posts/webpack5-1.png" alt="出现报错" title="出现报错"></p><p>为解决报错，我们需要用到的就是loader了~</p><p>可以在上图报错内容除看到，提示我们没找到合适的loader来处理，并且给出<code>css-loader</code>提示，我们按提示安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm</span></span><br><span class="line">npm install css-loader</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者 yarn   与npm二选一即可</span></span><br><span class="line">yarn add css-loader</span><br></pre></td></tr></table></figure><p>安装完成后，仍需在webpack.config.js中进行loader配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对loader进行配置，<strong>配置项都在module对象中的rules模块。rules模块是一个数组，代表了要对模块进行处理的规则</strong>。在此处，我们使用到的规则有<code>test</code>和<code>use</code>：</p><ul><li><strong>test</strong>：接收一个正则表达式或者一个元素为正则表达式的数组，只有正则匹配上的模块才会使用本条规则；</li><li><strong>use</strong>：接收一个数组，代表该规则所使用的loader。</li></ul><p>然后进行打包操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm</span></span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者 yarn   与npm二选一即可</span></span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure><p>然后发现，打包错误解决。</p><p>但，新的问题出现了：<br>此时我们在浏览器打开<code>index.html</code>，发现样式并没有生效。原因是<strong>css-loader 的作用是处理css的加载语法而不是做style的样式渲染，因此我们需要添加一个 style-loader 来进行样式渲染。</strong></p><h3 id="2-2-链式loader"><a href="#2-2-链式loader" class="headerlink" title="2.2 链式loader"></a>2.2 链式loader</h3><p>在上面我们说了需要在引入一个 <strong>style-loader</strong> 来进行样式渲染处理，先安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm</span></span><br><span class="line">npm install style-loader</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者 yarn   与npm二选一即可</span></span><br><span class="line">yarn add style-loader</span><br></pre></td></tr></table></figure><p>接着搭配之前的webpack配置，做一些修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css style</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们将<code>style-loader</code>写在了<code>use</code>的数组中，并且细心的朋友可能发现写在了<code>css-loader</code>之前，这就是<strong>链式loader</strong>。</p><p>那么为什么要区分顺序呢？在前面描述关于loader的公式中我们介绍过:</p><blockquote><p><strong><em>output = loader(input)</em></strong> ，</p></blockquote><p><strong>在链式webpack打包中，是按照数组从后往前的顺序将资源交给loader去处理，因此最后生效的应该放在前面。</strong></p><p>此时，我们在执行打包操作，然后可以在浏览器中看到<code>index.html</code>页面加载了样式：</p><p><img src="/images/posts/webpack5-2.png" alt="样式加载成功" title="样式加载成功"></p><h3 id="2-3-其他配置"><a href="#2-3-其他配置" class="headerlink" title="2.3 其他配置"></a>2.3 其他配置</h3><h4 id="2-3-1-options配置"><a href="#2-3-1-options配置" class="headerlink" title="2.3.1 options配置"></a>2.3.1 options配置</h4><p>有些loader会有专门的配置项，形式上可能会有一些不同，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'style-loader'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            <span class="comment">// css-loader相关配置</span></span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，具体配置项参数和值则需要参考相应loader的文档来进行配置，用时参阅该loader文档即可。</p><h4 id="2-3-2-exclude-和-include"><a href="#2-3-2-exclude-和-include" class="headerlink" title="2.3.2 exclude 和 include"></a>2.3.2 exclude 和 include</h4><p>从字面意思理解，这两个分别是用来<code>排除或者包含</code>指定目录下模块的。</p><p>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面配置了<code>exclude: /node_modules/</code>，则代表着该目录下的所有模块都不会被此条规则限制，也就是说<code>node_modules</code>中的模块不会执行该规则。</p><p>同样，include用途与此类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">                include: <span class="regexp">/src/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到此处使用的是<code>include</code>，代表<strong>该规则只对正则匹配到的模块生效</strong>，也就是说只对src下的模块生效。</p><p><strong><em>在<code>exclude</code>和<code>include</code>同时存在的情况下，<code>exclude</code>优先级更高！</em></strong></p><p>通常情况下，在使用loader时，需要配置它，以此来加速打包速度，不配置的话打包会将所有模块打包，可能拖慢整体的打包速度。</p><h4 id="2-3-3-resource-与-issuer"><a href="#2-3-3-resource-与-issuer" class="headerlink" title="2.3.3 resource 与 issuer"></a>2.3.3 resource 与 issuer</h4><p>有时候，我们会在项目中看到关于<code>resource</code>和<code>issuer</code>的相关配置，那么这两个配置是做什么的呢？</p><p>其实与<code>exclude</code>和<code>include</code>类似，都是用于规定模块作用范围的配置。但是区别是<code>exclude</code>和<code>include</code>对规则的作用范围更加的精确。<br>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./src/common.css'</span></span><br></pre></td></tr></table></figure><p>在webpack中，我们认为<strong>被加载模块是resource，加载者是issuer</strong>，在上述代码中，css作为被加载者，而index作为加载者。</p><p>那么具体如何使用呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                issuer: &#123;</span><br><span class="line">                    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                    include: <span class="regexp">/src/</span>pages/</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们看到配置了<code>issuer</code>对象，限制是让<code>src/pages</code>目录下js可以引用使用规则<code>css-loader</code>。</p><p>我们看完后会发现一个风格问题： 代码可读性较差。可以稍加改善：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">                resource: &#123;</span><br><span class="line">                    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                    exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">                &#125;,</span><br><span class="line">                issuer: &#123;</span><br><span class="line">                    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                    exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过添加resource对象来讲外层配置包裹起来，区分resource和issuer的规则，看上去即可一目了然，但实际本质一样。可选择一种风格进行配置。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇介绍了loader的作用和意义，以及在项目中实际使用时的一些配置，如引入、使用过程、链式loader、loader的配置等，从各大小方面均能做到对项目有优化或效率提升。<br>下一篇介绍几个项目常用loader以及如何自定义loader。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第5篇记录，前几篇记录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;li&gt;资源输入与输出&lt;/li&gt;
&lt;li&gt;一切皆模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上一篇简单描述了&lt;strong&gt;一切皆模块&lt;/strong&gt;的思想，学以致用，来实践下~&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——一切皆模块</title>
    <link href="https://www.zhuxingmin.com/2020/07/20/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%80%E5%88%87%E7%9A%86%E6%A8%A1%E5%9D%97/"/>
    <id>https://www.zhuxingmin.com/2020/07/20/webpack实战——一切皆模块/</id>
    <published>2020-07-20T04:00:12.000Z</published>
    <updated>2020-07-21T09:31:22.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是<code>webpack实战</code>系列笔记的第4篇记录，简单描述一个思想：模块化思想——<code>一切皆模块</code>。本系列前几篇：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li><li>资源输入与输出</li></ul><a id="more"></a><h2 id="一切皆模块"><a href="#一切皆模块" class="headerlink" title="一切皆模块"></a>一切皆模块</h2><p>一个web工程通常会包含一系列的静态资源，并且这些资源一般会存在某种相互依赖的关系。一般静态资源包含：</p><ul><li>HTML/CSS/JS</li><li>图片/音视频x</li><li>字体</li><li>模板</li><li>。。。</li></ul><p>而其中可能存在的联系也容易举例，比如JS之间相互导出引入、HTML中会引入CSS、JS，而CSS和JS中又可能会引入图片、音视频等媒体资源。</p><p>但是对于webpack来说，这些静态资源却都是模块，我们可以像加载一个JS模块一样去加载它们，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'@/reset.css'</span></span><br></pre></td></tr></table></figure><p>如果经常使用vue\react等单页面框架去构建项目的一定会非常熟悉这种写法，但如果没接触过的也一定会感觉这种写法比较新奇，甚至迷惑不解：从JS中加载CSS的意义何在呢？</p><p>其实从显示结果来看各种方法所呈现的页面都一样，但是实际上，上述语句却将<em>reset.css</em>打包生成在了输出资源目录下，并且描述了JS与CSS文件之间的依赖关系。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>举个场景：<strong>某页面模块需要用到按钮</strong>，于是我们加载它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/page/index.js'</span></span><br><span class="line">imort Button <span class="keyword">from</span> <span class="string">'./ui/button/button.js'</span></span><br></pre></td></tr></table></figure><p>但是加载了JS文件之后发现需要各类样式，因此仍需要引入按钮组件的样式文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/page/style.scss  以SCSS为例</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./ui/button/style.scss'</span></span><br></pre></td></tr></table></figure><p>当然，在webpack中实际构建时，可以采用更加简洁的写法来处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/page/index.js</span></span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'./ui/button/index.js'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.scss'</span>   <span class="comment">// 引用页面自身样式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./ui/button/index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.scss'</span>   <span class="comment">// 引用组件自身样式</span></span><br></pre></td></tr></table></figure><p>从上例子可以看到，在button的JS中加载了组件自身的样式，但对于需要该组件的页面来说，只需要引入button的js模块即可，不需要再这里引入button的样式了。</p><p>可以画出依赖图便于理解：</p><ul><li><p>先看一般情况下的流程：<br><img src="/images/posts/webpack4-1.png" alt="一般情况" title="一般情况"></p></li><li><p>接下来看使用webpack：<br><img src="/images/posts/webpack4-2.png" alt="webpack" title="webpack"></p></li></ul><p>可以看到，在一般情况下，JS和Style样式是分开处理的，我们需要分别维护组件JS和SCSS，每当我们增删一个或多个组件的时候，都需要多次操作操作：引入 JS&amp;SCSS 或者删除 JS&amp;SCSS。但在使用 webpack 的情况下，可以看到，button 模块被作为一个整体被引入进来，这样不仅可以直观且请清晰的看到依赖关系（JS和SCSS被作为一个整体引入到page/index.js），而且在进行组件的引入与删除时，直接操作一次即可达成目的。</p><p>在项目具有一定规模的情况下，可以更加清晰明了的总结出webpack对我们项目工程优化之处：</p><ol><li>工程结构更简洁</li><li>让依赖关系更直观</li><li>代码可维护性更强</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在前面我们也说过模块化的一些特性：高内聚性和可复用性，而本篇旨在描述出<strong>一切皆模块</strong>的思想，在学习webpack过程中，可以将这一思想尽情发挥到每一种静态资源上，从而使得项目系统更加简洁且健壮！下一篇继续发挥一切皆模块思想——预处理器（loader）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第4篇记录，简单描述一个思想：模块化思想——&lt;code&gt;一切皆模块&lt;/code&gt;。本系列前几篇：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;li&gt;资源输入与输出&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lomo | 朱幸民</title>
  
  <subtitle>on the way</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zhuxingmin.com/"/>
  <updated>2020-09-17T09:07:44.641Z</updated>
  <id>https://www.zhuxingmin.com/</id>
  
  <author>
    <name>Lomo 朱幸民</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack实战——生产环境配置【中】</title>
    <link href="https://www.zhuxingmin.com/2020/09/07/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E3%80%90%E4%B8%AD%E3%80%91/"/>
    <id>https://www.zhuxingmin.com/2020/09/07/webpack实战——生产环境配置【中】/</id>
    <published>2020-09-07T12:23:20.000Z</published>
    <updated>2020-09-17T09:07:44.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇中，描述了一些关于生产环境的配置：环境变量的使用、配置文件描述、开启生产模式、环境变量自定义配置等，从这几个方面入手都可以对生产环境产生一些有利影响。</p><p>那么本篇，从<strong>source map</strong>和<strong>资源压缩</strong>方面入手，继续深入探究。</p><h2 id="1-source-map"><a href="#1-source-map" class="headerlink" title="1. source map"></a>1. source map</h2><blockquote><p>source map 指的是将编译、打包、压缩后的代码映射回源代码的过程。</p></blockquote><p>经过webpack打包压缩后的代码基本上已经不具备可读性，此时若是代码抛出错误，想要回溯它的调用栈是非常困难的，而有了source map，加上浏览器调试工具（dev tools），要做到这一点就会变得很容易。同时，它对于线上问题的追查也有一定帮助。</p><a id="more"></a><h3 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h3><p>工作原理：<strong>webpack对于工程源代码的每一步处理都有可能会改变代码的位置、结构、甚至是所处文件，因此每一步都需要生成对应的source map。</strong><br>如果我们启用了<code>devtool</code>配置，那么source map救护跟随源代码一步步被传递，直到生成最后的map文件。这个文件默认就是打包后的文件名字上加上后缀[.map]，例如bundle.js.map。</p><p>在生成map文件的同时，bundle文件中会追加一句注释来标识map文件的位置，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// bundle的内容</span></span><br><span class="line">    ...</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// # sourceMappingURL=bundle.js.map</span></span><br></pre></td></tr></table></figure><p>而当我们打开浏览器开发者工具后，其实map文件同时也会被加载进来，这时浏览器会使用它来对打包后的bundle文件来进行解析，分析出源代码的目录结构和内容。</p><p>亲自尝试过的朋友可能会发现，打包后，map文件会比较大，甚至超出源文件几倍的体积大小，不过不用担心，不打开开发者工具是不会加载这些map文件的，因此对于普通用户来讲没有什么影响。但是要注意的是，虽然普通用户看不到，不过有经验的“特殊人群”还是可以通过dev tools看到工程源码的。因此建议如果是生产环境，还是要解决一下。如何解决呢？下面会提到。</p><h3 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h3><p>在webpack.config.js中添加devtool即可完成对source map的配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    devtool: <span class="string">'source-map'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于CSS、SCSS及Less来说，则需要添加额外的source map配置项。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// scss</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'style-loader'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            sourceMap: <span class="literal">true</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            sourceMap: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack支出多种source map形式：</p><ul><li>source-map</li><li>cheap-source-map</li><li>eval-source-map</li><li>…</li></ul><p>在开发环境中，通常使用module-eval-source-map，因为在打包速度和源码信息还原程度都属于良好程度。</p><p>而在生产环境中，通常我们会对代码进行压缩，而最常见的压缩插件<code>UglifyjsWebpackPlugin</code>目前只支持source-map形式。</p><h3 id="1-3-安全"><a href="#1-3-安全" class="headerlink" title="1.3 安全"></a>1.3 安全</h3><p>在1.1中我们抛出一个安全问题，就是在开启source-map的时候任何人都可以通过浏览器的开发者工具devtool来看到工程源码，因此对于安全性来讲是一个极大的隐患。那么如何能在保持其功能的同时又能防止暴漏源码呢？</p><p>webpack提供了两种安全策略：</p><ol><li>hidden-source-map</li><li>nosources-source-map</li></ol><p><strong>hidden-source-map</strong></p><p>hidden-source-map意味着Webpack仍然会产出完整的map文件，但是不会再bundle文件中添加对于map文件的引用。这样当打开浏览器开发者工具时，是无法看到map文件的，自然也就无法解析。如果我们自己想要追溯源码，可使用一些第三方服务，将map文件上传到第三方服务中。目前比较流行的是<code>Sentry</code>（错误跟踪平台），有兴趣的可以自行搜索了解一下。</p><p><strong>nosources-source-map</strong></p><p>它对于安全性保护不如hidden-source-map，但是使用方式相对简单。当打包部署后，我们可以在浏览器开发者工具的sources选项卡中看到源码的目录结构，但是文件内容会被隐藏起来。这样，对于错误来讲，我们仍然可以在console控制台中查看源代码的错误栈，或者console日志的准确行数。对于追溯错误来说基本上够使用。</p><p>另外的方案则是服务端配合处理，例如正常打包出source map，服务端通过服务器的nginx配置，将.map文件只对固定的白名单（如公司内网）开放，这样其余用户就无法获取到它们了，也不失为一个小妙招。</p><h2 id="2-资源压缩"><a href="#2-资源压缩" class="headerlink" title="2. 资源压缩"></a>2. 资源压缩</h2><blockquote><p>资源在发布到生产环境之前，通常会进行代码压缩，也叫uglify，意思是移除多余的空格、换行、执行不到的代码块等，同时缩短变量名，在执行结果不变的前提下替换为更短的形式。</p></blockquote><p><strong>一般工程代码在被压缩后整个体积会显著缩小。</strong></p><p>但同时，<strong>uglify之后的代码基本上不具有可读性</strong>，从另一个层面讲，一定程度上提<strong>高了代码的安全性</strong>。</p><h3 id="2-1-压缩JavaScript"><a href="#2-1-压缩JavaScript" class="headerlink" title="2.1 压缩JavaScript"></a>2.1 压缩JavaScript</h3><p>压缩JS（JavaScript）的工具<code>terser(optomization)</code>在webpack中已集成（webpack4），并且支持ES6+的代码压缩，偏面向未来。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 压缩配置</span></span><br><span class="line">    optomization: &#123;</span><br><span class="line">        minimize: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-压缩CSS"><a href="#2-2-压缩CSS" class="headerlink" title="2.2 压缩CSS"></a>2.2 压缩CSS</h3><p>CSS文件的压缩前提是使用相关插件处理，先将样式提取出来，然后进行压缩。例如<em>常使用extract-text-webpack-plugin或mini-css-extract-plugin将样式提取，然后使用optimize-css-assets-webpack-plugin来进行压缩。</em>这个插件本质上使用的是压缩器cssnano，当然我们可以对其进行配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                    fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">                    use: <span class="string">'css-loader'</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// css 压缩</span></span><br><span class="line">    plugins: [<span class="keyword">new</span> ExtractTextPlugin(<span class="string">'style.css'</span>)];</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [<span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">            <span class="comment">// 生效范围，只压缩匹配到的资源</span></span><br><span class="line">            assetNameRegExp: <span class="regexp">/\.optimize\.css$/g</span>,</span><br><span class="line">            <span class="comment">// 压缩处理器指定，默认为 cssnano</span></span><br><span class="line">            cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>),</span><br><span class="line">            <span class="comment">// 压缩处理器配置</span></span><br><span class="line">            cssProcessorOptions: &#123;</span><br><span class="line">                discardComments: &#123;</span><br><span class="line">                    removeAll: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 是否打印log</span></span><br><span class="line">            canPrint: <span class="literal">true</span></span><br><span class="line">        &#125;)]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇介绍了关于生产环境配置中比较重量级的两种配置：source-map和资源压缩。</p><p>开发环境中我们关注打包速度，而在生产环境中我们关心的则是线上错误处理、输出资源的体积以及资源渲染等问题，而比较好的利用source-map和资源压缩都可以帮助我们处理处理或优化生产环境中的一些问题，因此比较重要，但同时也要注意解决所存在的安全隐患问题。</p><p>下一篇则从缓存和bundle体积监控入手继续描述生产环境配置的其他方面优化问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇中，描述了一些关于生产环境的配置：环境变量的使用、配置文件描述、开启生产模式、环境变量自定义配置等，从这几个方面入手都可以对生产环境产生一些有利影响。&lt;/p&gt;
&lt;p&gt;那么本篇，从&lt;strong&gt;source map&lt;/strong&gt;和&lt;strong&gt;资源压缩&lt;/strong&gt;方面入手，继续深入探究。&lt;/p&gt;
&lt;h2 id=&quot;1-source-map&quot;&gt;&lt;a href=&quot;#1-source-map&quot; class=&quot;headerlink&quot; title=&quot;1. source map&quot;&gt;&lt;/a&gt;1. source map&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;source map 指的是将编译、打包、压缩后的代码映射回源代码的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过webpack打包压缩后的代码基本上已经不具备可读性，此时若是代码抛出错误，想要回溯它的调用栈是非常困难的，而有了source map，加上浏览器调试工具（dev tools），要做到这一点就会变得很容易。同时，它对于线上问题的追查也有一定帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——生产环境配置【上】</title>
    <link href="https://www.zhuxingmin.com/2020/09/02/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E3%80%90%E4%B8%8A%E3%80%91/"/>
    <id>https://www.zhuxingmin.com/2020/09/02/webpack实战——生产环境配置【上】/</id>
    <published>2020-09-02T01:25:36.000Z</published>
    <updated>2020-09-02T08:10:39.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是<code>webpack实战</code>系列笔记的第10篇记录——<code>生产环境配置【上篇】</code>。</p><p>在前面的几篇中，介绍了webpack的大部分使用方法，使用其实就是为了上线，牵扯到生产环境，就会出现新的问题，比如：</p><ul><li>如何让用户更快的加载资源</li><li>如何压缩资源</li><li>如何添加环境变量优化打包</li><li>如何最大限度的利用缓存</li><li>…</li></ul><p>在生产环境配置篇中，将会一一介绍。本篇大致分为三个小篇，以上中下结构拆开描述。本篇描述：环境配置的封装、开启production模式、环境变量。</p><a id="more"></a><h2 id="1-环境变量的使用"><a href="#1-环境变量的使用" class="headerlink" title="1. 环境变量的使用"></a>1. 环境变量的使用</h2><p>在开发环境中，我们设置过mode模式，而生产环境中，我们这需要更多的配置，如：mode、环境变量、版本号等，webpack可以使用两种方式来按照不同环境采用不同配置。</p><h3 id="1-1-使用相同配置文件"><a href="#1-1-使用相同配置文件" class="headerlink" title="1.1 使用相同配置文件"></a>1.1 使用相同配置文件</h3><p>例如之前的<code>webpack.config.js</code>，可以在构建开始前将当前环境作为一个变量传进去，然后在js中通过判断来决定使用某个配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "scripts": &#123;</span><br><span class="line">        "dev": "ENV=development webpack-dev-server",</span><br><span class="line">        "build": "ENV=production webpack"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ENV = process.env.ENV;</span><br><span class="line"><span class="keyword">const</span> isProd = ENV === <span class="string">'production'</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: isProd ? <span class="string">'bundle@[chunkhash].js'</span> : <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: ENV,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上配置可以看出，首先通过npm脚本传入了一个ENV的环境变量，而后在输出时，webpack中用三元表达式判断环境，生产环境则添加哈希值为版本信息，本地则直接输出。</p><h3 id="1-2-多配置文件"><a href="#1-2-多配置文件" class="headerlink" title="1.2 多配置文件"></a>1.2 多配置文件</h3><p>顾名思义：为不同环境创建不同的配置信息文件。</p><p>例如，可以单独创建一个<strong>webpack.development.config.js</strong>来配置开发环境信息，再创建一个<strong>webpack.production.config.js</strong>来配置生产环境信息。然后在package.json中修改：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "scripts": &#123;</span><br><span class="line">        "dev": "webpack-dev-server --config=webpack.development.config.js",</span><br><span class="line">        "build": "webpack --config=webpack.prodection.config.js"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上述的json文件中，通过 <strong>–config</strong> 来指定了打包时用哪一个文件，但其实会有一些小问题，比如两个配置文件会有重复的内容，不利于维护等，这时可以将重复配置提取出来写成公共配置文件，比如再新建一个文件 <strong>webpack.common.config.js</strong> 来存放公共部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    <span class="comment">// 公共配置</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完之后，在开发与生产环境的webpack配置文件中，都引入该公共文件，然后加上自身的专属配置即可。</p><h2 id="2-production模式"><a href="#2-production模式" class="headerlink" title="2. production模式"></a>2. production模式</h2><p>在前面我们多次用到一个叫做<code>mode</code>的配置，其实这个配置时webpack4及之后才新添加的一个配置项，开发者可以直接使用这个配置来切换打包模式。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    mode: <span class="string">'production'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这便意味着当前模式处于生产环境，那么webpack则会自动添加许多适用于生产环境的配置项，减少手动操作配置。而目的也是为了提供更加有利的开发环境，更少的代码，更少的配置，做更多的事儿。</p><p>然而，多数情况下，仅仅配置mode是难以达到我们希望的需求的，因此还是需要用到其他与生产环境配置相关联的其他配置项。</p><h2 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3. 环境变量"></a>3. 环境变量</h2><p>通常，我们需要为生产环境和本地环境添加不同的环境变量，在webpack中可以试用DefinePlugin来进行设置。</p><h3 id="3-1-字符串类型"><a href="#3-1-字符串类型" class="headerlink" title="3.1 字符串类型"></a>3.1 字符串类型</h3><p>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:<span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'production'</span>,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            ENV: <span class="built_in">JSON</span>.stringify(<span class="string">'production'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(ENV);</span><br></pre></td></tr></table></figure><p>如上所示。通过配置DefinePlugin设置了ENV的环境变量，最终页控制台上打印的字符串会是<code>production</code>。</p><ul><li>注意<br>上面用到了JSON.stringify，因为DefinePlugin在替换环境变量时对于字符串类型的值是完全替换，如果不加的话，在替换后就会成为变量名而不是字符串。因此需要添加JSON.stringify。</li></ul><h3 id="3-2-其他类型"><a href="#3-2-其他类型" class="headerlink" title="3.2 其他类型"></a>3.2 其他类型</h3><p>在上面演示了字符串类型，当然也可以设置其他类型的环境变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            ENV: <span class="built_in">JSON</span>.stringify(<span class="string">'production'</span>),</span><br><span class="line">            IS_PRODUCTION: <span class="literal">true</span>,</span><br><span class="line">            ENV_ID: <span class="number">80808888</span>,</span><br><span class="line">            CONSTANTS: <span class="built_in">JSON</span>.stringify()&#123;</span><br><span class="line">                TYPES: [<span class="string">'foo'</span>, <span class="string">'bar'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-其他说明"><a href="#3-3-其他说明" class="headerlink" title="3.3 其他说明"></a>3.3 其他说明</h3><p>很多框架中都会采用<code>process.env.NODE_ENV</code>来作为一个区别开发环境和生产环境的变量。</p><ul><li>process.env是Node.js用于存放当前进程环境变量的对象</li><li>NODE_ENV则可以让开发者指定当前的运行时环境，值为production时代表生产环境。</li></ul><p>在上述中，当库和框架在打包时如果发现是生产环境，那么就会去掉一些开发环境中的代码和配置，如警告信息，日志打印，断点等，也有助于提升生产环境的代码运行速度，并且优化包体积。</p><p>具体配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            process.env.NODE_ENV: <span class="string">'production'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果启用了mode: production，那么webpack则已经设置好了process.env.NODE_ENV，自己则无需再手动操作</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇描述了关于生产环境的一些配置：环境变量的使用，配置文件描述，生产模式开启，环境变量自定义配置等。从这几个方面入手都可以对生产环境产生一些有利影响。</p><p>下一篇更新从 [source map] 方面和 [ 资源压缩 ] 方面进行配置和优化处理。</p><hr><p>更多关于webpack的基础讲解和进阶及性能调优方面欢迎关注公众号【流眸】回复关键词【webpack】获取~</p><p><img src="/images/qrcode.jpg" alt="流眸" title="流眸"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第10篇记录——&lt;code&gt;生产环境配置【上篇】&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在前面的几篇中，介绍了webpack的大部分使用方法，使用其实就是为了上线，牵扯到生产环境，就会出现新的问题，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何让用户更快的加载资源&lt;/li&gt;
&lt;li&gt;如何压缩资源&lt;/li&gt;
&lt;li&gt;如何添加环境变量优化打包&lt;/li&gt;
&lt;li&gt;如何最大限度的利用缓存&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在生产环境配置篇中，将会一一介绍。本篇大致分为三个小篇，以上中下结构拆开描述。本篇描述：环境配置的封装、开启production模式、环境变量。&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——代码分片</title>
    <link href="https://www.zhuxingmin.com/2020/08/27/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E5%88%86%E7%89%87/"/>
    <id>https://www.zhuxingmin.com/2020/08/27/webpack实战——代码分片/</id>
    <published>2020-08-27T07:51:39.000Z</published>
    <updated>2020-08-27T13:09:59.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是<code>webpack实战</code>系列笔记的第9篇记录——<code>代码分片</code>，前几篇记录如下：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li><li>资源输入与输出</li><li>一切皆模块</li><li>预处理器【上篇】</li><li>预处理器——常用loader【下篇】</li><li>样式文件分离</li><li>样式预处理</li></ul><h2 id="代码分片"><a href="#代码分片" class="headerlink" title="代码分片"></a>代码分片</h2><blockquote><p>实现高性能应用其中重要的一点就是尽可能的让用户每次只加载必要的资源，优先级不太高的资源则采用延迟加载（懒加载）等技术渐进式的获取，这样可以保证首屏页面加载的速度。<br>代码分片是Webpack作为打包工具所特有的一项技术，通过这项技术我们可以把代码按照特定的形式进行拆分，使用户按需加载。</p></blockquote><a id="more"></a><h2 id="通过入口划分代码"><a href="#通过入口划分代码" class="headerlink" title="通过入口划分代码"></a>通过入口划分代码</h2><p><em>通过入口配置进行一些简单有效的代码拆分。</em></p><p>对于web应用来说通常会有一些库和工具是不常变动的，可以将它们放在一个单独的入口中，由该入口产生的资源不会经常更新，因此可以有效地利用客户端缓存，让用户不必在每次请求页面时都让资源重新加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">entry:&#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    lib: [<span class="string">'lib-a'</span>, <span class="string">'lib-b'</span>, <span class="string">'lib-c'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/lib.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种拆分方法主要适用于那些将接口绑定在全局对象上的库，因为业务代码中的模块无法直接引用库中的模块，而这属于不同的依赖树。</p><p>但这样仍会带来新的问题：<strong>公共模块与业务模块处于不同依赖树的问题以及很多页面并不需要公共模块的问题。</strong> </p><h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><p>在webpack4之前，做代码切片使用的是<strong>CommonsChunkPlugin</strong>，而在4及之后，取而代之的是<strong>optimization</strong>。</p><blockquote><p><strong>optimization.SplitChunks</strong>简称optimization，是Webpack4为了改进CommonChunkPlugin而重新设计和实现的代码分片特性。</p></blockquote><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两种方式二选一</span></span><br><span class="line">yarn add optimization react</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">npm install optimization react</span><br></pre></td></tr></table></figure><h4 id="2-a-js-amp-b-js"><a href="#2-a-js-amp-b-js" class="headerlink" title="2. a.js &amp; b.js"></a>2. a.js &amp; b.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'a.js'</span>, React.version)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.js'</span>, React.version)</span><br></pre></td></tr></table></figure><h4 id="3-webpack配置"><a href="#3-webpack配置" class="headerlink" title="3. webpack配置"></a>3. webpack配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/a.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'a.js'</span>,</span><br><span class="line">        publicPath: <span class="string">'/dist/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">'all'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-打包"><a href="#4-打包" class="headerlink" title="4. 打包"></a>4. 打包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>结果如图所示：</p><p><img src="/images/posts/webpack9-1.png" alt="打包结果" title="打包结果"></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>首先观察上面的配置，从上面的配置项中可以看到：</p><ul><li>指定了chunks的值是all，含义是：SplitChunks将会对所有的chunks生效；</li><li>mode：之前也一直在用，其实是Webpack4中新增的配置项，可以针对当前是开发环境还是生产环境自动添加一些对应的Webpack配置。</li></ul><p>而从上图打包结果中看，可以看到三个文件包：<code>0.a.js</code>、<code>a.js</code>和<code>vendors~main.a.js</code>。其中，<code>vendors~main.a.js</code>则是将react提取到了里面。</p><h4 id="提取条件"><a href="#提取条件" class="headerlink" title="提取条件"></a>提取条件</h4><ul><li>提取后的chunk可悲共享或者来自node_modules目录。</li><li>提取后的JS chunk体积大于30kB（压缩和gzip前），CSS chunk体积大于50kB。</li><li>按需加载过程中，并行请求的资源最大值小于等于5。</li><li>首次加载时，并行请求的资源数最大值小于等于3。</li></ul><p>需要注意的是，默认提取方式为异步提取。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>分为四类：</p><ul><li>匹配模式<br>通过chunks可以配置Splitchunks的工作模式：async（默认），initial和all。async即只提取异步chunk，initial只对入口chunk生效，all则两种模式同时开启。</li><li>匹配条件<br>minSize、minChunks、maxAsyncRequests、maxInitialRequests都属于匹配条件。</li><li>命名<br>配置项name默认为true，意味着SplitChunks可以根据CacheGroups和作用范围自动为新生成的chunk命名，并且以automaticNameDelimiter分割。</li><li>CacheGroups<br>可以理解为分离chunks时的规则。</li></ul><h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        chunks: <span class="string">'async'</span>,</span><br><span class="line">        miSize: &#123;</span><br><span class="line">            javascript: <span class="number">30000</span>,</span><br><span class="line">            style: <span class="number">50000</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        maxSize: <span class="number">0</span>,</span><br><span class="line">        minChunks: <span class="number">1</span>,</span><br><span class="line">        maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">        maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">        automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">        name: <span class="literal">true</span>,</span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">            vendors: &#123;</span><br><span class="line">                test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">                priority: <span class="number">-10</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                minChunks: <span class="number">2</span>,</span><br><span class="line">                priority: <span class="number">-20</span>,</span><br><span class="line">                reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇了解了两种代码分片方式：</p><ul><li>入口规划</li><li>SplitChunks</li></ul><p>而借助这些方法，我们可以有效的缩小资源体积，更好的利用缓存，从而给用户更有好的体验度。</p><p>下一篇介绍生产环境优化中的一些配置，如环境配置封装、sourceMap等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第9篇记录——&lt;code&gt;代码分片&lt;/code&gt;，前几篇记录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;li&gt;资源输入与输出&lt;/li&gt;
&lt;li&gt;一切皆模块&lt;/li&gt;
&lt;li&gt;预处理器【上篇】&lt;/li&gt;
&lt;li&gt;预处理器——常用loader【下篇】&lt;/li&gt;
&lt;li&gt;样式文件分离&lt;/li&gt;
&lt;li&gt;样式预处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;代码分片&quot;&gt;&lt;a href=&quot;#代码分片&quot; class=&quot;headerlink&quot; title=&quot;代码分片&quot;&gt;&lt;/a&gt;代码分片&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;实现高性能应用其中重要的一点就是尽可能的让用户每次只加载必要的资源，优先级不太高的资源则采用延迟加载（懒加载）等技术渐进式的获取，这样可以保证首屏页面加载的速度。&lt;br&gt;代码分片是Webpack作为打包工具所特有的一项技术，通过这项技术我们可以把代码按照特定的形式进行拆分，使用户按需加载。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——样式预处理</title>
    <link href="https://www.zhuxingmin.com/2020/08/22/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%A0%B7%E5%BC%8F%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>https://www.zhuxingmin.com/2020/08/22/webpack实战——样式预处理/</id>
    <published>2020-08-22T03:28:36.000Z</published>
    <updated>2020-08-24T04:16:06.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是<code>webpack实战</code>系列笔记的第8篇记录——<code>样式与处理</code>，前几篇记录如下：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li><li>资源输入与输出</li><li>一切皆模块</li><li>预处理器【上篇】</li><li>预处理器——常用loader【下篇】</li><li>样式文件分离</li></ul><p>在目前的前端项目中，经常可以看到使用<code>SASS</code>和<code>LESS</code>来对CSS进行处理，那么在webpack中如何配置？</p><a id="more"></a><h2 id="样式预处理"><a href="#样式预处理" class="headerlink" title="样式预处理"></a>样式预处理</h2><blockquote><p>样式预处理，指的是在开发中使用到的一些预编译语言，如<strong>SCSS</strong>. <strong>LESS</strong>等，在项目打包过程中再将这些预编译语言<strong>转换为CSS</strong>。</p></blockquote><p>借助这些语言强大和便捷的特性，可以降低项目的开发及维护成本。</p><h3 id="1-Sass-与-SCSS"><a href="#1-Sass-与-SCSS" class="headerlink" title="1. Sass 与 SCSS"></a>1. Sass 与 SCSS</h3><h4 id="1-1-关系"><a href="#1-1-关系" class="headerlink" title="1.1 关系"></a>1.1 关系</h4><p>我们经常看到Sass与SCSS，但是有什么关系呢？我们怎么选择呢？</p><p>Sass是对CSS的语法增强，它有两种语法，现在使用的更多的是SCSS。如果你两者都使用过，那么可以发现无论是安装还是配置，都是使用 <strong>sass-loader</strong>，而编写保存的文件后缀却是：<strong>.scss</strong>。</p><p>一般而言，我们使用它需要配置以下几个loader搭配使用：</p><ul><li>sass-loader</li><li>css-loader</li><li>style-loader</li><li>node-sass</li></ul><p>如上，样式预处理器的安装好理解，那么为什么要安装<strong>node-loader</strong>呢？因为loader本身只是编译核心库与Webpack的连接器，因此这里我们除了Sass-loader以外还需安装node-sass，node-sass才是真正用来编译SCSS的，而sass-loader只是起到黏合作用。</p><h4 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种方式任选其一</span></span><br><span class="line">npm install sass-loader node-sass css-loader style-loader</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">yarn add sass-loader node-sass css-loader style-loader</span><br></pre></td></tr></table></figure><h4 id="1-3-webpack配置"><a href="#1-3-webpack配置" class="headerlink" title="1.3 webpack配置"></a>1.3 webpack配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h4><p>写一段scss测试一下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// style.scss</span></span><br><span class="line"><span class="variable">$default-color</span>: <span class="number">#f00</span>;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    &amp;_banner&#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="variable">$default-color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.scss'</span></span><br></pre></td></tr></table></figure><h4 id="1-5-查看结果"><a href="#1-5-查看结果" class="headerlink" title="1.5 查看结果"></a>1.5 查看结果</h4><p>从html中引入打包后的js，查看结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main_banner</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f00</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/posts/webpack8-1.png" alt="结果" title="结果"></p><h4 id="1-6-其他配置"><a href="#1-6-其他配置" class="headerlink" title="1.6 其他配置"></a>1.6 其他配置</h4><p>如果希望在浏览器的firebug里面查看及调试源码，则需要<strong>打开sourceMap</strong>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// scss</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'style-loader'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            sourceMap: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            sourceMap: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Less"><a href="#2-Less" class="headerlink" title="2. Less"></a>2. Less</h3><blockquote><p>Less也是对CSS的扩展。</p></blockquote><h4 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种方式任选其一</span></span><br><span class="line">npm install less-loader less css-loader style-loader</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">yarn add less-loader less css-loader style-loader</span><br></pre></td></tr></table></figure><h4 id="2-2-webpack配置"><a href="#2-2-webpack配置" class="headerlink" title="2.2 webpack配置"></a>2.2 webpack配置</h4><p>与SCSS配置比较类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.less/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="string">'style-loader'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            sourceMap: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            sourceMap: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// style.less</span><br><span class="line">@default-color: red;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    .title&#123;</span><br><span class="line">        <span class="selector-tag">color</span>: @<span class="keyword">default</span>-<span class="keyword">color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.less'</span></span><br></pre></td></tr></table></figure><h4 id="2-4-编译结果"><a href="#2-4-编译结果" class="headerlink" title="2.4 编译结果"></a>2.4 编译结果</h4><p>与SCSS一样，打包，引入，浏览器中查看结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> <span class="selector-class">.title</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇介绍了处理样式的预处理器工具以及相关配置，通过SCSS、less等编译语言来提高CSS的开发效率且降低代码复杂度。</p><p>下一篇开始接触与性能相关的问题——代码分片。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第8篇记录——&lt;code&gt;样式与处理&lt;/code&gt;，前几篇记录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;li&gt;资源输入与输出&lt;/li&gt;
&lt;li&gt;一切皆模块&lt;/li&gt;
&lt;li&gt;预处理器【上篇】&lt;/li&gt;
&lt;li&gt;预处理器——常用loader【下篇】&lt;/li&gt;
&lt;li&gt;样式文件分离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在目前的前端项目中，经常可以看到使用&lt;code&gt;SASS&lt;/code&gt;和&lt;code&gt;LESS&lt;/code&gt;来对CSS进行处理，那么在webpack中如何配置？&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——分离样式文件</title>
    <link href="https://www.zhuxingmin.com/2020/08/11/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%88%86%E7%A6%BB%E6%A0%B7%E5%BC%8F%E6%96%87%E4%BB%B6/"/>
    <id>https://www.zhuxingmin.com/2020/08/11/webpack实战——分离样式文件/</id>
    <published>2020-08-11T01:31:21.000Z</published>
    <updated>2020-08-13T04:05:23.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是<code>webpack实战</code>系列笔记的第7篇记录——<code>分离样式</code>，前几篇记录如下：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li><li>资源输入与输出</li><li>一切皆模块</li><li>预处理器【上篇】</li><li>预处理器——常用loader【下篇】</li></ul><p>在之前篇章里面主要是对js的打包应用和处理，而打包方面另外一个重要工作就是<code>样式处理</code>。</p><a id="more"></a><p>在实际工程中，如果项目具有一定规模，那么CSS的维护成本则会比较高昂，这个时候就需要更友好且更低价的方式来处理样式问题。本篇介绍webpack结合样式编辑器、转换器及相关插件来提升样式方面的开发效率。</p><h2 id="分离样式"><a href="#分离样式" class="headerlink" title="分离样式"></a>分离样式</h2><h3 id="1-分离样式文件概念"><a href="#1-分离样式文件概念" class="headerlink" title="1. 分离样式文件概念"></a>1. 分离样式文件概念</h3><p>在之前写的简单demo中，处理过关于CSS，并且在预处理器篇介绍过关于CSS的预处理器：style-loader和css-loader。通过JS引入CSS样式去打包，在编写阶段可以直观的描述出来模块之间的依赖关系。</p><p>但是问题随之而来：在打包后，我们对css样式的添加，是通过标签<code>&lt;style&gt;</code>来引入的，可<code>生产环境下，一般我们希望样式存在于CSS文件中而不是style标签中，因为文件更有利于客户端进行缓存</code>。那么我们怎么输出单独的CSS文件呢？</p><h3 id="2-mini-css-extract-plugin"><a href="#2-mini-css-extract-plugin" class="headerlink" title="2. mini-css-extract-plugin"></a>2. mini-css-extract-plugin</h3><blockquote><p>该插件主要是用于提取样式到CSS文件的。</p></blockquote><p>特性：</p><ul><li>可处理多样式文件</li><li>支持按需加载</li></ul><h3 id="3-安装"><a href="#3-安装" class="headerlink" title="3 安装"></a>3 安装</h3><p><em>两种方式 选择一种即可</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add mini-css-extract-plugin</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">npm install mini-css-extract-plugin</span><br></pre></td></tr></table></figure><h3 id="4-举例"><a href="#4-举例" class="headerlink" title="4. 举例"></a>4. 举例</h3><p>举个例子：</p><p><code>a.js</code>引入自身<code>a.css</code>样式，并引入<code>b.js</code>，而<code>b.js</code>也有自身相应的<code>b.css</code>样式，那么最终样式会被同步加载，通过<code>index.html</code>的link标签加载进来。</p><h4 id="a-js"><a href="#a-js" class="headerlink" title="a.js"></a>a.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./a.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./b.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'A.JS&lt;br/&gt;'</span>);</span><br></pre></td></tr></table></figure><h4 id="a-css"><a href="#a-css" class="headerlink" title="a.css"></a>a.css</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: deepskyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="b-js"><a href="#b-js" class="headerlink" title="b.js"></a>b.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./b.css'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'B.JS&lt;br/&gt;'</span>);</span><br></pre></td></tr></table></figure><h4 id="b-css"><a href="#b-css" class="headerlink" title="b.css"></a>b.css</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: thistle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/a.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: MiniCssExtractPlugin.loader,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            publicPath: <span class="string">'../'</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">'css-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],        </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'[name].css'</span>,</span><br><span class="line">            chunkFilename: <span class="string">'[id].css'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p><img src="/images/posts/webpack7-1.png" alt="build" title="build"> </p><h4 id="HTML引入"><a href="#HTML引入" class="headerlink" title="HTML引入"></a>HTML引入</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./dist/index.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>style<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>运行引入了脚本和样式的HTML文件，查看结果：</p><p><img src="/images/posts/webpack7-2.png" alt="结果" title="结果"> </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实本篇就是单独拎出来了一个loader预处理器来介绍：<code>mini-css-extract-plugin</code>。目的就是生产环境下，通过link引入样式存在于CSS文件中而不是style标签中，这样更有利于客户端进行缓存。</p><p>下一篇介绍<strong>样式预处理</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第7篇记录——&lt;code&gt;分离样式&lt;/code&gt;，前几篇记录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;li&gt;资源输入与输出&lt;/li&gt;
&lt;li&gt;一切皆模块&lt;/li&gt;
&lt;li&gt;预处理器【上篇】&lt;/li&gt;
&lt;li&gt;预处理器——常用loader【下篇】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在之前篇章里面主要是对js的打包应用和处理，而打包方面另外一个重要工作就是&lt;code&gt;样式处理&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
      <category term="样式分离" scheme="https://www.zhuxingmin.com/tags/%E6%A0%B7%E5%BC%8F%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——预处理器(loader)【下篇】</title>
    <link href="https://www.zhuxingmin.com/2020/08/03/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8loader/"/>
    <id>https://www.zhuxingmin.com/2020/08/03/webpack实战——常用loader/</id>
    <published>2020-08-03T09:56:01.000Z</published>
    <updated>2020-08-04T07:43:01.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是<code>webpack实战</code>系列笔记的第6篇记录，前几篇记录如下：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li><li>资源输入与输出</li><li>一切皆模块</li><li>预处理器【上篇】</li></ul><p>在上一篇中根据一切皆模块的思想，学习了解了loader：概述、引入、配置及使用。本篇接着上篇的话题，讲述常用loader。</p><p>在我们项目开发中，尤其是目前流行的单页面应用，一些新手经常会在loader配置中有一些疑问，比如：</p><ul><li>对于xx资源应该使用哪个loader？</li><li>实现xx功能配置哪个loader？</li><li>…</li></ul><a id="more"></a><h2 id="常用loader介绍"><a href="#常用loader介绍" class="headerlink" title="常用loader介绍"></a>常用loader介绍</h2><p>其实，在社区上每天都会有很多loader发布，开发者在选择loader的时候要多读一下loader文档，了解loader用法，优缺点，然后根据需求去挑选。接下来介绍几种常用loader。</p><h3 id="1-babel-loader"><a href="#1-babel-loader" class="headerlink" title="1. babel-loader"></a>1. babel-loader</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><blockquote><p>babel-loader是用来<strong>处理ES6+并将其编译为ES5</strong></p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure><p>看这条安装指令，有几个参数，代表着什么呢？</p><ul><li>babel-loader：它是使Babel与Webpack协同工作的模块</li><li>@babel/core：Babel编译器的核心模块</li><li>@babel/preset-env：Babel官方推荐的预置器，可根据用户设置的目标环境自动添加所需要的插件和补丁来编译ES6+代码</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>当然，知道了参数，也需要根据loader文档注意一些小细节，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                cacheDirectory: <span class="literal">true</span>,</span><br><span class="line">                presets: [</span><br><span class="line">                    [</span><br><span class="line">                        <span class="string">'env'</span>, &#123;</span><br><span class="line">                            modules: <span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li><code>babel-loader</code>一般对于js后缀文件生效， 而在<code>node_modules</code>中所有插件有大量的js后缀文件，因此需要使用<code>exclude</code>将其排除，避免打包时速度过慢；</li><li>可以看到上面配置中添加了<code>cacheDirectory: true</code>的配置，意味着会启用缓存机制，在多次打包时，如果没有做过改变的模块不会二次编译，打包时只重新编译更改的模块，以此来加快打包速度；</li><li>另外可以看到<code>@babel/presets-env</code>中配置为<code>modules: false</code>，原因是 <strong>@babel/presets-env会自动将ES6 Module转化为CommonJS形式，会导致Webpack中的tree-shaking特性失效，而将modules配置为false后悔禁用模块化语句的转化，将Module的语法交给Webpack本身去处理，来避免这一问题的发生。</strong></li><li>babel-loader支持从.babelrc文件读取Babel配置，因此也可以将presets和plugins从Webpack配置文件中提取出来，也能达到相同效果。</li></ol><h3 id="2-ts-loader"><a href="#2-ts-loader" class="headerlink" title="2. ts-loader"></a>2. ts-loader</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><blockquote><p>用于<strong>连接Webpack与TypeScript</strong>的模块</p></blockquote><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ts-loader typescript</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        use: <span class="string">'ts-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>学习或使用过typescript的开发者都知道，typescript的配置信息在工程目录下的<code>tsconfig.jsson</code>中，因此在<code>ts-loader</code>中不配置，直接对<code>tsconfig.json</code>进行配置即可。如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">        <span class="attr">"sourceMap"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-html-loader"><a href="#3-html-loader" class="headerlink" title="3. html-loader"></a>3. html-loader</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><blockquote><p>用于<strong>将HTML文件转化为字符串并进行格式化</strong>，这使得我们可以把一个HTML片段通过JS加载进来</p></blockquote><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-loader</span><br></pre></td></tr></table></figure><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        use: <span class="string">'html-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- header.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a Header.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./header.html'</span></span><br><span class="line"><span class="built_in">document</span>.write(Header)</span><br></pre></td></tr></table></figure><h3 id="4-vue-loader"><a href="#4-vue-loader" class="headerlink" title="4. vue-loader"></a>4. vue-loader</h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><blockquote><p>vue-loader用于<strong>处理.vue组件</strong>，类似如下示例形式，常与vue-template-compiler、css-loader配合使用。</p></blockquote><h4 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-loader vue vue-template-compiler css-loader</span><br></pre></td></tr></table></figure><p>包含有：</p><ul><li>vue</li><li>vue-loader</li><li>vue-template-compiler</li><li>css-loader</li></ul><h4 id="vue组件示例"><a href="#vue组件示例" class="headerlink" title="vue组件示例"></a>vue组件示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">'vue-loader'</span>,</span></span><br><span class="line"><span class="undefined">    data() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            msg: <span class="string">'vue-loader'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">h1&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#f00</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: <span class="string">'vue-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><em>此处展示基础vue-loader示例，更多配置可以参考vue-loader官网文档</em></p><h3 id="5-file-loader"><a href="#5-file-loader" class="headerlink" title="5. file-loader"></a>5. file-loader</h3><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><blockquote><p>用于打包文件类型的资源，并<strong>返回其PublicPath</strong></p></blockquote><h4 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader</span><br></pre></td></tr></table></figure><h4 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h4><p>以对图片（png、jpg、jepg、gif）为例来配置file-loader：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./index.js'</span>,</span><br><span class="line">    output<span class="string">" &#123;</span></span><br><span class="line"><span class="string">        path: path.join(__dirname, 'dist'),</span></span><br><span class="line"><span class="string">        filename: 'bundle.js'</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    module: &#123;</span></span><br><span class="line"><span class="string">        rules: [</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                test: /\.(png|jpg|jepg|gif)$/,</span></span><br><span class="line"><span class="string">                use: 'file-loader'</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js  测试</span></span><br><span class="line"><span class="keyword">import</span> testPng <span class="keyword">from</span> <span class="string">'./test.png'</span></span><br><span class="line"><span class="built_in">console</span>.log(testPng);   <span class="comment">// caj15a1123d2asf132c123cx132.jpg</span></span><br></pre></td></tr></table></figure><h3 id="6-url-loader"><a href="#6-url-loader" class="headerlink" title="6. url-loader"></a>6. url-loader</h3><h4 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h4><blockquote><p>与file-loader类似，不同之处在于用户可以<strong>设置一个文件大小的阈值，小于该阈值时，返回的文件以base64形式编码</strong>，大于该阈值时返回publicPath</p></blockquote><h4 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader</span><br></pre></td></tr></table></figure><h4 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|jepg|gif)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                limit: <span class="number">10240</span>,</span><br><span class="line">                name: <span class="string">'[name].[ext]'</span>,</span><br><span class="line">                publicPath: <span class="string">'./assets-path/'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如此，如果目标文件资源大小小于设置的阈值，那么目标资源将会转化为base64形式编码。 </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇着重接上一篇的loader配置，介绍了几种常用的loader及其作用和意义，如babel-loader、html-loader、vue-loader等，并配有简单地配置介绍，目的是对loader有基础的使用来促进更深的了解。回归本质，loader就是一个函数，能够处理相应功能的函数。第一个loader是源文件，之后所有loader是上一个loader的输出，最后一个loader则是输出给webpack。</p><p>除了JavaScript外，在打包方面另外一个重要工作就是<strong>样式处理</strong>。下一篇介绍webpack中对样式处理的模块。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第6篇记录，前几篇记录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;li&gt;资源输入与输出&lt;/li&gt;
&lt;li&gt;一切皆模块&lt;/li&gt;
&lt;li&gt;预处理器【上篇】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上一篇中根据一切皆模块的思想，学习了解了loader：概述、引入、配置及使用。本篇接着上篇的话题，讲述常用loader。&lt;/p&gt;
&lt;p&gt;在我们项目开发中，尤其是目前流行的单页面应用，一些新手经常会在loader配置中有一些疑问，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于xx资源应该使用哪个loader？&lt;/li&gt;
&lt;li&gt;实现xx功能配置哪个loader？&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
      <category term="loader" scheme="https://www.zhuxingmin.com/tags/loader/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——预处理器(loader)【上篇】</title>
    <link href="https://www.zhuxingmin.com/2020/07/23/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-loader/"/>
    <id>https://www.zhuxingmin.com/2020/07/23/webpack实战——预处理器-loader/</id>
    <published>2020-07-23T07:22:35.000Z</published>
    <updated>2020-07-28T01:49:07.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是<code>webpack实战</code>系列笔记的第5篇记录，前几篇记录如下：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li><li>资源输入与输出</li><li>一切皆模块</li></ul><p>上一篇简单描述了<strong>一切皆模块</strong>的思想，学以致用，来实践下~</p><a id="more"></a><h2 id="1-关于-loader"><a href="#1-关于-loader" class="headerlink" title="1. 关于 loader"></a>1. 关于 loader</h2><p>每个loader本质上都是一个函数，可用公式表达其本质：</p><blockquote><p><strong><em>output = loader(input)</em></strong></p></blockquote><ul><li>input可能是工程源文件的字符串，也可能是上一个loader转化后的结果，包含：<ul><li>字符串（转化后的结果）</li><li>source map</li><li>AST对象（抽象语法树）</li></ul></li><li>output同样包含上述几种信息。<code>如果是最后一个loader，其结果直接被送到webpack中做后续处理；否则作为下一个loader的input向后传递</code>。</li></ul><p><strong>举个例子</strong></p><p>当使用 <em>babel-loader</em> 将 ES6+ 代码转化为 ES5 时，带入公式：</p><blockquote><p><strong><em>ES5 = babel-loader(ES6+)</em></strong></p></blockquote><p>上述描述说过，loader本身是一个函数那么loader是如何工作的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">loader</span> (<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">    <span class="keyword">var</span> result = handler(content, map, meta);</span><br><span class="line">    callback(</span><br><span class="line">        <span class="literal">null</span>,   <span class="comment">// error</span></span><br><span class="line">        result.content, <span class="comment">// 转换后的内容</span></span><br><span class="line">        result.map, <span class="comment">// 转换source-map</span></span><br><span class="line">        result.meta <span class="comment">// 转换后的AST</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，该函数对接受到的内容进行转换，然后返回转换后的结果。</p><h2 id="2-loader配置"><a href="#2-loader配置" class="headerlink" title="2. loader配置"></a>2. loader配置</h2><p>那在应用层面应该如何实施呢？</p><p>在<code>一切皆模块</code>中说过静态资源的类型是各式各样的，比如静态HTML/CSS/JS、图片字体音视频等，webpack如何处理这各类资源呢？ok，loader的应用场景来了。</p><p>loader，字面意思是装载器，但在webpack中实际用途则是预处理器：<strong>webpack本身只认识JavaScript，对于其他类型的资源必须先定义一个或多个loader对其进行转译，输出为webpack能够接收的形式再继续进行，因此loader做的实际上是一个预处理的工作。</strong></p><h3 id="2-1-引入"><a href="#2-1-引入" class="headerlink" title="2.1 引入"></a>2.1 引入</h3><p>那loader到底应该如何使用呢？举例要在js中引入css文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./assets/common/css'</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* common.css */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">background</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok,现在我们执行打包操作，build一下，会发现在终端报错：</p><p><img src="/images/posts/webpack5-1.png" alt="出现报错" title="出现报错"></p><p>为解决报错，我们需要用到的就是loader了~</p><p>可以在上图报错内容除看到，提示我们没找到合适的loader来处理，并且给出<code>css-loader</code>提示，我们按提示安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm</span></span><br><span class="line">npm install css-loader</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者 yarn   与npm二选一即可</span></span><br><span class="line">yarn add css-loader</span><br></pre></td></tr></table></figure><p>安装完成后，仍需在webpack.config.js中进行loader配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对loader进行配置，<strong>配置项都在module对象中的rules模块。rules模块是一个数组，代表了要对模块进行处理的规则</strong>。在此处，我们使用到的规则有<code>test</code>和<code>use</code>：</p><ul><li><strong>test</strong>：接收一个正则表达式或者一个元素为正则表达式的数组，只有正则匹配上的模块才会使用本条规则；</li><li><strong>use</strong>：接收一个数组，代表该规则所使用的loader。</li></ul><p>然后进行打包操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm</span></span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者 yarn   与npm二选一即可</span></span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure><p>然后发现，打包错误解决。</p><p>但，新的问题出现了：<br>此时我们在浏览器打开<code>index.html</code>，发现样式并没有生效。原因是<strong>css-loader 的作用是处理css的加载语法而不是做style的样式渲染，因此我们需要添加一个 style-loader 来进行样式渲染。</strong></p><h3 id="2-2-链式loader"><a href="#2-2-链式loader" class="headerlink" title="2.2 链式loader"></a>2.2 链式loader</h3><p>在上面我们说了需要在引入一个 <strong>style-loader</strong> 来进行样式渲染处理，先安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm</span></span><br><span class="line">npm install style-loader</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者 yarn   与npm二选一即可</span></span><br><span class="line">yarn add style-loader</span><br></pre></td></tr></table></figure><p>接着搭配之前的webpack配置，做一些修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css style</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们将<code>style-loader</code>写在了<code>use</code>的数组中，并且细心的朋友可能发现写在了<code>css-loader</code>之前，这就是<strong>链式loader</strong>。</p><p>那么为什么要区分顺序呢？在前面描述关于loader的公式中我们介绍过:</p><blockquote><p><strong><em>output = loader(input)</em></strong> ，</p></blockquote><p><strong>在链式webpack打包中，是按照数组从后往前的顺序将资源交给loader去处理，因此最后生效的应该放在前面。</strong></p><p>此时，我们在执行打包操作，然后可以在浏览器中看到<code>index.html</code>页面加载了样式：</p><p><img src="/images/posts/webpack5-2.png" alt="样式加载成功" title="样式加载成功"></p><h3 id="2-3-其他配置"><a href="#2-3-其他配置" class="headerlink" title="2.3 其他配置"></a>2.3 其他配置</h3><h4 id="2-3-1-options配置"><a href="#2-3-1-options配置" class="headerlink" title="2.3.1 options配置"></a>2.3.1 options配置</h4><p>有些loader会有专门的配置项，形式上可能会有一些不同，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'style-loader'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            <span class="comment">// css-loader相关配置</span></span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，具体配置项参数和值则需要参考相应loader的文档来进行配置，用时参阅该loader文档即可。</p><h4 id="2-3-2-exclude-和-include"><a href="#2-3-2-exclude-和-include" class="headerlink" title="2.3.2 exclude 和 include"></a>2.3.2 exclude 和 include</h4><p>从字面意思理解，这两个分别是用来<code>排除或者包含</code>指定目录下模块的。</p><p>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面配置了<code>exclude: /node_modules/</code>，则代表着该目录下的所有模块都不会被此条规则限制，也就是说<code>node_modules</code>中的模块不会执行该规则。</p><p>同样，include用途与此类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">                include: <span class="regexp">/src/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到此处使用的是<code>include</code>，代表<strong>该规则只对正则匹配到的模块生效</strong>，也就是说只对src下的模块生效。</p><p><strong><em>在<code>exclude</code>和<code>include</code>同时存在的情况下，<code>exclude</code>优先级更高！</em></strong></p><p>通常情况下，在使用loader时，需要配置它，以此来加速打包速度，不配置的话打包会将所有模块打包，可能拖慢整体的打包速度。</p><h4 id="2-3-3-resource-与-issuer"><a href="#2-3-3-resource-与-issuer" class="headerlink" title="2.3.3 resource 与 issuer"></a>2.3.3 resource 与 issuer</h4><p>有时候，我们会在项目中看到关于<code>resource</code>和<code>issuer</code>的相关配置，那么这两个配置是做什么的呢？</p><p>其实与<code>exclude</code>和<code>include</code>类似，都是用于规定模块作用范围的配置。但是区别是<code>exclude</code>和<code>include</code>对规则的作用范围更加的精确。<br>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./src/common.css'</span></span><br></pre></td></tr></table></figure><p>在webpack中，我们认为<strong>被加载模块是resource，加载者是issuer</strong>，在上述代码中，css作为被加载者，而index作为加载者。</p><p>那么具体如何使用呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                issuer: &#123;</span><br><span class="line">                    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                    include: <span class="regexp">/src/</span>pages/</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们看到配置了<code>issuer</code>对象，限制是让<code>src/pages</code>目录下js可以引用使用规则<code>css-loader</code>。</p><p>我们看完后会发现一个风格问题： 代码可读性较差。可以稍加改善：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// css</span></span><br><span class="line">            &#123;</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">                resource: &#123;</span><br><span class="line">                    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                    exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">                &#125;,</span><br><span class="line">                issuer: &#123;</span><br><span class="line">                    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                    exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过添加resource对象来讲外层配置包裹起来，区分resource和issuer的规则，看上去即可一目了然，但实际本质一样。可选择一种风格进行配置。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇介绍了loader的作用和意义，以及在项目中实际使用时的一些配置，如引入、使用过程、链式loader、loader的配置等，从各大小方面均能做到对项目有优化或效率提升。<br>下一篇介绍几个项目常用loader以及如何自定义loader。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第5篇记录，前几篇记录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;li&gt;资源输入与输出&lt;/li&gt;
&lt;li&gt;一切皆模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上一篇简单描述了&lt;strong&gt;一切皆模块&lt;/strong&gt;的思想，学以致用，来实践下~&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——一切皆模块</title>
    <link href="https://www.zhuxingmin.com/2020/07/20/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%80%E5%88%87%E7%9A%86%E6%A8%A1%E5%9D%97/"/>
    <id>https://www.zhuxingmin.com/2020/07/20/webpack实战——一切皆模块/</id>
    <published>2020-07-20T04:00:12.000Z</published>
    <updated>2020-07-21T09:31:22.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是<code>webpack实战</code>系列笔记的第4篇记录，简单描述一个思想：模块化思想——<code>一切皆模块</code>。本系列前几篇：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li><li>资源输入与输出</li></ul><a id="more"></a><h2 id="一切皆模块"><a href="#一切皆模块" class="headerlink" title="一切皆模块"></a>一切皆模块</h2><p>一个web工程通常会包含一系列的静态资源，并且这些资源一般会存在某种相互依赖的关系。一般静态资源包含：</p><ul><li>HTML/CSS/JS</li><li>图片/音视频x</li><li>字体</li><li>模板</li><li>。。。</li></ul><p>而其中可能存在的联系也容易举例，比如JS之间相互导出引入、HTML中会引入CSS、JS，而CSS和JS中又可能会引入图片、音视频等媒体资源。</p><p>但是对于webpack来说，这些静态资源却都是模块，我们可以像加载一个JS模块一样去加载它们，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'@/reset.css'</span></span><br></pre></td></tr></table></figure><p>如果经常使用vue\react等单页面框架去构建项目的一定会非常熟悉这种写法，但如果没接触过的也一定会感觉这种写法比较新奇，甚至迷惑不解：从JS中加载CSS的意义何在呢？</p><p>其实从显示结果来看各种方法所呈现的页面都一样，但是实际上，上述语句却将<em>reset.css</em>打包生成在了输出资源目录下，并且描述了JS与CSS文件之间的依赖关系。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>举个场景：<strong>某页面模块需要用到按钮</strong>，于是我们加载它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/page/index.js'</span></span><br><span class="line">imort Button <span class="keyword">from</span> <span class="string">'./ui/button/button.js'</span></span><br></pre></td></tr></table></figure><p>但是加载了JS文件之后发现需要各类样式，因此仍需要引入按钮组件的样式文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/page/style.scss  以SCSS为例</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./ui/button/style.scss'</span></span><br></pre></td></tr></table></figure><p>当然，在webpack中实际构建时，可以采用更加简洁的写法来处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/page/index.js</span></span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'./ui/button/index.js'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.scss'</span>   <span class="comment">// 引用页面自身样式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./ui/button/index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.scss'</span>   <span class="comment">// 引用组件自身样式</span></span><br></pre></td></tr></table></figure><p>从上例子可以看到，在button的JS中加载了组件自身的样式，但对于需要该组件的页面来说，只需要引入button的js模块即可，不需要再这里引入button的样式了。</p><p>可以画出依赖图便于理解：</p><ul><li><p>先看一般情况下的流程：<br><img src="/images/posts/webpack4-1.png" alt="一般情况" title="一般情况"></p></li><li><p>接下来看使用webpack：<br><img src="/images/posts/webpack4-2.png" alt="webpack" title="webpack"></p></li></ul><p>可以看到，在一般情况下，JS和Style样式是分开处理的，我们需要分别维护组件JS和SCSS，每当我们增删一个或多个组件的时候，都需要多次操作操作：引入 JS&amp;SCSS 或者删除 JS&amp;SCSS。但在使用 webpack 的情况下，可以看到，button 模块被作为一个整体被引入进来，这样不仅可以直观且请清晰的看到依赖关系（JS和SCSS被作为一个整体引入到page/index.js），而且在进行组件的引入与删除时，直接操作一次即可达成目的。</p><p>在项目具有一定规模的情况下，可以更加清晰明了的总结出webpack对我们项目工程优化之处：</p><ol><li>工程结构更简洁</li><li>让依赖关系更直观</li><li>代码可维护性更强</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在前面我们也说过模块化的一些特性：高内聚性和可复用性，而本篇旨在描述出<strong>一切皆模块</strong>的思想，在学习webpack过程中，可以将这一思想尽情发挥到每一种静态资源上，从而使得项目系统更加简洁且健壮！下一篇继续发挥一切皆模块思想——预处理器（loader）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第4篇记录，简单描述一个思想：模块化思想——&lt;code&gt;一切皆模块&lt;/code&gt;。本系列前几篇：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;li&gt;资源输入与输出&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——资源输入与输出</title>
    <link href="https://www.zhuxingmin.com/2020/07/13/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E8%B5%84%E6%BA%90%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"/>
    <id>https://www.zhuxingmin.com/2020/07/13/webpack实战——资源输入与输出/</id>
    <published>2020-07-13T11:34:45.000Z</published>
    <updated>2020-07-15T07:57:39.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是<code>webpack实战</code>系列笔记的第三篇记录：资源输入与输出。前两篇：</p><ul><li>打包第一个应用</li><li>模块化与模块打包</li></ul><h2 id="1-资源处理流程"><a href="#1-资源处理流程" class="headerlink" title="1. 资源处理流程"></a>1. 资源处理流程</h2><p>前两篇的博客中提及，webpack主要作用是对 <strong>解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起</strong>，那么我们就要对资源处理的流程有一个了解。各个流程如下：</p><a id="more"></a><p><strong>处理流程</strong></p><ol><li><code>指定入口(entry)</code>： 告诉webpack从哪儿入手开始打包。</li><li><code>打包封装(chunk)</code>： 存在依赖关系的模块在打包时被封装为一个chunk，chunk就像文件袋，里面包裹着很多文件（模块）。根据配置，可能会产生一个或者多个chunk。</li><li><code>打包产物(bundle)</code>： 由上述chunk得到的打包产物则为bundle。</li></ol><p><strong>三者关系</strong></p><p><img src="/images/posts/webpack3-1.png" alt="三者关系图" title="三者关系图"></p><h2 id="2-资源入口"><a href="#2-资源入口" class="headerlink" title="2. 资源入口"></a>2. 资源入口</h2><p>webpack决定入口文件路径需要通过两个配置项：<code>context</code>和<code>entry</code>。配置时做了两件事：</p><ul><li>确定入口模块位置<br>告诉webpack从哪儿开始打包</li><li>定义chunk name<br>分两种情况，如果是单入口，那么默认chunk name是“main”，如果是多个入口，则需要为每个入口定义不同的chunk name来作为chunk的唯一标识。</li></ul><h3 id="2-1-context"><a href="#2-1-context" class="headerlink" title="2.1 context"></a>2.1 context</h3><p>context可以理解为资源入口的路径前缀，要求使用绝对路径的形式。<br>以下两个案例效果相同：</p><p><em>注：入口文件为: <code>./src/js/index.js</code></em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例1</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 入口</span></span><br><span class="line">    context: path.join(__dirname, <span class="string">'./src'</span>),</span><br><span class="line">    entry: <span class="string">'./js/index.js'</span>,</span><br><span class="line">    <span class="comment">// 出口</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 打包模式：develop-开发，production-生产</span></span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例2</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    context: path.join(__dirname, <span class="string">'./src/js'</span>),</span><br><span class="line">    entry: <span class="string">'./index.js'</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在多入口情况，使用context则可以使得入口编写更加整洁。如果忽略不写，那么默认值为当前工程的根目录。</p><h3 id="2-2-entry"><a href="#2-2-entry" class="headerlink" title="2.2 entry"></a>2.2 entry</h3><p>在上面可以看到，entry指定确定的入口文件。而entry的写法则有多种，如：字符串、数组、对象、函数，那么根据不同的场景来选择使用即可。 </p><p><em>注：假设入口文件为: <code>./src/index.js</code></em></p><h4 id="2-2-1-字符串类型"><a href="#2-2-1-字符串类型" class="headerlink" title="2.2.1 字符串类型"></a>2.2.1 字符串类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-数组类型"><a href="#2-2-2-数组类型" class="headerlink" title="2.2.2 数组类型"></a>2.2.2 数组类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: [<span class="string">'babel-polyfill'</span>, <span class="string">'./src/index.js'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面配置等同于↓</span></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="2-2-3-对象类型"><a href="#2-2-3-对象类型" class="headerlink" title="2.2.3 对象类型"></a>2.2.3 对象类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        main: <span class="string">'./src/main.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实对象类型是为定义多入口而设计的。如果资源入口有多个则必须使用对象类型来配置，其中，配置的<strong>属性名是chunk name</strong>，其对应的<strong>value值则是入口路径</strong>。如上述例子，<strong>main这条配置：chunk name为main,入口路径是 ./src/main.js</strong>。</p><h4 id="2-2-4-函数类型"><a href="#2-2-4-函数类型" class="headerlink" title="2.2.4 函数类型"></a>2.2.4 函数类型</h4><p>函数类型的话可以返回上述介绍的三种类型的任意类型。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串类型</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象类型</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">        <span class="comment">// 返回对象类型，其中value的路径地址可以是数组类型</span></span><br><span class="line">        index: [<span class="string">'babel-polyfill'</span>, <span class="string">'./src/index.js'</span>],</span><br><span class="line">        main: <span class="string">'./src/main.js'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-实例"><a href="#2-3-实例" class="headerlink" title="2.3 实例"></a>2.3 实例</h3><p>我们现在应用前端一些主流框架来构建项目时，可能会发现我们构造出来的页面属于<code>单页面应用（SPA：single page APP）</code>。那么对于单页面应用来说，一般只需要定义一个入口即可，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/app.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后所有的库、模块等，均由该入口文件进行引用。此法其实利弊分明：</p><ul><li>一方面只会产生一个JS文件，依赖关系清晰</li><li>另一方面则是项目过大时会造成资源体积包过大，降低页面渲染速度，从而影响用户体验度</li></ul><p>为解决该问题，我们使用提取vendor的方法。</p><h4 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h4><p><em>vendor，小贩; 摊贩; 供应商。</em></p><p>在webpack中，vendor则指的是工程中用到的库、框架等第三方模块打包而产生的bundle。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    context: path.join(__dirname, <span class="string">'./src'</span>),</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./app.js'</span>,</span><br><span class="line">        vendor: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>, <span class="string">'react-router'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，app和以往一样无需改动，但我们新增了一个chunk name为 vendor的入口，通过数组形式放入了一些第三方模块。</p><p>但我们并没有设置vendor的入口路径，webpack如何去打包呢？此时我们可以采用<code>optimization.splitChunks</code>来将app和rendor这两个chunk中的公共模块给提取出来，然后app.js中只包含业务模块，第三方模块依赖都被抽取出来作为新的bundle。由于被抽取的模块不常变动，也可以利用这个特性来做客户端缓存，从而加快整体的渲染速度。</p><h4 id="多入口"><a href="#多入口" class="headerlink" title="多入口"></a>多入口</h4><p>刚才说了单页面应用，那么多页应用一般有多个入口，在此场景中，为了尽可能减小资源的体积，我们则是希望每个页面加载自身必要的逻辑，而不是都打包到一个bundle中。此时，就需要多入口配置来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    context: path.join(__dirname, <span class="string">'./src'</span>),</span><br><span class="line">    entry: &#123;</span><br><span class="line">        page1: <span class="string">'./page1.js'</span>,</span><br><span class="line">        page2: <span class="string">'./page2.js'</span>,</span><br><span class="line">        page3: <span class="string">'./page3.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面配置中，入口与页面一一对应，如此的话每个html则只需要引入各自的js就可以加载其所需的模块。</p><p>另外，对于多页应用的场景，我们同样使用 vendor，将各个页面间的公共模块进行打包。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    context: path.join(__dirname, <span class="string">'./src'</span>),</span><br><span class="line">    entry: &#123;</span><br><span class="line">        page1: <span class="string">'./page1.js'</span>,</span><br><span class="line">        page2: <span class="string">'./page2.js'</span>,</span><br><span class="line">        page3: <span class="string">'./page3.js'</span>,</span><br><span class="line">        vendor: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置后，加上配置<code>optimization.splitChunks</code>将<code>react</code>和<code>react-dom</code>从各个页面中提取出来，生成单独的<code>bundle</code>即可。</p><h2 id="3-资源出口"><a href="#3-资源出口" class="headerlink" title="3. 资源出口"></a>3. 资源出口</h2><p>资源出口配置都集中在<strong>output</strong>对象中，包含了几十个配置项，但是大多数无需刻意配置，我们常用的一般有<code>filename</code>、<code>path</code>和<code>publicPath</code>。</p><h3 id="3-1-filename"><a href="#3-1-filename" class="headerlink" title="3.1 filename"></a>3.1 filename</h3><p>filename，控制输出资源的文件名，值为字符串形式。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 入口在 ./src/js/index.js</span></span><br><span class="line">    entry: <span class="string">'./src/js/index.js'</span>,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>   <span class="comment">// 字符串形式，控制输出资源的名字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽说值为字符串形式，但是字符串中可以不仅仅是文件名，还可以加上路径，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 入口在： ./src/js/index.js</span></span><br><span class="line">    entry: <span class="string">'./src/js/index.js'</span>,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'./js/bundle.js'</span>  <span class="comment">// 则会自动在dist下创建js目录，bundle会打包在js目录下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行打包操作后，可以看到在dist目录下生成了一个js目录，将bundle资源放在了js下：</p><p><img src="/images/posts/webpack3-2.png" alt="可指定路径输出" title="可指定路径输出"></p><p>那么如果是<strong>多入口场景</strong>，我们则需要为每个bundle指定不同的名字避免命名冲突。这时我们可以试用webpack提供的一种类似模板语言的形式动态生成，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        app: <span class="string">'./src/app.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: [name].js<span class="string">'    // [name]类似模板语言  </span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>执行打包命令后生成的资源：</p><p><img src="/images/posts/webpack3-3.png" alt="[name].js" title="[name].js"></p><p>从上图打包结果可以看出，我们配置的[name]在资源输出时，会被替换为 chunk name，最后打包输出的资源分别是<code>app.js</code>和<code>index.js</code>。除了[name]之外，还有几个常用的配置：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">[hash]</td><td style="text-align:left">webpack此次打包所有资源生成的hash值</td></tr><tr><td style="text-align:left">[chunkhash]</td><td style="text-align:left">当前chunk的hash</td></tr><tr><td style="text-align:left">[id]</td><td style="text-align:left">当前chunk的id</td></tr><tr><td style="text-align:left">[query]</td><td style="text-align:left">filename配置项中的query</td></tr></tbody></table><blockquote><p>在这几个变量中，<code>[name]</code>、<code>[id]</code>和<code>[chunkhash]</code>在有多个chunk时可以使用，用来对chunk进行区分。另外一个比较好的效果<strong>控制缓存</strong>：<code>[hash]</code>和<code>[chunkhash]</code>都与chunk内容直接相关，当chunk内容改变时，可以同时引起资源文件名的改变，从而导致用户在下一次请求资源文件时会下载新版本的内容而不是用本地缓存。如果要控制客户端缓存，一般加上<code>[chunkhash]</code>，因为每个chunk所产生的chunkhash只与自身内容相关，不会影响到其他资源，可以精准的让客户端缓存得到更新。</p></blockquote><p>在生产环境中，我们可以如下配置filename：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name]@[chunkhash].js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-path"><a href="#3-2-path" class="headerlink" title="3.2 path"></a>3.2 path</h3><p>path指定输出资源的位置，值<strong>必须是绝对路径</strong>，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.join(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：在webpack4版本及之后版本，output.path的默认路径就是dist，如果我们需要更改则如上配置可修改，如无需修改则不需单独配置。</em></p><h3 id="3-3-publicPath"><a href="#3-3-publicPath" class="headerlink" title="3.3 publicPath"></a>3.3 publicPath</h3><p>publicPath相对于path还是比较容易混淆的。</p><ul><li>path： 指定输出资源的输出位置</li><li>publicPath： 指定资源的请求位置</li></ul><p>那么怎么理解输出位置和请求位置呢？</p><blockquote><ul><li>输出位置： <code>打包后资源产生的目录</code>，不自定义配置的话默认是dist目录</li><li>请求位置： <code>JS或者CSS所请求的间接资源路径</code>。页面中的资源分两种：一种是由HTML页面直接请求的，比如通过script标签加载的JS；另一种是由JS或者CSS请求的，比如异步JS、CSS请求的图片字体等。publicPath就是用来指定这部分间接资源请求位置的。</li></ul></blockquote><p><strong>webpack-dev-server</strong></p><p>第一篇得时候介绍过关于webpack-dev-server。在webpack-dev-server中，也配置了一个publicPath，作用是指定webpack-dev-server的静态资源服务路径。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        publicPath: <span class="string">'/assets/'</span>, <span class="comment">// 指定webpack-dev-server的静态资源服务路径</span></span><br><span class="line">        port: <span class="number">8088</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-实例"><a href="#4-实例" class="headerlink" title="4. 实例"></a>4. 实例</h2><h3 id="4-1-单入口"><a href="#4-1-单入口" class="headerlink" title="4.1 单入口"></a>4.1 单入口</h3><p>单入口场景，通常不必设置动态的filename，直接输出文件名即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundie.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要使用webpack-dev-server，那么则配置devServer的publicPath即可</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        publicPath: <span class="string">'/dist/'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-多入口"><a href="#4-2-多入口" class="headerlink" title="4.2 多入口"></a>4.2 多入口</h3><p>多入口场景，则需要使用模板来配置filaneme，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name]@[chunkhash].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要devServer的话添加即可</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        publicPath: <span class="string">'/dist/'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>本篇主要记录的是webpack打包控制资源的输入和输出流程，以及各自的一些常用配置，如entry、context、filename、path等。除此之外，还介绍了例如vendor方法来提取公共资源，更有效的利用缓存来提升页面渲染速度。<br>下一篇简述“一切皆模块”的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这是&lt;code&gt;webpack实战&lt;/code&gt;系列笔记的第三篇记录：资源输入与输出。前两篇：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包第一个应用&lt;/li&gt;
&lt;li&gt;模块化与模块打包&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-资源处理流程&quot;&gt;&lt;a href=&quot;#1-资源处理流程&quot; class=&quot;headerlink&quot; title=&quot;1. 资源处理流程&quot;&gt;&lt;/a&gt;1. 资源处理流程&lt;/h2&gt;&lt;p&gt;前两篇的博客中提及，webpack主要作用是对 &lt;strong&gt;解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起&lt;/strong&gt;，那么我们就要对资源处理的流程有一个了解。各个流程如下：&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——模块打包</title>
    <link href="https://www.zhuxingmin.com/2020/07/06/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85/"/>
    <id>https://www.zhuxingmin.com/2020/07/06/webpack实战——模块打包/</id>
    <published>2020-07-06T08:40:17.000Z</published>
    <updated>2020-07-07T09:00:47.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是<strong>webpack实战</strong>系列的第二篇：<strong>模块和模块打包</strong>。上一篇：<strong>webpack实战——打包第一个应用</strong> 记录了webpack的一些基础内容与一个简单地小例子，开启了webpack的实战之路，这一篇记录一下关于模块和模块打包。</p><a id="more"></a><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>先看一下模块的定义：</p><blockquote><p>模块,是能够单独命名并独立地完成一定功能的程序语句的集合（即程序代码和数据结构的集合体）。它具有两个基本的特征：外部特征和内部特征。外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能；内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）。</p></blockquote><p>可以从定义中看出，每个独立的模块负责不同工作，彼此之间又可以联系在一起共同保证整体系统运行。那么在webpack中，如何将其打包成一个（或多个）文件呢？</p><p>想了解这些，我们还是先要熟悉在 Javascript 中的模块。在 Javascript 模块化中比较常见的有：</p><ul><li>CommonJS</li><li>ES6 module</li><li>AMD</li><li>CMD</li><li>UMD(AMD和CommonJS)</li><li>…</li></ul><p>但由于在目前的使用场景中 <code>CommonJS</code> 和 <code>ES6 module</code> 居多，因此暂时就这两者进行讨论。</p><h2 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1. CommonJS"></a>1. CommonJS</h2><h3 id="1-1-模块"><a href="#1-1-模块" class="headerlink" title="1.1 模块"></a>1.1 模块</h3><p><strong>在 CommonJS 中规定每个文件都是一个模块。</strong></p><p>在 CommonJS 中，变量及函数的声明不会造成全局污染。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'name: add.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'name: index.js'</span>;</span><br><span class="line">reuqire(<span class="string">'./add.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// name: index.js</span></span><br></pre></td></tr></table></figure><p>在上面 index.js 中通过 require 函数来加载 add.js ，输出的结果是 <code>name: index.js</code> ，说明在 add 中定义的变量并不会影响 index ，可以得出使用 CommonJs 模块，作用域只针对于该模块，而<strong>不会造成全局污染，对外不可见</strong>。</p><h3 id="1-2-导出"><a href="#1-2-导出" class="headerlink" title="1.2 导出"></a>1.2 导出</h3><p>前面说过模块拥有自己的作用域，那么模块是需要向外传递的，怎么办呢？<br><strong>导出是一个模块向外暴露自身的唯一方式</strong>。在 CommonJS 中，我们通过 <code>module.exports</code> 来导出模块中的内容。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name: <span class="string">'add'</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 CommonJS 内部会有一个 module 对象用于存放当前模块的信息。而 module.exports 则指定向外暴露的内容。</p><h3 id="1-3-导入"><a href="#1-3-导入" class="headerlink" title="1.3 导入"></a>1.3 导入</h3><p>导出自然是为了另外一个模块来使用，这时便使用到了导入功能。在 CommonJS 中，使用 require 来进行模块导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name: <span class="string">'add'</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="built_in">require</span>(<span class="string">'./add.js'</span>);</span><br><span class="line"><span class="keyword">const</span> sum = add.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum);   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面这个例子，便是在 index.js 中通过 require 导入了 add.js ，并且调用了其中的 add() 方法。</p><p>而我们在 reuqire 一个模块的时候，会分两种情况：</p><ol><li>如果 require 的模块第一次被加载，那么会执行该模块然后导出内容；</li><li>如果非首次加载，那么该模块代码不会再次执行，而是直接导出上次代码执行后所得到的结果。</li></ol><p>有时候我们只想通过加载执行某个模块让它产生某种作用而不需要获取它所导出的内容，则可以直接通过 require 来导入而不需要定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./task.js'</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>而通过这个特性，加上 require 函数可以接收表达式，那么我们则可以动态指定模块加载路径：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleList = [<span class="string">'add.js'</span>, <span class="string">'subtract.js'</span>];</span><br><span class="line">moduleList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">`./<span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-ES6-Module"><a href="#2-ES6-Module" class="headerlink" title="2. ES6 Module"></a>2. ES6 Module</h2><p>熟悉 JavaScript 语言的小伙伴知道，其实在 JavaScript 设计之初，并没有模块化这个概念。而伴随 JavaScript 不断的壮大发展，社区中也涌现出了不少模块化概念。一直到 ES6 ， JavaScript 终于正式的有了模块化这一特性。</p><h3 id="2-1-模块"><a href="#2-1-模块" class="headerlink" title="2.1 模块"></a>2.1 模块</h3><p>在前面我们使用 CommonJS 实现了一个例子来展示 CommonJS 的模块、导出与导入，同样在此处也先来一个例子，只需将上面例子稍微改写即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'add'</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">'./add.js'</span>;</span><br><span class="line"><span class="keyword">const</span> sum = add.add(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>ES6 Module 也是将每一个文件都作为一个模块，并且每个模块拥有自身的作用域，但是与 CommonJS 相比， 不同的是导入、导出语句。在 ES6 Module 中，<br>import 和 export 也作为关键字被保留。</p><h3 id="2-2-导出"><a href="#2-2-导出" class="headerlink" title="2.2 导出"></a>2.2 导出</h3><p>在 ES6 Module 中，使用 export 来对模块进行导出。</p><p>export 导出的两种方式：</p><ul><li>命名导出</li><li>默认导出</li></ul><h4 id="2-2-1-命名导出"><a href="#2-2-1-命名导出" class="headerlink" title="2.2.1 命名导出"></a>2.2.1 命名导出</h4><p>以下有两种写法，但其效果并无区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 命名导出： 两种写法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 声明和导出写在一起</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">'add'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 先声明，再统一导出</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'add'</span>;</span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; name, add &#125;</span><br></pre></td></tr></table></figure><p><strong>as关键字</strong></p><p>在使用命名导出时，如果用写法2（先声明再统一导出），可以使用 <code>as 关键字</code> 来对导出的变量进行重命名。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'add'</span>;</span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add as sum ： 在导入时，使用 name 和 sum 即可</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, add <span class="keyword">as</span> sum &#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-默认导出"><a href="#2-2-2-默认导出" class="headerlink" title="2.2.2 默认导出"></a>2.2.2 默认导出</h4><p>说完了命名导出，来到默认导出：模块的默认导出只能导出一个。举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> defailt &#123;</span><br><span class="line">    name: <span class="string">'add'</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可见，我们可以将默认导出理解为向外输出了一个命名为 default 的变量。</p><h3 id="2-3-导入"><a href="#2-3-导入" class="headerlink" title="2.3 导入"></a>2.3 导入</h3><p>ES6 Module 中使用 import 进行模块导入。由于在 ES6 Module 的导出中，分为 <code>命名导出</code> 和 <code>默认导出</code> ，因此在导入的时候也有对应的两种方式进行导入。</p><h4 id="2-3-1-命名"><a href="#2-3-1-命名" class="headerlink" title="2.3.1 命名"></a>2.3.1 命名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'add'</span>;</span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; name, add &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, add &#125; <span class="keyword">from</span> <span class="string">'./add.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name, add(<span class="number">1</span>, <span class="number">2</span>));   <span class="comment">// add 3</span></span><br></pre></td></tr></table></figure><p>可以看到，在使用 import 对命名导出模块进行引入的时候， import 后面跟了一对花括号 <code>{ }</code> 将导入的变量名包裹起来，并且变量名需要与导出时的变量命名一样。同样，我们还是可以使用 <code>as 关键字</code> 来对变量进行重命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, add <span class="keyword">as</span> sum &#125; <span class="keyword">from</span> <span class="string">'./add.js'</span></span><br><span class="line">sum(<span class="number">2</span>, <span class="number">2</span>);  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong><em>值得注意的是，导入变量的效果相当于在当前作用域下声明了变量（如 name 和 add），但不可对这些变量不能修改，只可当成只读的来使用。</em></strong></p><p>当然，我们还可以使用 <code>*</code> 来进行整体导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> add <span class="keyword">from</span> <span class="string">'./add.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(add.name);  <span class="comment">// add</span></span><br><span class="line"><span class="built_in">console</span>.log(add.add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-默认"><a href="#2-3-2-默认" class="headerlink" title="2.3.2 默认"></a>2.3.2 默认</h4><p>对于默认导出的导入处理如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'add'</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> addMe <span class="keyword">from</span> <span class="string">'./add.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(addMe.name, addMe.add(<span class="number">2</span>, <span class="number">5</span>));   <span class="comment">// add 7</span></span><br></pre></td></tr></table></figure><p>可以看到，如果是导入默认导出的模块，那么在 import 后面直接跟变量名即可，并且这个变量名无需与导出模块的变量名重复，可以自己指定新的变量名。</p><h2 id="3-CommonJS-与-ES6-Module-的区别"><a href="#3-CommonJS-与-ES6-Module-的区别" class="headerlink" title="3. CommonJS 与 ES6 Module 的区别"></a>3. CommonJS 与 ES6 Module 的区别</h2><p>介绍了 CommonJS 与 ES6 Module 的基础应用之后，我们也要了解到在实际的开发过程中我们经常将这两者在同一个项目中混用。为了避免不必要的麻烦，还是要说一下两者的异同。</p><h3 id="3-1-动态与静态"><a href="#3-1-动态与静态" class="headerlink" title="3.1 动态与静态"></a>3.1 动态与静态</h3><p><strong>CommonJS 对模块依赖的解决是动态的，而 ES6 Module 对模块依赖的解决是静态的。</strong></p><p>首先要了解这里说的<code>动态</code>与<code>静态</code>是什么：</p><ul><li>动态： 模块依赖关系的建立发生在代码<code>运行阶段</code>；</li><li>静态： 模块依赖关系的建立发生在代码<code>编译阶段</code>；</li></ul><p>由于 ES6 Module 中导入导出语句都是声明式的，不支持导入表达式类路径，并且导入导出语句必须位于模块的顶层作用域。相比 CommonJS ，具备优势如下：</p><ul><li><strong>死代码检测和排除</strong>： 可以使用静态分析工具检测出没有被调用的模块，减小打包资源体积；</li><li><strong>模块变量类型检查</strong>： 有助于确保模块之间传递的值或者接口类型的正确性；</li><li><strong>编译器优化</strong>： ES6 Module 直接导入变量，减少层级引用，程序效率更高。</li></ul><h3 id="3-2-值拷贝和动态映射"><a href="#3-2-值拷贝和动态映射" class="headerlink" title="3.2 值拷贝和动态映射"></a>3.2 值拷贝和动态映射</h3><p>在导入一个模块时，对于 CommonJS 来说获取的是一份导出值的拷贝，而在 ES6 Module 中则是值的动态映射，这个映射是只读的。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    count: count,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="built_in">require</span>(<span class="string">'./add.js'</span>).count;</span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'./add/js'</span>).add;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 0 (这里的count是对add.js中couunt的拷贝)</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 0 (add.js中变量值的改变不会对这里的拷贝值造成影响)</span></span><br><span class="line"></span><br><span class="line">count += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1 (拷贝的值 0 + 1 = 1，表示拷贝的值可以更改)</span></span><br></pre></td></tr></table></figure><p>可以看出，index.js 中的 count 是 add.js 中 count 的一份值拷贝，因此在调用 add 函数时，即便更改了 add 中的 count，但不会对 index.js 中的值拷贝造成影响。</p><p>但在 ES6 Module 中，却不一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; count, add &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; count, add &#125; <span class="keyword">from</span> <span class="string">'./add.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 0 (对add.js中count值的映射)</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1 (对add.js中count值的映射，会映射值的变化)</span></span><br><span class="line"></span><br><span class="line">count += <span class="number">1</span>; <span class="comment">// 报错，该count值不可更改</span></span><br></pre></td></tr></table></figure><h2 id="4-模块打包原理"><a href="#4-模块打包原理" class="headerlink" title="4. 模块打包原理"></a>4. 模块打包原理</h2><p>前面描述了一些基础的 CommonJS 与 ES6 Module 模块化的一些知识，那么回到 webpack 中来：webpack是如何将各种模块有序的组织在一起的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="built_in">require</span>(<span class="string">'./add.js'</span>);</span><br><span class="line"><span class="keyword">const</span> sum = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`sum: <span class="subst">$&#123;sum&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>还是之前的例子，但现在经过 webpack 打包之后，它会变成什么样子呢？</p><p><img src="/images/posts/webpack2-1.png" alt="bundle.js"></p><p>如图所示，这便是一个简单地打包结果。我们可以观察自己的 bundle.js 文件，从中看打包逻辑关系：</p><ul><li>首先一个立即执行匿名函数，包裹所有内容，构成资深作用域；</li><li>installedModule对象（模块缓存），每个模块在第一次被加载的时候执行，到处结果存储到其中，以后再次调用模块直接取值即可，不会再次执行模块；</li><li><strong>webpack_require</strong>函数： 对模块加载的实现，在浏览器中可以通过调用此函数加模块id来进行模块导入；</li><li>modules对象：工程中所有产生依赖关系的模块都会以 <code>key-value</code> 形式放在此对象中， key 作为模块 id，由数字或者 hash 字符串构成，value 则由一个匿名函数包裹的模块构成，匿名函数的参数则赋予了每个模块导出和导入能力。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇记录了关于 JavaScript 的模块化与 webpack 的模块打包原理简介。</p><p>首先，介绍了关于模块的概念，然后依次介绍了两种模块化：CommonJS 和 ES6 Module ，以及他们分别的模块概念、导出和导入，接着介绍了他们之间的两个差异：动态与静态、值拷贝和映射。最后，提及了一下模块化打包的简单原理，对webpack打包工作有一个大概认知。</p><p>下一篇将会介绍在webpack中资源的输入与输出。敬请期待。</p><hr><p>学习推荐： 本系列学习资源多来自于 <em>《webpack实战 入门、进阶与调优》</em> ，作者 <em>居玉皓</em> ， 感兴趣的朋友可以购买实体书支持学习~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这是&lt;strong&gt;webpack实战&lt;/strong&gt;系列的第二篇：&lt;strong&gt;模块和模块打包&lt;/strong&gt;。上一篇：&lt;strong&gt;webpack实战——打包第一个应用&lt;/strong&gt; 记录了webpack的一些基础内容与一个简单地小例子，开启了webpack的实战之路，这一篇记录一下关于模块和模块打包。&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实战——打包第一个应用</title>
    <link href="https://www.zhuxingmin.com/2020/07/03/webpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%89%93%E5%8C%85%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/"/>
    <id>https://www.zhuxingmin.com/2020/07/03/webpack实战——打包第一个应用/</id>
    <published>2020-07-03T03:48:56.000Z</published>
    <updated>2020-07-03T12:01:58.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近学习了一些关于webpack的知识，在此做一些纪录。<br>作为前端开发者，我们以前在浏览器中运行 JavaScript ，会引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈；亦或使用一个包含所有项目代码的大型 <code>.js</code> 文件，但是这会导致作用域、文件大小、可读性和可维护性方面的问题。</p><a id="more"></a><p>后来，模块化诞生……随之而来的是一个新的时代，基于 <code>node.js</code> 的一系列解决方案也是孕育而生，各种功能、方法都是用模块，对于开发、维护也是极大的瓶颈突破和效率提升，但是新的问题随之而来，各种模块不是浏览器支持不够友好，就是各依赖问题难以手动解决或者构建……而 <code>webpack</code> 此时也是破空而出，是用于现代 JavaScript 应用程序的静态模块打包工具。最核心的功能则是解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，最终合并为一个或多个 <code>.js</code> 文件。这个过程也被称为 <code>模块打包</code> 。<br>那么webpack到底神秘在何处？为何前端大框架都用它来配置？为何近年面试频频被问？上手难度几何？实际效果又如何？<br>本专题文章着手纪录webpack实战过程，从零开始着手webpack的配置过程及优化方案，例如<strong>模块打包</strong>、<strong>资源输入输出</strong>、<strong>预处理器</strong>、<strong>样式处理</strong>、<strong>代码切割</strong>、<strong>打包优化</strong>、<strong>开发环境调优</strong> 等等篇章。<br>本篇纪录关于webpack的简介以及环境配置、打包第一个应用~</p><h2 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h2><p><img src="/images/posts/webpack1-1.png" alt="webpack"></p><h3 id="1-什么是webpack"><a href="#1-什么是webpack" class="headerlink" title="1. 什么是webpack"></a>1. 什么是webpack</h3><blockquote><p>webpack是一个开源的Javascript模块打包工具，最核心的功能是解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，最终合并为一个JS文件。</p></blockquote><h3 id="2-为什么选择webpack"><a href="#2-为什么选择webpack" class="headerlink" title="2. 为什么选择webpack"></a>2. 为什么选择webpack</h3><p>对比同类模块打包工具，具备以下优势：</p><ul><li>支持多种模块标准，如AMD，CommonJS及ES6模块等</li><li>具有完备的代码分割功能，可以有效减小资源体积，提升首页渲染速度</li><li>可以处理各类型资源，如css、png等</li><li>拥有庞大的社区支持</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h3><ul><li>操作系统： 无要求</li><li>环境： Node.js</li></ul><p>此处使用macOS或者windows为例。</p><h3 id="2-Node-js安装"><a href="#2-Node-js安装" class="headerlink" title="2. Node.js安装"></a>2. Node.js安装</h3><p>打开<a href="http://nodejs.cn/" target="_blank" rel="noopener">node.js中文网（http://nodejs.cn/）</a>，点击下载项安装对应系统的安装包即可。</p><h3 id="3-webpack安装"><a href="#3-webpack安装" class="headerlink" title="3. webpack安装"></a>3. webpack安装</h3><ol><li>新建一个目录作为工程目录</li><li>然后终端进入或者通过命令行工具执行npm初始化：<br><code>npm init</code></li><li>依次输入所提示的的基本信息，完成后得到一个<code>package.json</code>文件<br><img src="/images/posts/webpack1-2.png" alt="webpack安装"></li><li>执行安装webpack和webpack-cli<br><code>npm i webpack webpack-cli --save-dev</code></li><li>执行完成好就完成了安装过程</li></ol><h2 id="打包第一个应用"><a href="#打包第一个应用" class="headerlink" title="打包第一个应用"></a>打包第一个应用</h2><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><p>接着刚才的步骤继续：</p><ul><li>项目根目录建入口文件： index.html</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>my first webpack app<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>项目根目录新建文件夹<code>src</code>，存放两个js文件：<code>index.js</code>和<code>hello.js</code></li><li>index.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">'./hello.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'my first webpack app &lt;br/&gt;'</span>);</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure><ul><li>hello.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">'hello world!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>命令行工具执行打包命令：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack --entry=./src/index.js --output-filename=bundle.js --mode=development</span><br></pre></td></tr></table></figure><ul><li><p>执行结果（和工程目录）如下：<br><img src="/images/posts/webpack1-3.png" alt="第一次打包应用"></p></li><li><p>验证结果：浏览器打开<code>index.html</code>，查看页面结果：<br><img src="/images/posts/webpack1-4.png" alt="结果"></p></li></ul><h2 id="命令优化"><a href="#命令优化" class="headerlink" title="命令优化"></a>命令优化</h2><p>在上述打包命令中，我们使用<code>npx webpack --entry=./src/index.js --output-filename=bundle.js --mode=development</code>来执行打包，但这一段命令冗长而又耗时，搞不好还容易出错。那么有没有简洁一些的方法呢？<br>当然有！</p><h3 id="1-使用-npm-scripts-配置"><a href="#1-使用-npm-scripts-配置" class="headerlink" title="1. 使用 npm scripts 配置"></a>1. 使用 npm scripts 配置</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>打开根目录的配置文件，编辑一条 <code>scripts</code> 命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"w1"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"打包第一个应用"</span>,</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">    <span class="attr">"author"</span>: <span class="string">"zxm"</span>,</span><br><span class="line">    <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line"></span><br><span class="line">    // 添加命令</span><br><span class="line">    "scripts": &#123;</span><br><span class="line">        "build": "webpack --entry=./src/index.js --output-filename=bundle.js --mode=development"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scripts</code> 是 <code>npm</code> 提供的脚本命令功能，在这里可以直接使用模块所添加的指令。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>我们修改<code>hello.js</code>中的输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">'hello scripts'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行打包命令：<code>npm run build</code>，观察结果：</p><p><img src="/images/posts/webpack1-5.png" alt="结果"></p><h3 id="2-使用配置文件配置"><a href="#2-使用配置文件配置" class="headerlink" title="2. 使用配置文件配置"></a>2. 使用配置文件配置</h3><p>从上面命令可以看出，我们使用 <code>scripts</code> 命令一样可以代替执行 webpack 的打包命令，并且在命令行工具中使用则会更加简洁。<br>但是存在一个问题，如果项目需要越来越多的配置，那么就需要往命令中塞入更多的参数，越来越多，到后期，项目的维护成本则正比的增加许多。为了解决此问题，可以将这些参数用对象的配置形式来统一存放到一个配置文件中，然后webpack每次打包都读取该配置文件即可。</p><ul><li>根目录新建文件：<code>webpack.config.js</code>，并配置如下代码：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 入口文件指定</span></span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    <span class="comment">// 输出资源配置</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 打包模式：develop-开发，production-生产</span></span><br><span class="line">    mode: <span class="string">'development'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改<code>package.json</code>文件的<code>scripts &gt; build</code>配置：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 修改后如下：</span><br><span class="line">    "scripts": &#123;</span><br><span class="line">        "build": "webpack"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>校验：修改<code>hello.js</code>的输出：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">`this is webpack.config\'s result`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行<code>npm run build</code>，刷新浏览器，看结果：</li></ul><p><img src="/images/posts/webpack1-6.png" alt="结果"></p><p>至此，webpack的初始化环境配置及基础配置已经完毕。但是我们现在遇到一个麻烦事：我们没更改一些代码，则需要重新打包才能去测试，才能看到结果，那么有没有什么简洁的方案处理呢？有！继续操作~</p><h3 id="3-开发优化——热更新"><a href="#3-开发优化——热更新" class="headerlink" title="3. 开发优化——热更新"></a>3. 开发优化——热更新</h3><p>webpack社区为我们提供了一个便捷的本地开发工具：<code>webpack-dev-server</code>，</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>执行安装命令：<br><code>npm i webpack-dev-server --save-dev</code></p><h4 id="新增-npm-scripts-命令"><a href="#新增-npm-scripts-命令" class="headerlink" title="新增 npm scripts 命令"></a>新增 npm scripts 命令</h4><p>前面刚写了一个<code>scripts</code>命令，那么此时再添加一个<code>dev</code>来配置。编辑根目录的<code>package.json</code>文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    "scripts": &#123;</span><br><span class="line">        "build": "webpack --entry=./src/index.js --output-filename=bundle.js --mode=development",</span><br><span class="line">        "dev": "webpack-dev-server"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还没结束，仍需在webpack中配置一下：</p><h4 id="webpack-config-js添加dev-server配置"><a href="#webpack-config-js添加dev-server配置" class="headerlink" title="webpack.config.js添加dev-server配置"></a>webpack.config.js添加dev-server配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增： dev-server配置</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        publicPath: <span class="string">'/dist'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h4><p>执行命令<code>npm run dev</code></p><p><img src="/images/posts/webpack1-7.gif" alt="执行结果"></p><p>可以看到，在左侧代码块中修改内容后，只需要保存即可，右边浏览器则自动刷新了~~</p><p>这个功能可以脱离<code>dist</code>文件，也就是没有通过实际的打包，为什么会这样呢？<br>因为<code>webpack-dev-serve</code>其实不会写入实际的<code>bundle.js</code>文件，而是将打包结果运行于内存之中，然后每次<code>webpack-dev-serve</code>接收到请求的时候都将此时内存中的打包结果返回给浏览器端即可。</p><p><strong><em>备注：如果<code>npm run dev</code>启动失败，有可能是<code>webpack</code> <code>webpack-cli</code> <code>webpack-dev-server</code> 的班班之间存在不兼容现象，将这三个卸载后(用 npm uninstall 卸载)，同时将这三个安装一下即可：<code>npm install webpack webpack-cli webpack-dev-serve</code></em></strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章中，对webpack有了一个基本的介绍： 处理模块之间的依赖并将其打包然后进行了webpack环境的安装和配置：环境、nodeJs、webpack及webpack-cli等。<br>之后，开始了第一个案例： hello world，然后通过webpack命令进行打包，打包到<code>./dist/bundle.js</code>。<br>最后进行了一波优化，由于直接输入命令过于繁琐，因此借助 npm 脚本或者 webpack.config 来维护 webpack 命令。此时由于频繁的打包也不符合开发条件，因此使用本地服务 <code>webpack-dev-server</code> 来启用一个可热加载的本地服务来处理打包资源和静态文件的请求。</p><p>下一篇将会纪录如何编写和使用模块，以及模块打包。敬请期待~</p><hr><p>本篇代码demo存于公众号【流眸】，欢迎扫码关注公众号，可在公众号下回复【2073】获取</p><p><img src="/images/qrcode.jpg" alt="流眸"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;最近学习了一些关于webpack的知识，在此做一些纪录。&lt;br&gt;作为前端开发者，我们以前在浏览器中运行 JavaScript ，会引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈；亦或使用一个包含所有项目代码的大型 &lt;code&gt;.js&lt;/code&gt; 文件，但是这会导致作用域、文件大小、可读性和可维护性方面的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://www.zhuxingmin.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>常用验证码之滑动验证码|图形验证码</title>
    <link href="https://www.zhuxingmin.com/2020/07/02/%E5%B8%B8%E7%94%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B9%8B%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81-%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>https://www.zhuxingmin.com/2020/07/02/常用验证码之滑动验证码-图形验证码/</id>
    <published>2020-07-02T09:09:39.000Z</published>
    <updated>2020-07-02T12:35:21.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这里是常用验证码的第三篇——<strong>滑动/图形验证码</strong>。<br>在前两篇已经实现了随机验证码和算术验证码，感兴趣的可以去看一下~</p><ul><li><a href="/2020/06/19/常用验证码之字符串验证码/" title="常用验证码之字符串验证码">常用验证码之字符串验证码</a></li><li><a href="/2020/06/25/常用验证码之算术验证码/" title="常用验证码之算数验证码">常用验证码之算数验证码</a></li></ul><p>除了这两种常用的验证码之外，现在最经常用到的还有几种，比如滑动验证，图片验证等，这一类的验证码一般借助于第三方来处理即可。比如图形验证码：</p><p><img src="/images/posts/check_img.png" alt></p><p>本篇纪录两种常用验证码的第三方调用方式：</p><ul><li>滑动验证码</li><li>图形验证码</li></ul><a id="more"></a><h2 id="滑动验证码"><a href="#滑动验证码" class="headerlink" title="滑动验证码"></a>滑动验证码</h2><h3 id="1-示例"><a href="#1-示例" class="headerlink" title="1. 示例"></a>1. 示例</h3><p><img src="/images/posts/check_slide.gif" alt></p><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><p>人机验证服务适用于登录、注册、活动、论坛、短信等高风险业务场景。</p><h3 id="3-实际意义"><a href="#3-实际意义" class="headerlink" title="3. 实际意义"></a>3. 实际意义</h3><p>通过对用户的行为数据、设备特征与网络数据构建多维度数据分析，使用业界先进的风控引擎结合“规则+AI”模型，对风险设备使用、模拟行为、暴力重放等攻击进行综合实时风控判决。</p><h3 id="4-使用流程"><a href="#4-使用流程" class="headerlink" title="4. 使用流程"></a>4. 使用流程</h3><ul><li><p>接入平台： 阿里云<br>搜索引擎搜索打开阿里云官网，注册并登录。</p></li><li><p>搜索栏搜索关键词：<code>验证码</code><br>然后在结果中点击进入【人机验证(验证码)】<br><img src="/images/posts/check_step_1.png" alt></p></li><li><p>点立即开通，即可获取自己的专属token,记录下即可~在代码配置中会用得到~</p></li><li>点击产品文档，各种配置在里面查看配置即可；</li><li>示例</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"checkId"</span> <span class="attr">class</span>=<span class="string">"nc-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!--No-Captcha渲染的位置，其中 class 中必须包含 nc-container--&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先得先引入资源如下</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span> src=<span class="string">"https://g.alicdn.com/sd/ncpc/nc.js?t=2015052012"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置即可</span></span><br><span class="line"><span class="keyword">var</span> nc_token = [<span class="string">"[自己的key值]"</span>, (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime(), <span class="built_in">Math</span>.random()].join(<span class="string">':'</span>);</span><br><span class="line"><span class="keyword">var</span> NC_Opt = </span><br><span class="line">&#123;</span><br><span class="line">    renderTo: <span class="string">"#checkId"</span>,</span><br><span class="line">    appkey: <span class="string">"[自己的key值]"</span>,</span><br><span class="line">    scene: <span class="string">"nc_login"</span>,</span><br><span class="line">    token: nc_token,</span><br><span class="line">    customWidth: <span class="number">300</span>,</span><br><span class="line">    trans:&#123;<span class="string">"key1"</span>:<span class="string">"code0"</span>&#125;,</span><br><span class="line">    elementID: [<span class="string">"usernameID"</span>],</span><br><span class="line">    is_Opt: <span class="number">0</span>,</span><br><span class="line">    language: <span class="string">"cn"</span>,</span><br><span class="line">    isEnabled: <span class="literal">true</span>,</span><br><span class="line">    timeout: <span class="number">3000</span>,</span><br><span class="line">    times:<span class="number">5</span>, </span><br><span class="line">    callback: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; </span><br><span class="line">        <span class="comment">// 验证后续操作</span></span><br><span class="line">        <span class="built_in">window</span>.console &amp;&amp; <span class="built_in">console</span>.log(nc_token)</span><br><span class="line">        <span class="built_in">window</span>.console &amp;&amp; <span class="built_in">console</span>.log(data.csessionid)</span><br><span class="line">        <span class="built_in">window</span>.console &amp;&amp; <span class="built_in">console</span>.log(data.sig)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> nc = <span class="keyword">new</span> noCaptcha(NC_Opt)</span><br><span class="line"><span class="comment">// 在此处配置相关文案信息</span></span><br><span class="line">nc.upLang(<span class="string">'cn'</span>, &#123;</span><br><span class="line">    _startTEXT: <span class="string">"请按住滑块，拖动到最右边"</span>,</span><br><span class="line">    _yesTEXT: <span class="string">"验证通过"</span>,</span><br><span class="line">    _error300: <span class="string">"哎呀，出错了，点击&lt;a href=\"javascript:__nc.reset()\"&gt;刷新&lt;/a&gt;再来一次"</span>,</span><br><span class="line">    _errorNetwork: <span class="string">"网络不给力，请&lt;a href=\"javascript:__nc.reset()\"&gt;点击刷新&lt;/a&gt;"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>打开后如案例所示，完成~<br><img src="/images/posts/check_slide.gif" alt></li></ul><hr><h2 id="图形验证码"><a href="#图形验证码" class="headerlink" title="图形验证码"></a>图形验证码</h2><h3 id="1-示例-1"><a href="#1-示例-1" class="headerlink" title="1. 示例"></a>1. 示例</h3><p><img src="/images/posts/check_img.gif" alt></p><h3 id="2-应用场景-1"><a href="#2-应用场景-1" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><ul><li>注册登录</li><li>活动秒杀</li><li>点赞发帖</li><li>数据保护</li></ul><h3 id="3-实际意义-1"><a href="#3-实际意义-1" class="headerlink" title="3. 实际意义"></a>3. 实际意义</h3><p>为网页、App、小程序开发者打造立体、全面的人机验证，最大程度地保护注册登录、活动秒杀、点赞发帖、数据保护等各大场景下的业务安全。</p><h3 id="4-使用流程-1"><a href="#4-使用流程-1" class="headerlink" title="4. 使用流程"></a>4. 使用流程</h3><ul><li><p>接入平台： 腾讯云<br>搜索引擎搜索打开腾讯云官网，注册并登录。</p></li><li><p>搜索栏搜索关键词：<code>验证码</code><br>然后在结果中点击进入【验证码】<br><img src="/images/posts/check_step_2.png" alt></p></li><li><p>点立即选购（体验即可，无需付费）或者在线体验</p></li><li>点击产品文档，各种配置在里面查看配置即可；<br>相比之下，腾讯云的基本使用方法则比阿里云简单的多，示例如下：</li><li>示例</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"TencentCaptcha"</span> <span class="attr">data-appid</span>=<span class="string">"2041127177"</span> <span class="attr">data-cbfn</span>=<span class="string">"callback"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>验证<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先得先引入资源如下</span></span><br><span class="line">&lt;script src=<span class="string">"https://ssl.captcha.qq.com/TCaptcha.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础使用</span></span><br><span class="line"><span class="built_in">window</span>.callback = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 添加自己相应配置即可</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">if</span> (res.ret === <span class="number">0</span>) &#123;</span><br><span class="line">        alert(res.ticket)   <span class="comment">// 票据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完成~<br><img src="/images/posts/check_img.png" alt></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这里是常用验证码的第三篇——&lt;strong&gt;滑动/图形验证码&lt;/strong&gt;。&lt;br&gt;在前两篇已经实现了随机验证码和算术验证码，感兴趣的可以去看一下~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/19/常用验证码之字符串验证码/&quot; title=&quot;常用验证码之字符串验证码&quot;&gt;常用验证码之字符串验证码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/25/常用验证码之算术验证码/&quot; title=&quot;常用验证码之算数验证码&quot;&gt;常用验证码之算数验证码&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了这两种常用的验证码之外，现在最经常用到的还有几种，比如滑动验证，图片验证等，这一类的验证码一般借助于第三方来处理即可。比如图形验证码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/check_img.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;本篇纪录两种常用验证码的第三方调用方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滑动验证码&lt;/li&gt;
&lt;li&gt;图形验证码&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="https://www.zhuxingmin.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="验证码" scheme="https://www.zhuxingmin.com/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>常用验证码之算数验证码</title>
    <link href="https://www.zhuxingmin.com/2020/06/25/%E5%B8%B8%E7%94%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B9%8B%E7%AE%97%E6%9C%AF%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>https://www.zhuxingmin.com/2020/06/25/常用验证码之算术验证码/</id>
    <published>2020-06-25T06:39:50.000Z</published>
    <updated>2020-07-02T09:36:27.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这里是常用验证码的第二篇——<strong>算术验证码</strong>。<br>在上一篇已经实现了<a href="/2020/06/19/常用验证码之字符串验证码/" title="常用验证码之字符串验证码">常用验证码之字符串验证码</a>，感兴趣的可以去看一下~<br>接下来要实现的就是字符串验证码了，先看下效果：</p><p><img src="/images/posts/check_compute.gif" alt></p><a id="more"></a><p><strong>本篇记录纯前端写算术验证码。</strong></p><h2 id="实现：算术验证码"><a href="#实现：算术验证码" class="headerlink" title="实现：算术验证码"></a>实现：算术验证码</h2><p>一般来讲，字符串、算数、gif、短信语音等验证码放在后端实现，但本着技术无界限的原则，前端依然是能照葫芦画瓢给实现出来的。<br>本次要实现的效果如下：</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/images/posts/check_compute.png" alt></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>验证码实现步骤：</p><ul><li>canvas画布</li><li>生成随机100以内的简单整数四则运算</li><li>随机颜色</li><li>背景色（可固定色）</li><li>噪音线设置</li><li>绘制验证码</li></ul><p>其他一些基础内容也包含其中，如点击验证码刷新、点击下一步验证等操作。</p><h3 id="步骤实现："><a href="#步骤实现：" class="headerlink" title="步骤实现："></a>步骤实现：</h3><p><strong><em>注：本案例基于vue操作，UI使用element完成，原生js同样道理</em></strong></p><h4 id="1-canvas画布"><a href="#1-canvas画布" class="headerlink" title="1. canvas画布"></a>1. canvas画布</h4><p><strong>html</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输入框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"inputCode"</span> <span class="attr">placeholder</span>=<span class="string">"请输入右侧图案的值"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- canvas画布：验证码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">ref</span>=<span class="string">"checkCode"</span> @<span class="attr">click</span>=<span class="string">"getCode"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"checkMe"</span>&gt;</span>下一步<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要的数据</span></span><br><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        inputCode: <span class="string">''</span>,  <span class="comment">// 输入的值</span></span><br><span class="line">        checkCode: <span class="string">''</span>,  <span class="comment">// 图片验证码的值</span></span><br><span class="line">        expressValue: <span class="string">''</span>,  <span class="comment">// 表达式的值</span></span><br><span class="line">        <span class="comment">// canvas各种设置</span></span><br><span class="line">        cvs: &#123;</span><br><span class="line">            w: <span class="number">100</span>, <span class="comment">// 给出默认宽度  宽度会在图片绘制时根据长度更改</span></span><br><span class="line">            h: <span class="number">40</span>,  <span class="comment">// 高 与input保持一致</span></span><br><span class="line">            fontSize: <span class="number">24</span>,   <span class="comment">// 字体大小</span></span><br><span class="line">            str: <span class="string">'+-*'</span>,  <span class="comment">// 符号生成范围</span></span><br><span class="line">            line: <span class="number">3</span> <span class="comment">// 噪音线个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-生成随机表达式"><a href="#2-生成随机表达式" class="headerlink" title="2. 生成随机表达式"></a>2. 生成随机表达式</h4><ul><li>写一个随机整数生成器，在各个环节都会用到</li><li>生成随机字符串，长度是在<code>data</code>里面<code>cvs</code>中对应长度<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机整数生成器，范围[0, max)</span></span><br><span class="line">rInt(max) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">100000</span> % max);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机表达式</span></span><br><span class="line">rCode() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">this</span>.rInt(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">this</span>.rInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> op = <span class="keyword">this</span>.cvs.str.charAt(<span class="keyword">this</span>.rInt(<span class="keyword">this</span>.cvs.str.length));</span><br><span class="line">    <span class="comment">// 表达式</span></span><br><span class="line">    <span class="keyword">let</span> code = <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;op&#125;</span><span class="subst">$&#123;b&#125;</span>=`</span>;</span><br><span class="line">    <span class="keyword">this</span>.checkCode = code;</span><br><span class="line">    <span class="comment">// 表达式的值</span></span><br><span class="line">    <span class="keyword">this</span>.expressValue = <span class="built_in">eval</span>(code.substr(<span class="number">0</span>, code.length - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-生成随机颜色"><a href="#3-生成随机颜色" class="headerlink" title="3. 生成随机颜色"></a>3. 生成随机颜色</h4><ul><li>rgba格式</li><li>a：透明度，取值为0.5-1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 生成随机颜色 rgba格式</span></span><br><span class="line">rColor() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = ((<span class="built_in">Math</span>.random()*<span class="number">5</span> + <span class="number">5</span>) / <span class="number">10</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`rgba(<span class="subst">$&#123;<span class="keyword">this</span>.rInt(<span class="number">256</span>)&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.rInt(<span class="number">256</span>)&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.rInt(<span class="number">256</span>)&#125;</span>, <span class="subst">$&#123;a&#125;</span>)`</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-开始绘制"><a href="#4-开始绘制" class="headerlink" title="4. 开始绘制"></a>4. 开始绘制</h4><ul><li>方法接收一个dom对象</li><li>判断浏览器对canvas支持程度</li><li>取随机字表达式</li><li>设置canvas宽高大小</li><li>绘制</li></ul><p>具体过程如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证码图片绘制</span></span><br><span class="line">drawCode(domCvs) &#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 随机表达式</span></span><br><span class="line">    <span class="keyword">let</span> checkCode = <span class="keyword">this</span>.rCode();</span><br><span class="line">    <span class="comment">// 宽设置</span></span><br><span class="line">    <span class="keyword">this</span>.cvs.w = <span class="number">10</span> + <span class="keyword">this</span>.cvs.fontSize * <span class="keyword">this</span>.checkCode.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否支持canvas</span></span><br><span class="line">    <span class="keyword">if</span> (domCvs !== <span class="literal">null</span> &amp;&amp; domCvs.getContext &amp;&amp; domCvs.getContext(<span class="string">'2d'</span>)) &#123;</span><br><span class="line">        <span class="comment">// 设置显示区域大小</span></span><br><span class="line">        domCvs.style.width = _this.cvs.w;</span><br><span class="line">        <span class="comment">// 设置画板宽高</span></span><br><span class="line">        domCvs.setAttribute(<span class="string">'width'</span>, _this.cvs.w);</span><br><span class="line">        domCvs.setAttribute(<span class="string">'height'</span>, _this.cvs.h);</span><br><span class="line">        <span class="comment">// 画笔</span></span><br><span class="line">        <span class="keyword">let</span> pen = domCvs.getContext(<span class="string">'2d'</span>);</span><br><span class="line">        <span class="comment">// 背景: 颜色  区域</span></span><br><span class="line">        pen.fillStyle = <span class="string">'#eee'</span>;</span><br><span class="line">        pen.fillRect(<span class="number">0</span>, <span class="number">0</span>, _this.cvs.w, _this.cvs.h);</span><br><span class="line">        <span class="comment">// 水平线位置</span></span><br><span class="line">        pen.textBaseline = <span class="string">'middle'</span>;   <span class="comment">// top middle bottom</span></span><br><span class="line">        <span class="comment">// 内容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _this.checkCode.length; i++) &#123;</span><br><span class="line">            pen.fillStyle = _this.rColor(); <span class="comment">// 随机颜色</span></span><br><span class="line">            pen.font = <span class="string">`bold <span class="subst">$&#123;_this.cvs.fontSize&#125;</span>px 微软雅黑`</span>; <span class="comment">// 字体设置</span></span><br><span class="line">            <span class="comment">// 字符绘制: (字符, X坐标, Y坐标)</span></span><br><span class="line">            pen.fillText(checkCode.charAt(i), <span class="number">10</span> + _this.cvs.fontSize * i, <span class="number">17</span> + _this.rInt(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 噪音线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _this.cvs.line; i++) &#123;</span><br><span class="line">            <span class="comment">// 起点</span></span><br><span class="line">            pen.moveTo(_this.rInt(_this.cvs.w) / <span class="number">2</span>, _this.rInt(_this.cvs.h));</span><br><span class="line">            <span class="comment">// 终点</span></span><br><span class="line">            pen.lineTo(_this.rInt(_this.cvs.w), _this.rInt(_this.cvs.h));</span><br><span class="line">            <span class="comment">// 颜色</span></span><br><span class="line">            pen.strokeStyle = _this.rColor();</span><br><span class="line">            <span class="comment">// 粗细</span></span><br><span class="line">            pen.lineWidth = <span class="string">'2'</span>;</span><br><span class="line">            <span class="comment">// 绘制</span></span><br><span class="line">            pen.stroke();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message.error(<span class="string">'不支持验证码格式，请升级或更换浏览器重试'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h4 id="5-绑定canvas的dom元素"><a href="#5-绑定canvas的dom元素" class="headerlink" title="5. 绑定canvas的dom元素"></a>5. 绑定canvas的dom元素</h4><p><strong>html</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">class</span>=<span class="string">"codeCanvas"</span> <span class="attr">ref</span>=<span class="string">"checkCode"</span> @<span class="attr">click</span>=<span class="string">"getCode"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>js：getCode方法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue的话可直接用$refs取值，不用vue的话可绑定id然后通过document处理</span></span><br><span class="line"><span class="keyword">let</span> domCvs = <span class="keyword">this</span>.$refs.checkCode;</span><br><span class="line"><span class="keyword">this</span>.drawCode(domCvs);</span><br></pre></td></tr></table></figure></p><h4 id="6-完成"><a href="#6-完成" class="headerlink" title="6. 完成~"></a>6. 完成~</h4><ul><li>在页面初始化的时候，也来一个验证码</li><li><p>点击下一步， 验证<code>data</code>中<code>inputCode</code>和<code>expressValue</code>的值是否一样即可。<strong>注意，直接使用eval验证即可</strong></p></li><li><p>页面初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化先搞一个验证码~点击canvas的时候重新执行getCode()</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="comment">// 获取验证码图</span></span><br><span class="line">    <span class="keyword">this</span>.getCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">checkMe() &#123;</span><br><span class="line">    <span class="comment">// 空、 错误、 正确 三个判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.inputCode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">eval</span>(<span class="keyword">this</span>.inputCode) === <span class="built_in">eval</span>(<span class="keyword">this</span>.expressValue)) &#123;</span><br><span class="line">            <span class="comment">// 验证成功要做的事</span></span><br><span class="line">            <span class="keyword">this</span>.$message.success(<span class="string">'验证成功'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 验证码有误</span></span><br><span class="line">            <span class="keyword">this</span>.$message.warning(<span class="string">'错误，请重新输入'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 输入为空</span></span><br><span class="line">        <span class="keyword">this</span>.$message.warning(<span class="string">'请输入右侧结果'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>ok，常用的简单算术验证码大致就是这样子了~</p><p>本篇案例源码可关注公众号【流眸】回复【20630】获取哟~<br><img src="/images/qrcode.jpg" alt="流眸"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这里是常用验证码的第二篇——&lt;strong&gt;算术验证码&lt;/strong&gt;。&lt;br&gt;在上一篇已经实现了&lt;a href=&quot;/2020/06/19/常用验证码之字符串验证码/&quot; title=&quot;常用验证码之字符串验证码&quot;&gt;常用验证码之字符串验证码&lt;/a&gt;，感兴趣的可以去看一下~&lt;br&gt;接下来要实现的就是字符串验证码了，先看下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/check_compute.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="https://www.zhuxingmin.com/tags/vue/"/>
    
      <category term="canvas" scheme="https://www.zhuxingmin.com/tags/canvas/"/>
    
      <category term="验证码" scheme="https://www.zhuxingmin.com/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>常用验证码之字符串验证码</title>
    <link href="https://www.zhuxingmin.com/2020/06/19/%E5%B8%B8%E7%94%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>https://www.zhuxingmin.com/2020/06/19/常用验证码之字符串验证码/</id>
    <published>2020-06-19T08:25:09.000Z</published>
    <updated>2020-06-30T07:06:37.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><strong>验证码</strong> 这个玩意，无论是开发者还是用户都十分熟悉：</p><ul><li>注册？ 请输入验证码…</li><li>登录？ 请输入验证码…</li><li>修改密码？ 请输入验证码…</li><li>删除？ 请输入验证码…</li><li>……</li></ul><p><strong>总之，各类敏感操作，请输入验证码！</strong></p><p><img src="/images/posts/check_text.png" alt></p><p>这么多场景中用到验证码，它到底有什么用？作为前端开发者，如何去实现呢？<br>接下来步入正题。</p><a id="more"></a><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><ul><li>是一种区分用户是计算机还是人的公共全自动程序。区分用户是真人还是程序，防止程序频繁访问服务器占用过多的资源。</li></ul><p><strong>作用：</strong></p><ul><li>防止恶意破解密码、刷票、论坛灌水等；</li><li>有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li><li>敏感操作前的提示</li><li>防止恶意注册</li></ul><p><strong>验证码表现方式：</strong></p><ul><li>随机字符串验证码</li><li>算数验证码</li><li>Gif动画验证码</li><li>滑动验证码</li><li>点选验证码</li><li>短信验证码</li><li>手机语音验证码</li></ul><p>接下来会使用纯前端方式实现其中的一些表现，如<code>随机字符串验证码</code>、<code>算数验证码</code>、<code>滑动验证码</code>等。</p><p><strong>本篇记录随机字符串验证码。</strong></p><h2 id="随机字符串验证码"><a href="#随机字符串验证码" class="headerlink" title="随机字符串验证码"></a>随机字符串验证码</h2><p>一般来讲，字符串、算数、gif、短信语音等验证码放在后端实现，但本着技术无界限的原则，前端依然是能照葫芦画瓢给实现出来的。<br>本次要实现的效果如下：</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/images/posts/check_text.gif" alt></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>验证码实现步骤：</p><ul><li>canvas画布</li><li>生成随机字符串</li><li>随机颜色</li><li>背景色（可固定色）</li><li>噪音线设置</li><li>绘制验证码</li></ul><p>其他一些基础内容也包含其中，如点击验证码刷新、点击下一步验证等操作。</p><h3 id="步骤实现："><a href="#步骤实现：" class="headerlink" title="步骤实现："></a>步骤实现：</h3><p><strong><em>注：本案例基于vue操作，UI使用element完成，原生js同样道理</em></strong></p><h4 id="1-canvas画布"><a href="#1-canvas画布" class="headerlink" title="1. canvas画布"></a>1. canvas画布</h4><p><strong>html</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输入框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"inputCode"</span> <span class="attr">placeholder</span>=<span class="string">"请输入验证码，不区分大小写"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- canvas画布：验证码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">ref</span>=<span class="string">"checkCode"</span> @<span class="attr">click</span>=<span class="string">"getCode"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"checkMe"</span>&gt;</span>下一步<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要的数据</span></span><br><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        inputCode: <span class="string">''</span>,  <span class="comment">// 输入的值</span></span><br><span class="line">        checkCode: <span class="string">''</span>,  <span class="comment">// 图片验证码的值</span></span><br><span class="line">        <span class="comment">// canvas各种设置</span></span><br><span class="line">        cvs: &#123;</span><br><span class="line">            w: <span class="number">100</span>, <span class="comment">// 给出默认宽度  宽度会在图片绘制时根据长度更改</span></span><br><span class="line">            h: <span class="number">40</span>,  <span class="comment">// 高 与input保持一致</span></span><br><span class="line">            fontSize: <span class="number">24</span>,   <span class="comment">// 字体大小</span></span><br><span class="line">            <span class="comment">// 字符串生成范围</span></span><br><span class="line">            str: <span class="string">'1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPLKJHGFDSAZXCVBNM'</span>,  </span><br><span class="line">            len: <span class="number">4</span>, <span class="comment">// 字符串长度 </span></span><br><span class="line">            line: <span class="number">3</span> <span class="comment">// 噪音线个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-生成随机字符串"><a href="#2-生成随机字符串" class="headerlink" title="2. 生成随机字符串"></a>2. 生成随机字符串</h4><ul><li>写一个随机整数生成器，在各个环节都会用到</li><li>生成随机字符串，长度是在<code>data</code>里面<code>cvs</code>中对应长度<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机整数生成器，范围[0, max)</span></span><br><span class="line">rInt(max) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">100000</span> % max);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机字符串</span></span><br><span class="line">rCode() &#123;</span><br><span class="line">    <span class="keyword">let</span> code = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">let</span> len = <span class="keyword">this</span>.cvs.len;</span><br><span class="line">    <span class="keyword">let</span> strLen = <span class="keyword">this</span>.cvs.str.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        code += <span class="keyword">this</span>.cvs.str.charAt(<span class="keyword">this</span>.rInt(strLen));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.checkCode = code;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-生成随机颜色"><a href="#3-生成随机颜色" class="headerlink" title="3. 生成随机颜色"></a>3. 生成随机颜色</h4><ul><li>rgba格式</li><li>a：透明度，取值为0.5-1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 生成随机颜色 rgba格式</span></span><br><span class="line">rColor() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = ((<span class="built_in">Math</span>.random()*<span class="number">5</span> + <span class="number">5</span>) / <span class="number">10</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`rgba(<span class="subst">$&#123;<span class="keyword">this</span>.rInt(<span class="number">256</span>)&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.rInt(<span class="number">256</span>)&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.rInt(<span class="number">256</span>)&#125;</span>, <span class="subst">$&#123;a&#125;</span>)`</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-开始绘制"><a href="#4-开始绘制" class="headerlink" title="4. 开始绘制"></a>4. 开始绘制</h4><ul><li>方法接收一个dom对象</li><li>判断浏览器对canvas支持程度</li><li>取随机字符串</li><li>设置canvas宽高大小</li><li>绘制</li></ul><p>具体过程如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证码图片绘制</span></span><br><span class="line">drawCode(domCvs) &#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 随机字符串</span></span><br><span class="line">    <span class="keyword">let</span> checkCode = <span class="keyword">this</span>.rCode();</span><br><span class="line">    <span class="comment">// 宽设置</span></span><br><span class="line">    <span class="keyword">this</span>.cvs.w = <span class="number">10</span> + <span class="keyword">this</span>.cvs.fontSize * <span class="keyword">this</span>.cvs.len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否支持canvas</span></span><br><span class="line">    <span class="keyword">if</span>(domCvs !== <span class="literal">null</span> &amp;&amp; domCvs.getContext &amp;&amp; domCvs.getContext(<span class="string">'2d'</span>))&#123;</span><br><span class="line">        <span class="comment">// 设置显示区域大小</span></span><br><span class="line">        domCvs.style.width = _this.cvs.w;</span><br><span class="line">        <span class="comment">// 设置画板宽高</span></span><br><span class="line">        domCvs.setAttribute(<span class="string">'width'</span>, _this.cvs.w);</span><br><span class="line">        domCvs.setAttribute(<span class="string">'height'</span>, _this.cvs.h);</span><br><span class="line">        <span class="comment">// 画笔</span></span><br><span class="line">        <span class="keyword">let</span> pen = domCvs.getContext(<span class="string">'2d'</span>);</span><br><span class="line">        <span class="comment">// 背景: 颜色  区域</span></span><br><span class="line">        pen.fillStyle = <span class="string">'#eee'</span>;</span><br><span class="line">        pen.fillRect(<span class="number">0</span>, <span class="number">0</span>, _this.cvs.w, _this.cvs.h);</span><br><span class="line">        <span class="comment">// 水平线位置</span></span><br><span class="line">        pen.textBaseline = <span class="string">'middle'</span>;   <span class="comment">// top middle bottom</span></span><br><span class="line">        <span class="comment">// 内容</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _this.cvs.len; i ++) &#123;</span><br><span class="line">            pen.fillStyle = _this.rColor(); <span class="comment">// 随机颜色</span></span><br><span class="line">            pen.font = <span class="string">`bold <span class="subst">$&#123;_this.cvs.fontSize&#125;</span>px 微软雅黑`</span>; <span class="comment">// 字体设置</span></span><br><span class="line">            <span class="comment">// 字符绘制: (字符, X坐标, Y坐标)</span></span><br><span class="line">            pen.fillText(checkCode.charAt(i), <span class="number">10</span> + _this.cvs.fontSize * i, <span class="number">17</span> + _this.rInt(<span class="number">10</span>));   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 噪音线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _this.cvs.line; i ++) &#123;</span><br><span class="line">            <span class="comment">// 起点</span></span><br><span class="line">            pen.moveTo(_this.rInt(_this.cvs.w) / <span class="number">2</span>, _this.rInt(_this.cvs.h));</span><br><span class="line">            <span class="comment">// 终点</span></span><br><span class="line">            pen.lineTo(_this.rInt(_this.cvs.w), _this.rInt(_this.cvs.h));</span><br><span class="line">            <span class="comment">// 颜色</span></span><br><span class="line">            pen.strokeStyle = _this.rColor();</span><br><span class="line">            <span class="comment">// 粗细</span></span><br><span class="line">            pen.lineWidth = <span class="string">'2'</span>;</span><br><span class="line">            <span class="comment">// 绘制</span></span><br><span class="line">            pen.stroke();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message.error(<span class="string">'不支持验证码格式，请升级或更换浏览器重试'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h4 id="5-绑定canvas的dom元素"><a href="#5-绑定canvas的dom元素" class="headerlink" title="5. 绑定canvas的dom元素"></a>5. 绑定canvas的dom元素</h4><p><strong>html</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">class</span>=<span class="string">"codeCanvas"</span> <span class="attr">ref</span>=<span class="string">"checkCode"</span> @<span class="attr">click</span>=<span class="string">"getCode"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>js：getCode方法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue的话可直接用$refs取值，不用vue的话可绑定id然后通过document处理</span></span><br><span class="line"><span class="keyword">let</span> domCvs = <span class="keyword">this</span>.$refs.checkCode;</span><br><span class="line"><span class="keyword">this</span>.drawCode(domCvs);</span><br></pre></td></tr></table></figure></p><h4 id="6-完成"><a href="#6-完成" class="headerlink" title="6. 完成~"></a>6. 完成~</h4><ul><li>在页面初始化的时候，也来一个验证码</li><li>点击下一步， 验证<code>data</code>中<code>inputCode</code>和<code>checkCode</code>的值是否一样即可。<strong>注意，要都换成小写<code>toLowerCase()</code>或者大写去处理~</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化先搞一个验证码~点击canvas的时候重新执行getCode()</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="comment">// 获取验证码图</span></span><br><span class="line">    <span class="keyword">this</span>.getCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>搞定，收工，最终效果如效果图所示~<br>根据本篇，那算术验证码的效果已然是呼之欲出了……下一篇更新！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;验证码&lt;/strong&gt; 这个玩意，无论是开发者还是用户都十分熟悉：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册？ 请输入验证码…&lt;/li&gt;
&lt;li&gt;登录？ 请输入验证码…&lt;/li&gt;
&lt;li&gt;修改密码？ 请输入验证码…&lt;/li&gt;
&lt;li&gt;删除？ 请输入验证码…&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总之，各类敏感操作，请输入验证码！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/check_text.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这么多场景中用到验证码，它到底有什么用？作为前端开发者，如何去实现呢？&lt;br&gt;接下来步入正题。&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="https://www.zhuxingmin.com/tags/vue/"/>
    
      <category term="canvas" scheme="https://www.zhuxingmin.com/tags/canvas/"/>
    
      <category term="验证码" scheme="https://www.zhuxingmin.com/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>docker-nginx部署web项目</title>
    <link href="https://www.zhuxingmin.com/2020/06/16/docker-nginx%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AE/"/>
    <id>https://www.zhuxingmin.com/2020/06/16/docker-nginx部署web项目/</id>
    <published>2020-06-16T02:42:24.000Z</published>
    <updated>2020-06-16T02:46:29.960Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>作为web端开发er，几乎从未接触过后端及服务端相关知识。但有些场景下又需要将自己的一些东西从公网（域名）上展示出来，比如自己的可开源项目、博客、简历、demo等。有时候我们可以麻烦后台或者运维同事来帮我们搞一搞，但终究授之以鱼不如授之以渔，在同事的帮助下，我也成功的通过一条简单的途径实现了本地文件上传至服务器并从域名访问。本片博客记录下实现过程。<br>本实现途径是在linux服务器中安装docker，然后启用docker-nginx代理实现的，希望对与我面对同样困境的小白有所帮助。<br>第一次接触服务端知识，有错敬请指教，感谢！<br>那么，开始吧~</p><a id="more"></a><h3 id="0-准备"><a href="#0-准备" class="headerlink" title="0. 准备"></a>0. 准备</h3><ul><li>云服务器——CentOS 7.x，低配置即可，如[1核 1GB 1Mbps]</li><li>域名——已备案</li><li>终端远程工具——如：xshell、FinalShell等</li></ul><p><strong><em>提示：以下命令行内容均在服务器中完成~自行通过终端远程工具连接自己的服务器</em></strong></p><hr><h3 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. 安装docker</h3><h4 id="1-1-卸载旧版本"><a href="#1-1-卸载旧版本" class="headerlink" title="1.1 卸载旧版本"></a>1.1 卸载旧版本</h4><p><strong><em>如已安装想重新安装，或者是旧版本，则执行。<br>如已是新版，跳过本步。</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></p><h4 id="1-2-使用官方脚本自动安装"><a href="#1-2-使用官方脚本自动安装" class="headerlink" title="1.2 使用官方脚本自动安装"></a>1.2 使用官方脚本自动安装</h4><p><strong><em>以下两种方式任选其一</em></strong></p><ul><li>命令：<br><code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></li><li>国内 daocloud 命令<br><code>curl -sSL https://get.daocloud.io/docker | sh</code></li></ul><h4 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3 启动docker"></a>1.3 启动docker</h4><p><code>$ sudo systemctl start docker</code></p><hr><h3 id="2-Docker-安装-Nginx"><a href="#2-Docker-安装-Nginx" class="headerlink" title="2. Docker 安装 Nginx"></a>2. Docker 安装 Nginx</h3><p>Nginx 是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP/POP3/SMTP 服务 。<br>docker内安装nginx,作为web服务器来提供我们所需要的的web服务。</p><h4 id="2-1-docker查看nginx可用版本"><a href="#2-1-docker查看nginx可用版本" class="headerlink" title="2.1 docker查看nginx可用版本"></a>2.1 docker查看nginx可用版本</h4><ul><li><code>docker search nginx</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_10_centos zxm]# docker search nginx</span><br><span class="line">NAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">nginx                              Official build of Nginx.                        13333               [OK]                </span><br><span class="line">jwilder/nginx-proxy                Automated Nginx reverse proxy for docker con…   1822                                    [OK]</span><br><span class="line">richarvey/nginx-php-fpm            Container running Nginx + PHP-FPM capable of…   777                                     [OK]</span><br><span class="line">linuxserver/nginx                  An Nginx container, brought to you by LinuxS…   115                                     </span><br><span class="line">bitnami/nginx                      Bitnami nginx Docker Image                      84                                      [OK]</span><br><span class="line">tiangolo/nginx-rtmp                Docker image with Nginx using the nginx-rtmp…   75                                      [OK]</span><br><span class="line">alfg/nginx-rtmp                    NGINX, nginx-rtmp-module and FFmpeg from sou…   66                                      [OK]</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-安装最新的nginx镜像"><a href="#2-2-安装最新的nginx镜像" class="headerlink" title="2.2 安装最新的nginx镜像"></a>2.2 安装最新的nginx镜像</h4><p><code>$ docker pull nginx:latest</code></p><h4 id="2-3-查看本地镜像"><a href="#2-3-查看本地镜像" class="headerlink" title="2.3 查看本地镜像"></a>2.3 查看本地镜像</h4><p>运行命令查看是否安装成功：<code>$ docker images</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              2622e6cca7eb        5 days ago          132MB</span><br></pre></td></tr></table></figure></p><p>如上，有nginx，成功。</p><hr><h3 id="3-创建docker-nginx实例"><a href="#3-创建docker-nginx实例" class="headerlink" title="3. 创建docker-nginx实例"></a>3. 创建docker-nginx实例</h3><p><code>$ docker run --name [name] -p 8080:80 -d nginx</code></p><blockquote><ul><li>[name]—— 容器名称</li><li>[-p 8080:80]—— 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口</li><li>[-d nginx]—— 设置容器在在后台一直运行</li></ul></blockquote><hr><h3 id="4-运行容器"><a href="#4-运行容器" class="headerlink" title="4. 运行容器"></a>4. 运行容器</h3><p>创建容器后默认是运行状态。可以通过<code>$ docker ps</code>命令查看运行中的容器，通过<code>$ docker ps -a</code>查看docker的所有容器。<br>如，我创建的容器名为<code>zxm-nginx-test</code>，可以在下面容器列表中查看到容器的运行状态及容器信息（id、name等）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_10_centos zxm]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">daad54bac361        nginx               &quot;/docker-entrypoint.…&quot;   41 hours ago        Up About an hour    0.0.0.0:8080-&gt;80/tcp   zxm-nginx-test</span><br></pre></td></tr></table></figure></p><p>如果容器未启动，则可以通过<code>$ docker start [容器name或id]</code>来启动容器。</p><hr><h3 id="5-测试访问"><a href="#5-测试访问" class="headerlink" title="5. 测试访问"></a>5. 测试访问</h3><p>运行容器启动之后，可以通过服务器公网ip地址测试访问。<br>如：<code>http://[ip]:8080/</code>。<br>出现页面提示如下，表示成功运行。<br><img src="/images/posts/serve_nginx.png" alt></p><hr><h3 id="6-上传文件到服务器"><a href="#6-上传文件到服务器" class="headerlink" title="6. 上传文件到服务器"></a>6. 上传文件到服务器</h3><p>上传本地文件/文件夹（我们的web项目，静态资源）到自己的服务器任意位置。<br>比如我在root下创建了文件夹zxm，通过工具直接将本地文件<code>Loading.html</code>拖入其中。</p><p><img src="/images/posts/serve_upload.gif" alt><br>然后本地资源就上传到了服务器中~<br><img src="/images/posts/serve_file.jpg" alt></p><h3 id="7-拷贝文件到docker-nginx容器"><a href="#7-拷贝文件到docker-nginx容器" class="headerlink" title="7. 拷贝文件到docker-nginx容器"></a>7. 拷贝文件到docker-nginx容器</h3><p>首先，我们已经将需要的项目（资源）从本地上传到了服务器上；<br>然后我们需要做的则是从服务器上的项目资源从目前所在的地方拷贝到docker-nginx容器内，那么我们就需要知道三个东西：</p><ol><li>目标路径</li><li>项目所在路径</li><li>docker 拷贝命令</li></ol><p>接下来，我们一步一步来。</p><h4 id="7-1-查找docker-nginx容器目标文件路径"><a href="#7-1-查找docker-nginx容器目标文件路径" class="headerlink" title="7.1 查找docker-nginx容器目标文件路径"></a>7.1 查找docker-nginx容器目标文件路径</h4><ul><li><p>进入容器： <code>docker exec -it daad54bac361 bash</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it daad54bac361 bash</span><br></pre></td></tr></table></figure></li><li><p>目录： <code>ls</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@daad54bac361:/# ls </span><br><span class="line">bin  boot  dev  docker-entrypoint.d  docker-entrypoint.sh  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure></li><li><p>查找配置文件： <code>cd etc/nginx/conf.d/</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@daad54bac361:/# cd etc/nginx/conf.d/</span><br><span class="line">root@daad54bac361:/etc/nginx/conf.d# ls</span><br><span class="line">default.conf</span><br></pre></td></tr></table></figure></li><li><p>查看配置文件： <code>cat default.conf</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@daad54bac361:/etc/nginx/conf.d# cat default.conf </span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span>  [::]:<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复制（记录）文件中<code>server&gt;location&gt;root</code><br>如：<code>/usr/share/nginx/html</code><br>这个目录则是容器的目标目录，接下来则需将其他位置的资源通过docker命令拷贝到该文件目录下。</p></li><li><p>退出容器： <code>exit</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@daad54bac361:/etc/nginx/conf.d# exit</span><br><span class="line">e xit</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-2-拷贝"><a href="#7-2-拷贝" class="headerlink" title="7.2 拷贝"></a>7.2 拷贝</h4><ul><li>先回到刚才本地上传文件至服务器步骤的文件所在服务器位置中</li><li>cd到该目录下</li><li>docker命令拷贝到容器中<br><code>docker cp [源文件目录] [容器id]:[目标目录]</code><br>例如，在我的服务器中，想要将<code>Loading.html</code>传入到容器中，则是：<br><code>docker cp Loading.html daad54bac361:/usr/share/nginx/html/</code></li></ul><h4 id="7-3-完成，访问"><a href="#7-3-完成，访问" class="headerlink" title="7.3 完成，访问"></a>7.3 完成，访问</h4><p>浏览器中输入<code>ip:8080/Loading.html</code>，正常访问到页面，收工~~<br><img src="/images/posts/serveLoading.gif" alt></p><hr><h3 id="8-nginx域名映射配置"><a href="#8-nginx域名映射配置" class="headerlink" title="8. nginx域名映射配置"></a>8. nginx域名映射配置</h3><p>以上内容我们完成了基本的服务器项目部署，也就是从公网可以访问自己的项目啦~但是我们不能一直使用公网来访问，不够安全，且不够优雅！那么我们怎么使用域名来访问自己的项目呢？<br>接下来我们操作一下域名映射。</p><h4 id="8-1-docker内安装vim工具"><a href="#8-1-docker内安装vim工具" class="headerlink" title="8.1 docker内安装vim工具"></a>8.1 docker内安装vim工具</h4><ul><li>进入docker容器<br><code>docker exec -it [容器id或者name] bash</code></li><li>docker内安装vim<br>依次执行以下命令：<br><code>apt-get update</code><br><code>apt-get install vim</code></li></ul><h4 id="8-2-配置default-conf文件"><a href="#8-2-配置default-conf文件" class="headerlink" title="8.2 配置default.conf文件"></a>8.2 配置<code>default.conf</code>文件</h4><ul><li><p>cd到配置文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@daad54bac361:/# cd etc/nginx/conf.d/ </span><br><span class="line">root@daad54bac361:/etc/nginx/conf.d# ls</span><br><span class="line">default.conf</span><br></pre></td></tr></table></figure></li><li><p>编辑default.conf文件:<br><code>vim default.conf</code></p></li><li><p>修改如下：<br>将<code>server&gt;server_name</code>的localhost改成自己的域名地址，如我的是<code>www.zhuxingmin.com</code>，但我可能会设置二级域名等，将<code>www</code>改成<code>*</code>。则配置如下：<code>server_name  *.zhuxingmin.com;</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span>  [::]:<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  <span class="regexp">*.zhuxingmin.com</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>退出容器<br><code>exit</code></p></li></ul><h4 id="8-3-重启docker-nginx容器"><a href="#8-3-重启docker-nginx容器" class="headerlink" title="8.3 重启docker-nginx容器"></a>8.3 重启docker-nginx容器</h4><p><code>docker restart [容器name或id]</code><br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_10_centos zxm]# docker restart zxm-nginx-test</span><br><span class="line">zxm-nginx-test</span><br><span class="line">[root@VM_0_10_centos zxm]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">daad54bac361        nginx               &quot;/docker-entrypoint.…&quot;   40 hours ago        Up 5 seconds        0.0.0.0:8080-&gt;80/tcp   zxm-nginx-test</span><br></pre></td></tr></table></figure></p><h3 id="9-域名解析"><a href="#9-域名解析" class="headerlink" title="9. 域名解析"></a>9. 域名解析</h3><ul><li>前提： 域名已备案</li><li>打开域名解析</li><li>添加记录（解析）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">记录类型:   A</span><br><span class="line">主机记录:   test.zhuxingmin.com</span><br><span class="line">解析线路:   默认</span><br><span class="line">记录值：    服务器公网ip</span><br><span class="line">TTL:       10分钟</span><br></pre></td></tr></table></figure></li></ul><p>然后，打开浏览器，输入自己配置的域名，即可访问到docker-nginx容器中的项目啦~~</p><p><img src="/images/posts/serve_url.gif" alt></p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;作为web端开发er，几乎从未接触过后端及服务端相关知识。但有些场景下又需要将自己的一些东西从公网（域名）上展示出来，比如自己的可开源项目、博客、简历、demo等。有时候我们可以麻烦后台或者运维同事来帮我们搞一搞，但终究授之以鱼不如授之以渔，在同事的帮助下，我也成功的通过一条简单的途径实现了本地文件上传至服务器并从域名访问。本片博客记录下实现过程。&lt;br&gt;本实现途径是在linux服务器中安装docker，然后启用docker-nginx代理实现的，希望对与我面对同样困境的小白有所帮助。&lt;br&gt;第一次接触服务端知识，有错敬请指教，感谢！&lt;br&gt;那么，开始吧~&lt;/p&gt;
    
    </summary>
    
    
      <category term="云服务器" scheme="https://www.zhuxingmin.com/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="web" scheme="https://www.zhuxingmin.com/tags/web/"/>
    
      <category term="nginx" scheme="https://www.zhuxingmin.com/tags/nginx/"/>
    
      <category term="部署" scheme="https://www.zhuxingmin.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="docker" scheme="https://www.zhuxingmin.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>axios进阶之路——封装篇</title>
    <link href="https://www.zhuxingmin.com/2020/05/26/axios%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85%E7%AF%87/"/>
    <id>https://www.zhuxingmin.com/2020/05/26/axios进阶之路——封装篇/</id>
    <published>2020-05-26T09:42:59.000Z</published>
    <updated>2020-05-26T11:52:42.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-封装前准备"><a href="#一、-封装前准备" class="headerlink" title="一、 封装前准备"></a>一、 封装前准备</h2><p>在前两篇讲过了axios的安装、基本配置、拦截器使用，如下：</p><ul><li><a href="/2020/05/12/axios进阶之路——基础篇/" title="axios进阶之路——基础篇">axios进阶之路——基础篇</a></li><li><a href="/2020/05/13/axios进阶之路——拦截器篇/" title="axios进阶之路——拦截器篇">axios进阶之路——拦截器篇</a></li></ul><p>那么本篇的封装也是基于前两篇的基础之上进行的。</p><h2 id="二、-开拔"><a href="#二、-开拔" class="headerlink" title="二、 开拔"></a>二、 开拔</h2><h3 id="1-新建文件夹"><a href="#1-新建文件夹" class="headerlink" title="1. 新建文件夹"></a>1. 新建文件夹</h3><p>在<code>src</code>目录下新建文件夹，用于存放所有请求列表和请求封装的js。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│  ├── service    // ++ 新建文件夹</span><br><span class="line">│  │  ├── http.js// ++ 用于封装请求</span><br><span class="line">│  │  ├── apiList.js// ++ 存放请求路径</span><br><span class="line">│  ├── page</span><br><span class="line">│  │  ├── Home.vue// 主页组件</span><br><span class="line">│  ├── router</span><br><span class="line">│  │  ├── index.js</span><br><span class="line">│  ├── App.vue</span><br><span class="line">│  ├── main.js</span><br></pre></td></tr></table></figure></p><h3 id="2-所有接口请求的统一管理"><a href="#2-所有接口请求的统一管理" class="headerlink" title="2. 所有接口请求的统一管理"></a>2. 所有接口请求的统一管理</h3><p>一般情况下，一个项目的所有请求都会由一个统一的基础路径加上不同的接口路径和接口名组成，并且大部分接口都会有统一的请求或者响应处理，例如返回不同code值，要做响应处理，如果把所有接口都单独处理可谓是资源的极大浪费，因此想办法统一管理。<br>在上一步中，已经新建了一个名为<code>service</code>的文件夹，包含两个js文件：</p><ul><li><strong>apiList.js</strong>：存放请求路径</li><li><strong>http.js</strong>：封装请求</li></ul><p>先看第一个：<code>apiList</code>，就是用来将所有接口统一管理的。<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义请求列表对象API_LIST，其下每个请求(对象)包含请求方法与请求路径两项</span></span><br><span class="line"><span class="keyword">const</span> API_LIST = &#123;</span><br><span class="line">    <span class="comment">// get请求</span></span><br><span class="line">    getData1: &#123;</span><br><span class="line">        method: <span class="string">'get'</span>,</span><br><span class="line">        url: <span class="string">'/xx/getData1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// post请求</span></span><br><span class="line">    getData2: &#123;</span><br><span class="line">        method: <span class="string">'post'</span>,</span><br><span class="line">        url: <span class="string">'/xx/getData2'</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> API_LIST</span><br></pre></td></tr></table></figure></p><p>一个项目，特殊接口的话可以单独处理，其余的的所有请求都可以放在这个文件中进行统一管理，之后项目变动找接口修改也会更好维护。</p><h3 id="3-请求封装"><a href="#3-请求封装" class="headerlink" title="3. 请求封装"></a>3. 请求封装</h3><p>在请求接口列表处理得当之后，就该在请求实例上做文章了。一般需要处理两个问题：一是走请求，二是拦截器处理。<br><em>尽可能加上注释的提供一份参考</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="comment">// 引入刚才封装的请求接口列表</span></span><br><span class="line"><span class="keyword">import</span> api_list <span class="keyword">from</span> <span class="string">'./api/api_list'</span></span><br><span class="line"><span class="comment">// 吐司框组件，配合拦截器使用，可自行处理（不要也行）</span></span><br><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">'xxx'</span></span><br><span class="line"><span class="comment">// 路由设置，配合拦截器使用，可不要</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'../router/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// baseUrl判断</span></span><br><span class="line"><span class="keyword">let</span> baseURL;</span><br><span class="line"><span class="comment">// 如果是开发环境，用本地baseURL，如果是生产环境用线上baseURL</span></span><br><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">    baseURL = <span class="string">'http://&#123;本地地址&#125;/xxx'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    baseURL = <span class="string">'https://&#123;线上地址&#125;/xxx'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">let</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: baseURL,   <span class="comment">// url判断</span></span><br><span class="line">    timeout: <span class="number">15000</span>  <span class="comment">// 超时时间设置</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Http = &#123;&#125;;    <span class="comment">// 用来包裹请求的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历接口列表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> api_list) &#123;</span><br><span class="line">    <span class="keyword">let</span> api = api_list[key];    <span class="comment">// 每一项api都包含method, url</span></span><br><span class="line">    </span><br><span class="line">    Http[key] = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        params,    <span class="regexp">//</span> 请求参数</span></span></span><br><span class="line"><span class="function"><span class="params">        isFormData = true,    <span class="regexp">//</span> 是否是form-data请求</span></span></span><br><span class="line"><span class="function"><span class="params">        config = &#123;&#125;    <span class="regexp">//</span> 配置参数</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newParams = &#123;&#125;; <span class="comment">// 参数容器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// content-type 参数转换</span></span><br><span class="line">        <span class="comment">// 如果需要form-data请求，则格式化为form-data，一般用于post请求</span></span><br><span class="line">        <span class="keyword">if</span>(params &amp;&amp; isFormData) &#123;</span><br><span class="line">            newParams = <span class="keyword">new</span> FormData();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">                newParams.append(key, params[key])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 一般用于get请求</span></span><br><span class="line">            newParams = params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回值容器</span></span><br><span class="line">        <span class="keyword">let</span> res = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不同请求判断</span></span><br><span class="line">        <span class="keyword">if</span>(api.method === <span class="string">'post'</span>) &#123;</span><br><span class="line">            <span class="comment">// post请求处理</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                res = <span class="keyword">await</span> instance[api.method](api.url, newParams, config);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                res = err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(api.method === <span class="string">'get'</span>) &#123;</span><br><span class="line">            <span class="comment">// get请求处理</span></span><br><span class="line">            config.params = newParams;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                res = <span class="keyword">await</span> instance[api.method](api.url, config);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                res = err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回返回值</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="params">req</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 吐司：loading框加载，不要也行</span></span><br><span class="line">    Toast.loading(&#123;</span><br><span class="line">        message: <span class="string">'加载中...'</span>,</span><br><span class="line">        forbidClick: <span class="literal">true</span>,</span><br><span class="line">        loadingType: <span class="string">'spinner'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> req;</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 请求错误</span></span><br><span class="line">    Toast.clear();  <span class="comment">// 清除吐司</span></span><br><span class="line">    Toast.fail(<span class="string">'请求失败，请稍后重试'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    Toast.clear();  <span class="comment">// 清除吐司</span></span><br><span class="line">    <span class="comment">// 不同的返回值跳相应路由即可，如201跳登陆，202跳加载失败等，根据需求自行处理</span></span><br><span class="line">    <span class="keyword">if</span>(res.data.code === <span class="number">201</span>) &#123;</span><br><span class="line">        Router.push(<span class="string">'/login'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(res.data.code === <span class="number">202</span>) &#123;</span><br><span class="line">        Router.push(<span class="string">'/loadfail'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回返回值，返回值为res.data</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">    Toast.clear();  <span class="comment">// 清除吐司</span></span><br><span class="line">    Toast.fail(<span class="string">'无响应，请稍后重试'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Http</span><br></pre></td></tr></table></figure></p><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h3><p>封装完成，盘他！</p><h4 id="4-1-挂载到vue实例上"><a href="#4-1-挂载到vue实例上" class="headerlink" title="4.1 挂载到vue实例上"></a>4.1 挂载到vue实例上</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> Http <span class="keyword">from</span> <span class="string">'./service/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue 实例挂载</span></span><br><span class="line">Vue.prototype.$Http = Http</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h4 id="4-2-测试使用"><a href="#4-2-测试使用" class="headerlink" title="4.2 测试使用"></a>4.2 测试使用</h4><p>在某个vue文件中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            data: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 获取get请求数据，注意async和await配对使用</span></span><br><span class="line">        <span class="keyword">async</span> getData1() &#123;</span><br><span class="line">            <span class="keyword">let</span> res = <span class="keyword">await</span> _this.$Http.getData1(&#123;</span><br><span class="line">                id: <span class="string">'xxx'</span>,</span><br><span class="line">                token: <span class="string">'xxx'</span></span><br><span class="line">            &#125;, <span class="literal">false</span>);  <span class="comment">// false代表不是formdata格式</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(res.code === <span class="number">200</span>) &#123;</span><br><span class="line">                alert(<span class="string">'get数据返回成功'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取post请求数据，注意async和await配对使用</span></span><br><span class="line">        <span class="comment">// 此处是formdata格式，第二个参数可写true,因为默认为true，因此可以不写</span></span><br><span class="line">        <span class="keyword">async</span> getData2() &#123;</span><br><span class="line">            <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.$Http.getData2(&#123;</span><br><span class="line">                id: <span class="string">'xxx'</span>,</span><br><span class="line">                token: <span class="string">'xxx'</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(res.code === <span class="number">200</span>) &#123;</span><br><span class="line">                alert(<span class="string">'post数据返回成功'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="keyword">this</span>.getData1();</span><br><span class="line">        <span class="keyword">this</span>.getData2();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经测试，普通格式（非文件等）请求有效，简单封装完成~</p><h2 id="三、-完结撒花"><a href="#三、-完结撒花" class="headerlink" title="三、 完结撒花~"></a>三、 完结撒花~</h2><p>一般接口的请求封装完毕，用到了基于axios的一些知识，记录至此。在项目中灵活运用，相比于一个个接口单独处理，可谓是大幅度的提升哟~<br>另外，基于此，也可配合proxy（在vue.config.js中配置）处理跨域问题，就不在此处赘述了。</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      本课题包含三篇：基础篇；拦截器篇；封装篇。本篇为封装篇，主题为为axios进行封装使用。
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="https://www.zhuxingmin.com/tags/vue/"/>
    
      <category term="axios" scheme="https://www.zhuxingmin.com/tags/axios/"/>
    
      <category term="拦截器" scheme="https://www.zhuxingmin.com/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>vscode/webstorm自定义vue模板</title>
    <link href="https://www.zhuxingmin.com/2020/05/14/vscode-webstorm%E8%87%AA%E5%AE%9A%E4%B9%89vue%E6%A8%A1%E6%9D%BF/"/>
    <id>https://www.zhuxingmin.com/2020/05/14/vscode-webstorm自定义vue模板/</id>
    <published>2020-05-14T03:40:33.000Z</published>
    <updated>2020-05-14T04:23:25.862Z</updated>
    
    <content type="html"><![CDATA[<h3 id="webstorm"><a href="#webstorm" class="headerlink" title="webstorm"></a>webstorm</h3><h4 id="1-打开设置"><a href="#1-打开设置" class="headerlink" title="1. 打开设置"></a>1. 打开设置</h4><p>打开设置：<br><code>File =&gt; Settings</code></p><h4 id="2-安装vue插件"><a href="#2-安装vue插件" class="headerlink" title="2. 安装vue插件"></a>2. 安装vue插件</h4><p>在搜索区输入<code>plugins</code>，或者找到plugins选项，右边的<code>Marketplace</code>搜索<code>vue</code>，安装。<br><img src="/images/posts/webstorm_1.png" alt="安装插件" title="安装插件"></p><h4 id="3-自定义模板"><a href="#3-自定义模板" class="headerlink" title="3. 自定义模板"></a>3. 自定义模板</h4><p>有时候我们新建vue文件时默认的模板不是我们想要的，这时可以自定义模板：<br>还是在设置中，搜索框输入<code>file and code template</code>或者在设置中找到该选项也行，在右侧选择vue模板，然后在编辑区修改模板即可。如图<br><img src="/images/posts/webstorm_2.png" alt="修改vue模板" title="修改vue模板"></p><h4 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h4><p>给出一份我自己的作为参考，可按自己常用规则优化修改。<br>其中，<code>${COMPONENT_NAME}</code>直接获取组件名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;$&#123;COMPONENT_NAME&#125;&quot;,</span><br><span class="line">        props: [],</span><br><span class="line">        components: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        mounted () &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/scss&quot; lang=&quot;scss&quot; scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><hr><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><h4 id="1-安装Vetur"><a href="#1-安装Vetur" class="headerlink" title="1. 安装Vetur"></a>1. 安装Vetur</h4><p>在应用市场中安装<code>Vetur</code></p><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h4><p>此时，在vue项目中新建<code>.vue</code>文件，然后输入<code>vue</code>时，按<code>tab</code>键则会出来一份默认的模板。由于默认模板涵盖内容过少，因此我们仍需要对齐进行自定义模板配置。</p><h4 id="3-自定义模板-1"><a href="#3-自定义模板-1" class="headerlink" title="3. 自定义模板"></a>3. 自定义模板</h4><ol><li>打开 <code>文件 =&gt; 首选项 =&gt; 用户片段</code></li><li>搜索关键词<code>vue</code></li><li>在候选列表中选择<code>vue.json</code></li><li>在打开的文件中自定义配置即可</li></ol><p><em>如果没有找到<code>vue.json</code>，可以重启一下vscode试一下。</em></p><h4 id="4-参考-1"><a href="#4-参考-1" class="headerlink" title="4. 参考"></a>4. 参考</h4><p>给出一份参考<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"Print to console"</span>: &#123;</span><br><span class="line">        <span class="attr">"prefix"</span>: <span class="string">"vue"</span>,</span><br><span class="line">        <span class="attr">"body"</span>: [</span><br><span class="line">            <span class="string">"&lt;template&gt;"</span>,</span><br><span class="line">            <span class="string">"    &lt;div&gt;\n"</span>,</span><br><span class="line">            <span class="string">"    &lt;/div&gt;"</span>,</span><br><span class="line">            <span class="string">"&lt;/template&gt;\n"</span>,</span><br><span class="line">            <span class="string">"&lt;script&gt;"</span>,</span><br><span class="line">            <span class="string">"export default &#123;"</span>,</span><br><span class="line">            <span class="string">"    props: &#123;\n"</span>,</span><br><span class="line"><span class="string">"    &#125;,"</span>,</span><br><span class="line">            <span class="string">"    components: &#123;\n"</span>,</span><br><span class="line">            <span class="string">"    &#125;,"</span>,</span><br><span class="line">            <span class="string">"    data() &#123;"</span>,</span><br><span class="line">            <span class="string">"        return &#123;\n"</span>,</span><br><span class="line">            <span class="string">"        &#125;;"</span>,</span><br><span class="line">            <span class="string">"    &#125;,"</span>,</span><br><span class="line">            <span class="string">"    watch: &#123;\n"</span>,</span><br><span class="line">            <span class="string">"    &#125;,"</span>,</span><br><span class="line">            <span class="string">"    methods: &#123;\n"</span>,</span><br><span class="line">            <span class="string">"    &#125;,"</span>,</span><br><span class="line">            <span class="string">"    mounted() &#123;\n"</span>,</span><br><span class="line">            <span class="string">"    &#125;,"</span>,</span><br><span class="line"></span><br><span class="line">            <span class="string">"&#125;;"</span>,</span><br><span class="line">            <span class="string">"&lt;/script&gt;\n"</span>,</span><br><span class="line">            <span class="string">"&lt;style scoped lang=\"$&#123;1:scss&#125;\" type=\"text/scss\"&gt;\n"</span>,</span><br><span class="line">            <span class="string">"&lt;/style&gt;\n"</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"Create vue template"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      在进行vue项目时，我们需要对编译器进一步配置来支持vue文件以及相关模板语法的高亮显示等。本文列出关于webstorm和vscode两种常用编译器的模板语法配置。
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="https://www.zhuxingmin.com/tags/vue/"/>
    
      <category term="webstorm" scheme="https://www.zhuxingmin.com/tags/webstorm/"/>
    
      <category term="vscode" scheme="https://www.zhuxingmin.com/tags/vscode/"/>
    
      <category term="配置" scheme="https://www.zhuxingmin.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>axios进阶之路——拦截器篇</title>
    <link href="https://www.zhuxingmin.com/2020/05/13/axios%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E6%8B%A6%E6%88%AA%E5%99%A8%E7%AF%87/"/>
    <id>https://www.zhuxingmin.com/2020/05/13/axios进阶之路——拦截器篇/</id>
    <published>2020-05-13T09:02:30.000Z</published>
    <updated>2020-05-13T10:33:46.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-拦截器介绍"><a href="#一、-拦截器介绍" class="headerlink" title="一、 拦截器介绍"></a>一、 拦截器介绍</h2><p>一般在使用axios时，会用到拦截器的功能，一般分为两种：<code>请求拦截器</code>、<code>响应拦截器</code>。</p><ul><li><strong>请求拦截器</strong><br>在请求发送前进行必要操作处理，例如添加统一cookie、请求体加验证、设置请求头等，相当于是对每个接口里相同操作的一个封装；</li><li><strong>响应拦截器</strong><br>同理，响应拦截器也是如此功能，只是在请求得到响应之后，对响应体的一些处理，通常是数据统一处理等，也常来判断登录失效等。</li></ul><h2 id="二、-Axios实例"><a href="#二、-Axios实例" class="headerlink" title="二、 Axios实例"></a>二、 Axios实例</h2><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a><strong>准备工作：</strong></h3><p>axios安装： <code>yarn add axios</code></p><h3 id="实例创建："><a href="#实例创建：" class="headerlink" title="实例创建："></a><strong>实例创建：</strong></h3><p>新建js文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">let</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'xxxxxxxxxx'</span>,</span><br><span class="line">    timeout: <span class="number">15000</span>  <span class="comment">// 毫秒</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="baseURL设置："><a href="#baseURL设置：" class="headerlink" title="baseURL设置："></a><strong>baseURL设置：</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baseURL;</span><br><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">    baseURL = <span class="string">'xxx本地环境xxx'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    baseURL = <span class="string">'xxx生产环境xxx'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">let</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: baseURL,</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="修改实例的3种配置"><a href="#修改实例的3种配置" class="headerlink" title="修改实例的3种配置"></a><strong>修改实例的3种配置</strong></h3><ol><li><p><strong>全局配置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 局限性比较大</span></span><br><span class="line">axios.defaults.timeout = <span class="number">1000</span>;</span><br><span class="line">axios.defaults.baseURL = <span class="string">'xxxxx'</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>实例配置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'xxxxx'</span>,</span><br><span class="line">    timeout: <span class="number">1000</span>,  <span class="comment">// 超时，401</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 创建完想要修改：</span></span><br><span class="line">instance.defaults.timeout = <span class="number">3000</span></span><br></pre></td></tr></table></figure></li><li><p><strong>请求配置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance.get(<span class="string">'/xxx'</span>,&#123;</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p><strong>优先级如下：</strong><br><code>请求配置</code> &gt; <code>实例配置</code> &gt; <code>全局配置</code></p><h2 id="三、-拦截器配置"><a href="#三、-拦截器配置" class="headerlink" title="三、 拦截器配置"></a>三、 拦截器配置</h2><p>首先了解两个方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="params">req</span>=&gt;</span>&#123;&#125;, err=&gt;&#123;&#125;);</span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">instance.interceptors.reponse.use(<span class="function"><span class="params">req</span>=&gt;</span>&#123;&#125;, err=&gt;&#123;&#125;);</span><br></pre></td></tr></table></figure></p><p>从上可以看出，instance依然是第二步中创建的实例，然后对齐进行拦截，请求用<code>request</code>，响应用<code>reponse</code>，二者都有两个配置项，一个是成功配置，一个是error配置。<br>接下来简单举例说明。</p><h3 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use(两个参数)</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">req</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在发送请求前要做的事儿</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> req</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在请求错误时要做的事儿</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 该返回的数据则是axios.catch(err)中接收的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use(两个参数)</span></span><br><span class="line">axios.interceptors.reponse.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 请求成功对响应数据做处理</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 该返回的数据则是axios.then(res)中接收的数据</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在请求错误时要做的事儿</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 该返回的数据则是axios.catch(err)中接收的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="常见错误码处理-error"><a href="#常见错误码处理-error" class="headerlink" title="常见错误码处理(error)"></a>常见错误码处理(error)</h3><p><strong>错误处理</strong>，请求错误时进行的处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get().then().catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>但实际开发过程中，一般在请求/响应拦截器中统一做错误处理，有特殊接口的话做单独的catch错误处理。</p><h4 id="1-请求错误码处理"><a href="#1-请求错误码处理" class="headerlink" title="1. 请求错误码处理"></a>1. 请求错误码处理</h4><ul><li>404： not found</li><li>401： 请求超时<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(req, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 此处做统一处理</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-响应错误码处理"><a href="#2-响应错误码处理" class="headerlink" title="2. 响应错误码处理"></a>2. 响应错误码处理</h4><ul><li>500： 系统错误</li><li>502： 系统重启<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.reponse.use(res, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 此处做统一处理</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="——"><a href="#——" class="headerlink" title="——"></a>——</h2><p>以上。<br>下一篇记录整个请求流程，以及请求的封装。</p>]]></content>
    
    <summary type="html">
    
      本课题包含三篇：基础篇；拦截器篇；封装篇。本篇为拦截器篇，主题为axios的请求拦截器、响应拦截器配置。
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="https://www.zhuxingmin.com/tags/vue/"/>
    
      <category term="axios" scheme="https://www.zhuxingmin.com/tags/axios/"/>
    
      <category term="拦截器" scheme="https://www.zhuxingmin.com/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>axios进阶之路——基础篇</title>
    <link href="https://www.zhuxingmin.com/2020/05/12/axios%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>https://www.zhuxingmin.com/2020/05/12/axios进阶之路——基础篇/</id>
    <published>2020-05-12T01:59:21.000Z</published>
    <updated>2020-05-12T04:18:16.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-关于Axios"><a href="#一、-关于Axios" class="headerlink" title="一、 关于Axios"></a>一、 关于Axios</h2><h3 id="1-Axios是什么"><a href="#1-Axios是什么" class="headerlink" title="1. Axios是什么"></a>1. Axios是什么</h3><ul><li>Axios是一个基于 promise 的 HTTP 库</li><li>可以用于浏览器和 node.js </li><li>类似于 Ajax，进行前后端交互使用</li></ul><h3 id="2-Axios-特性"><a href="#2-Axios-特性" class="headerlink" title="2. Axios 特性"></a>2. Axios 特性</h3><ul><li>支持 Promise API </li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防御 XSRF</li></ul><h2 id="二、-安装使用"><a href="#二、-安装使用" class="headerlink" title="二、 安装使用"></a>二、 安装使用</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>两种方式：（二选一）</p><ol><li>npm</li><li>yarn</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用npm：</span></span><br><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或者使用yarn：</span></span><br><span class="line">$ yarn add axios</span><br></pre></td></tr></table></figure><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p><strong>基础使用示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'url'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 请求成功要做的事</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 请求失败要做的事</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="三、-基础介绍及使用"><a href="#三、-基础介绍及使用" class="headerlink" title="三、 基础介绍及使用"></a>三、 基础介绍及使用</h2><h3 id="1-axios常用请求方法"><a href="#1-axios常用请求方法" class="headerlink" title="1. axios常用请求方法"></a>1. axios常用请求方法</h3><ul><li>get</li><li>post</li><li>put</li><li>patch</li><li>delete</li></ul><h3 id="2-区别"><a href="#2-区别" class="headerlink" title="2. 区别"></a>2. 区别</h3><table><thead><tr><th>方法</th><th>用途</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td><strong>get</strong></td><td>获取数据</td><td style="text-align:center">/</td></tr><tr><td><strong>post</strong></td><td>提交数据</td><td style="text-align:center">表单提交、文件上传等</td></tr><tr><td>put</td><td>更新数据</td><td style="text-align:center">所有数据推送到后端</td></tr><tr><td>patch</td><td>更新数据</td><td style="text-align:center">只将修改的数据推送到后端</td></tr><tr><td>delete</td><td>删除数据</td><td style="text-align:center">/</td></tr></tbody></table><p>其中<code>get</code>,<code>post</code>目前前后端交互中最为常用</p><p><em>注：请求方法一般由后端定义，实际项目使用参照后端文档规则</em></p><h3 id="3-常用示例（GET、POST）"><a href="#3-常用示例（GET、POST）" class="headerlink" title="3. 常用示例（GET、POST）"></a>3. 常用示例（GET、POST）</h3><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get</span></span><br><span class="line">axios.get(<span class="string">'/data.json'</span>,&#123;</span><br><span class="line">    <span class="comment">// 注 此处参数写入params中</span></span><br><span class="line">    params: &#123;</span><br><span class="line">        id: <span class="string">'zxm'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// post：参数直接跟在url后面即可</span></span><br><span class="line">axios.post(<span class="string">'xxxxxxxxx'</span>, &#123;</span><br><span class="line">        xxx: <span class="string">'xxxx'</span>,</span><br><span class="line">        xxxx: <span class="string">'xxxx'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-并发请求"><a href="#4-并发请求" class="headerlink" title="4. 并发请求"></a>4. 并发请求</h3><p><strong>并发请求：</strong><br> 同时进行多个请求，并统一处理返回值。两个步骤：</p><ol><li><code>axios.all([]).then()</code></li><li><code>axios.spread()</code></li></ol><p><strong>举例：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">    axios.get(<span class="string">'url1'</span>),</span><br><span class="line">    axios.get(<span class="string">'url2'</span>)</span><br><span class="line">]).then(</span><br><span class="line">    axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res1, res2);</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="——"><a href="#——" class="headerlink" title="——"></a>——</h2><p>基础篇到此结束，下篇记录<code>axios简单实例</code>，<code>请求拦截器</code>，<code>响应拦截器</code>。</p>]]></content>
    
    <summary type="html">
    
      本课题包含三篇：基础篇；拦截器篇；封装篇。本篇为基础篇，主题为axios基础介绍及安装使用。
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="https://www.zhuxingmin.com/tags/vue/"/>
    
      <category term="axios" scheme="https://www.zhuxingmin.com/tags/axios/"/>
    
      <category term="拦截器" scheme="https://www.zhuxingmin.com/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>css布局之道——内凹圆角设计</title>
    <link href="https://www.zhuxingmin.com/2020/04/29/css%E5%B8%83%E5%B1%80%E4%B9%8B%E9%81%93%E2%80%94%E2%80%94%E5%86%85%E5%87%B9%E5%9C%86%E8%A7%92%E8%AE%BE%E8%AE%A1/"/>
    <id>https://www.zhuxingmin.com/2020/04/29/css布局之道——内凹圆角设计/</id>
    <published>2020-04-29T03:51:37.000Z</published>
    <updated>2020-05-07T01:50:34.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-效果图"><a href="#一、-效果图" class="headerlink" title="一、 效果图"></a>一、 效果图</h2><p>先来看一下效果图：<br><img src="/images/posts/内凹圆角.gif" alt="内凹圆角" title="内凹圆角"></p><a id="more"></a><h2 id="二、-实现"><a href="#二、-实现" class="headerlink" title="二、 实现"></a>二、 实现</h2><h3 id="1-场景"><a href="#1-场景" class="headerlink" title="1. 场景"></a>1. 场景</h3><p>看上图，此类场景应该很是常用吧，比如账单、卡片、列表等。</p><h3 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2. 实现思路"></a>2. 实现思路</h3><p>看到效果图，能想到的实现方法则是</p><ul><li>planA：border-radius直接搞起来</li><li>planB：定位</li></ul><p>但是细想之后发现两者皆不可用，border-radius处理的话是凸角，舍弃；定位需要独立出来两个模块，复杂度高了，舍弃。<br>可是舍弃后，需要怎么做呢？切背景图吗？显然不合理，如果内容不固定，则模块的长度也不一样，背景图也会拉伸；思来想去，还是得从<code>定位</code>上做文章：既然元素多比较复杂，那就直接在伪类上动手。<br>可能大家猜到了，就是直接在<code>::before</code>、<code>::after</code>上模拟出来。</p><h2 id="三、-代码"><a href="#三、-代码" class="headerlink" title="三、 代码"></a>三、 代码</h2><h3 id="1-基础布局"><a href="#1-基础布局" class="headerlink" title="1. 基础布局"></a>1. 基础布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html：随便一些div --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80vw</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">15vh</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> dashed <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-伪类"><a href="#2-伪类" class="headerlink" title="2. 伪类"></a>2. 伪类</h3><p>基础布局出来后，怎么利用伪类处理呢？思路是这样的：</p><ol><li>利用伪类画出来一个与主题背景色一样的圆；</li><li>定位，向左(右)偏移圆自身的一半，视觉效果就是半个圆在上面；</li><li>继续定位，向上继续偏移小球的一半，视觉效果则是每个模块有个四分之一内凹圆角一样。</li></ol><p>知道思路后，就继续实现吧：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::before</span>,<span class="selector-tag">div</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">::before</span>,<span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就完成了~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、-效果图&quot;&gt;&lt;a href=&quot;#一、-效果图&quot; class=&quot;headerlink&quot; title=&quot;一、 效果图&quot;&gt;&lt;/a&gt;一、 效果图&lt;/h2&gt;&lt;p&gt;先来看一下效果图：&lt;br&gt;&lt;img src=&quot;/images/posts/内凹圆角.gif&quot; alt=&quot;内凹圆角&quot; title=&quot;内凹圆角&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="https://www.zhuxingmin.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="css" scheme="https://www.zhuxingmin.com/tags/css/"/>
    
      <category term="布局" scheme="https://www.zhuxingmin.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
</feed>

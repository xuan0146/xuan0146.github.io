<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue弹窗屏蔽滑动的两种解决方案]]></title>
    <url>%2F2019%2F05%2F28%2Fvue%E5%BC%B9%E7%AA%97%E5%B1%8F%E8%94%BD%E6%BB%91%E5%8A%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[序&emsp;&emsp;在开发过程中，我们经常会遇到要加弹窗的需求，而如果当前页的展示数据一屏展示不完，则在打开弹窗后，有滑动操作时，页面也会随之滑动。那么如何处理这一问题呢？ 常见问题&emsp;&emsp;我们开发过程中，最常见的问题上文已叙述：打开弹窗后，有滑动操作时，页面也会随之滑动。问题示意图如下： 最终效果我们来看一波正确示范 解决方案&emsp;&emsp;两种解决方案，针对两种不同情况： 弹框数据少，无需滑动 弹框内数据需要滑动展示 1. 无需滑动弹窗a. 思路 思路：vue自带修饰符可解决该问题—— @touchmove.prevent 此方案重点在将@touchmove.prevent绑定到弹窗模块，然后动态控制弹窗显示隐藏即可。 b. 效果 c. 代码1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=&quot;modalTest&quot;&gt; &lt;!-- 按钮组 --&gt; &lt;div class=&quot;btn&quot;&gt; &lt;el-button type=&quot;success&quot; size=&quot;small&quot; @click=&quot;modalSign1 = true&quot;&gt;弹窗1&lt;/el-button&gt; &lt;/div&gt; &lt;!-- 背景数据 --&gt; &lt;div class=&quot;listBG&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in 50&quot;&gt;这是第&#123;&#123;item&#125;&#125;条背景数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 弹框1 --&gt; &lt;div class=&quot;modalBox&quot; v-if=&quot;modalSign1&quot; @touchmove.prevent @click.self=&quot;modalSign1 = false&quot;&gt; &lt;div class=&quot;modal&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in 8&quot;&gt;这是第&#123;&#123;item&#125;&#125;条数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; modalSign1: false, // 弹窗是否打开 &#125; &#125; &#125;&lt;/script&gt; 2. 弹框内数据需要滑动展示a. 思路&emsp;&emsp;首先，我们使用正常的vue操作，比如刚才的修饰符/语法糖进行操作时，虽然可以屏蔽掉背景数据滑动，但是该事件同时会将弹框内的滑动也阻止掉，我们则无法完成该需求。如果这个不行，我们还有别的方法来完成需求吗？&emsp;&emsp;我考虑到一种方案，但是属于DOM操作，与vue的初衷可能不太符合。不过此方案也不矢为一种能够有效解决问题的办法。 思路：利用cssposition: fixed以及top: x px来固定位置。步骤分解如下： 写一个样式放到公共css中备用； 点击按钮，控制弹窗显示隐藏； 两个方法，一个控制将步骤1写的css动态添加到body上，另外一个则控制移除该效果； 添加方法：①获取当前页面距离顶部高度，保存到data中；②给body添加步骤1的css；③设置body的高度为刚才获取到的高度。 移除方法： ①将刚才冬天给body添加的css移除；②当前滑动高度设置为data中存储的高度。 b. 效果 c. 两个案例完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;template&gt; &lt;div class=&quot;modalTest&quot;&gt; &lt;!-- 按钮组 --&gt; &lt;div class=&quot;btn&quot;&gt; &lt;el-button type=&quot;success&quot; size=&quot;small&quot; @click=&quot;modalSign1 = true&quot;&gt;弹窗1&lt;/el-button&gt; &lt;br&gt; &lt;el-button type=&quot;danger&quot; size=&quot;small&quot; @click=&quot;openModal&quot;&gt;弹窗2&lt;/el-button&gt; &lt;/div&gt; &lt;!-- 背景数据 --&gt; &lt;div class=&quot;listBG&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in 50&quot;&gt;这是第&#123;&#123;item&#125;&#125;条背景数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 弹框1 --&gt; &lt;div class=&quot;modalBox&quot; v-if=&quot;modalSign1&quot; @touchmove.prevent @click.self=&quot;modalSign1 = false&quot;&gt; &lt;div class=&quot;modal&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in 8&quot;&gt;这是第&#123;&#123;item&#125;&#125;条数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 弹框2 --&gt; &lt;div class=&quot;modalBox&quot; v-if=&quot;modalSign2&quot; @click.self=&quot;closeModal&quot;&gt; &lt;div class=&quot;modal&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in 20&quot;&gt;这是第&#123;&#123;item&#125;&#125;条数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; modalSign1: false, // 弹窗是否打开 modalSign2: false, // 弹窗是否打开 scrollTop: undefined, // 距离顶端的值 className: &apos;modalOpen&apos;, // 类名 &#125; &#125;, methods: &#123; // 打开弹层 要做的事 afterOpen () &#123; this.scrollTop = document.scrollingElement.scrollTop; document.body.classList.add(this.className); document.body.style.top = `-$&#123;this.scrollTop&#125;px`; &#125;, // 弹层关闭之前 要做的事 beforeClose () &#123; document.body.classList.remove(this.className); document.scrollingElement.scrollTop = this.scrollTop; &#125;, // 打开弹窗 openModal () &#123; this.modalSign2 = true; this.afterOpen(); &#125;, // 关闭弹窗 closeModal () &#123; this.modalSign2 = false; this.beforeClose(); &#125; &#125;, mounted() &#123; &#125; &#125;&lt;/script&gt;&lt;style type=&quot;text/scss&quot; lang=&quot;scss&quot; scoped&gt; .modalTest&#123; width: 100%; min-height: 100vh; overflow: scroll; .btn&#123; padding: 10px; position: fixed; top: 0; left: 0; z-index: 10; &amp;&gt;button&#123; margin: 10px 0; &#125; &#125; .listBG&#123; text-align: center; line-height: 50px; &#125; .modalBox&#123; width: 100vw; height: 100vh; overflow: hidden; position: fixed; top: 0; left: 0; background: rgba(0,0,0,0.4); z-index: 999; .modal&#123; width: 220px; height: 280px; overflow: scroll; background: #fff; border-radius: 10px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); -moz-box-shadow:10px 10px 9px #332A0D; -webkit-box-shadow:10px 10px 9px #332A0D; box-shadow:10px 10px 9px #332A0D; padding: 30px 0 0; ul&#123; text-align: center; li&#123; list-style: none; line-height: 30px; &#125; &#125; &#125; &#125; &#125;&lt;/style&gt; d. 备注.modalOpen的css样式，放在公共样式中，因为我们要改变的是body的样式，因此在组件中写的样式可能会失效。例如，我将样式放在了src/assets/css/common.css123456/*弹层*/body.modalOpen &#123; -webkit-overflow-scrolling:touch; position: fixed; width: 100%;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>弹窗</tag>
        <tag>滑动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中引入并使用markdown编辑器]]></title>
    <url>%2F2019%2F05%2F23%2Fvue%E4%B8%AD%E5%BC%95%E5%85%A5%E5%B9%B6%E4%BD%BF%E7%94%A8markdown%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[效果 开篇&emsp;&emsp;不知道各位是否对markdown熟悉。它算是一门标记语言，但是语法简单，却本领强大。例如本篇博客，便是用markdown语法编写，然后根据不同的环境及依赖生成各种我想要的样式，比如直接生成本篇博客样式或者使用一些依赖或者工具赋之更加美观的样式。同样，一般在CMS后台管理系统中，也经常会用到编辑器来编写一些文章材料。其中最常用的还是markdown编辑器和富文本编辑器。 Markdown 介绍1. 什么是Markdown&emsp;&emsp;首先，各位框架玩家一定不会陌生，因为无论是在各类框架下还是开源项目中，都会有一个.md的文件，该文件一般是项目说明文件，不仅语法简洁，而且所生成的“页面”也要比普通标记语言更加整洁明了。那么它到底是什么呢？&emsp;&emsp;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。&emsp;&emsp;Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 2. Markdown用途&emsp;&emsp;Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。&emsp;&emsp;用于编写说明文档，并且以“README.md”的文件名保存在软件的目录下面。除此之外，由于我们有了RStudio这样的神级编辑器，我们还可以快速将Markdown转化为演讲PPT、Word产品文档、LaTex论文甚至是用非常少量的代码完成最小可用原型。在数据科学领域，Markdown已经广泛使用，极大地推进了动态可重复性研究的历史进程。 vue 中如何使用注： 本示例选用的是mavon-editor很明显，所有组件逃不过三步走原则： 安装 引入、配置 使用 1. 安装安装mavon-editor:npm install mavon-editor --save 2. 引入、配置在要使用markdown编辑器的组件内操作：12345&lt;script&gt;// 导入组件 及 组件样式import &#123; mavonEditor &#125; from &apos;mavon-editor&apos;import &apos;mavon-editor/dist/css/index.css&apos;&lt;/script&gt; 3. 使用 注意： 绑定model 实时改变：将markdown实时转化为html 在要使用markdown编辑器的组件内操作:1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div&gt; &lt;mavon-editor v-model=&quot;content&quot; ref=&quot;md&quot; @change=&quot;change&quot; style=&quot;min-height: 600px&quot; /&gt; &lt;button @click=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // 注册 components: &#123; mavonEditor, &#125;, data() &#123; return &#123; content:&apos;&apos;, // 输入的markdown html:&apos;&apos;, // 及时转的html &#125; &#125;, methods: &#123; // 所有操作都会被解析重新渲染 change(value, render)&#123; // render 为 markdown 解析后的结果[html] this.html = render; &#125;, // 提交 submit()&#123; console.log(this.content); console.log(this.html); &#125; &#125;, mounted() &#123; &#125;&#125;&lt;/script&gt; 问题那么，在常用的操作里面，例如各级标题、表格、加粗加斜、标记、图文……图？此时，我们发现一个问题：如何添加本地图片呢？ Q在某些IDE里面使用markdown时，可以自由的插入本地图片，那我们在页面中使用此编译器组件如何添加图片呢？ A监听。没错，就是监听输入框变化。如果监听到有图片插入，那么我们可以先将图片上传至服务器，然后获取到线上url，拿到该url再插入到该位置。那么具体过程就很明显了： 选择本地图片，插入 监听到有图片插入 将该图上传至服务器 获取到服务器返回的图片url 将该线上url冬天插入到输入框中 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div class=&quot;markdown&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;mavon-editor v-model=&quot;content&quot; ref=&quot;md&quot; @imgAdd=&quot;$imgAdd&quot; @change=&quot;change&quot; style=&quot;min-height: 600px&quot;/&gt; &lt;button @click=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; mavonEditor &#125; from &apos;mavon-editor&apos; import &apos;mavon-editor/dist/css/index.css&apos; export default &#123; name: &quot;&quot;, props: [], components: &#123; mavonEditor, &#125;, data() &#123; return &#123; content:&apos;&apos;, html:&apos;&apos;, configs: &#123;&#125; &#125; &#125;, methods: &#123; // 将图片上传到服务器，返回地址替换到md中 $imgAdd(pos, $file)&#123; let formdata = new FormData(); this.$upload.post(&apos;/上传接口地址&apos;, formdata).then(res =&gt; &#123; console.log(res.data); this.$refs.md.$img2Url(pos, res.data); &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125;, // 所有操作都会被解析重新渲染 change(value, render)&#123; // render 为 markdown 解析后的结果[html] this.html = render; &#125;, // 提交 submit()&#123; console.log(this.content); console.log(this.html); this.$message.success(&apos;提交成功，已打印至控制台！&apos;); &#125; &#125;, mounted() &#123; &#125; &#125;&lt;/script&gt; 后&emsp;&emsp;到这里，vue中使用markdown编辑器教程结束。那么更为大众广泛使用的富文本编辑器如何使用呢？且看下回~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[520特辑———旋转爱]]></title>
    <url>%2F2019%2F05%2F20%2F520%E7%89%B9%E8%BE%91%E2%80%94%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E7%88%B1%2F</url>
    <content type="text"><![CDATA[序&emsp;&emsp;520：网络情人节是信息时代的爱情节日，定于每年的5月20日和5月21日。该节日源于歌手范晓萱的《数字恋爱》中“520”被喻成“我爱你” ，以及音乐人吴玉龙的网络歌曲中“我爱你”与“网络情人”的紧密联系。后来，“521”也逐渐被情侣们赋予了“我愿意、我爱你”的意思。“网络情人节”又被称为“结婚吉日”、“表白日”、“撒娇日”、“求爱节”。&emsp;&emsp;那么，作为程序员，如何通过专业技能向自己的另一半表达爱意呢？ 效果 技术栈 技术栈[及环境] 版本 vue-cli 3.x vue 2.x element-ui 2.x sass scss 实现分析 不难看出，页面分为三个部分：背景、旋转导航花瓣及弹框； 6个花瓣对应对个导航栏，每个导航栏颜色及打开弹窗的背景色相同； 弹窗共用，动态展示不同的弹窗内容区域及改变标题即可； 动画：这里动画均有原生css3的@keyframes完成，在animation里调用。 功能点 导航切换 旋转动画 走马灯（相册轮播） 标签切换（足迹中标签） table表格（说说） 时间轴（时刻） 弹幕效果（留言） 缩放效果（中心图片点击缩放） 项目一览项目结构如下：12345678910111213141516├── README.md // 项目说明├── babel.config // babel配置├── package.json // 包配置├── public│ ├── favicon.ico // 放在title前的页面logo│ └── index.html // 主页面├── src│ ├── assets│ │ ├── css // 自定义配置css│ │ └── love // 图片资源│ ├── love│ │ └── love.vue // 520主题组件│ ├── App.vue│ ├── router.js // 路由│ └── main.js // 主配置└── vue.config.js // vue自定义配置 其中，项目重点在love.vue组件中 功能点简述1. 导航及切换 首先，6个导航位，文字不同，icon不同；其次，点击菜单需要有旋转效果，菜单旋转缩小，弹框旋转放大展示；最后，判断/写入弹框卡片(下简称卡片)背景色。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// template 部分&lt;div class=&quot;leafs&quot;&gt; &lt;div v-for=&quot;(item, index) in menuList&quot; :key=&quot;item.name&quot; class=&quot;leaf&quot; @click=&quot;runCircle(item.name, index)&quot; :class=&quot;`leaf$&#123;index+1&#125;`&quot;&gt; &lt;img :src=&quot;item.url&quot; alt=&quot;&quot;&gt; &lt;span class=&quot;nameSpain&quot;&gt;&lt;i :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;!-- 小心心 --&gt; &lt;div class=&quot;heart&quot; :class=&quot;&#123;heartScale: heartScaleSign&#125;&quot; @click=&quot;heartScale&quot;&gt; &lt;img src=&quot;../assets/love/heart.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/div&gt;// script部分data() &#123; return &#123; show: false, runCircleSign: false, // 旋转变小 heartScaleSign: false, // 心 变大缩小 cardMiss: false, // 卡片动画消失 showCard: false, // 卡片显示状态 cardName: &apos;&apos;, // 卡片title cardChange: -1, //切换卡片 cardGround: &apos;&apos;, // 卡片背景色 menuList: [ &#123; url: require(&apos;../assets/love/leaf1.png&apos;), icon: &apos;el-icon-picture-outline&apos;, name: &apos;相册&apos; &#125;, &#123; url: require(&apos;../assets/love/leaf2.png&apos;), icon: &apos;el-icon-location&apos;, name: &apos;足迹&apos; &#125;, &#123; url: require(&apos;../assets/love/leaf3.png&apos;), icon: &apos;el-icon-edit&apos;, name: &apos;说说&apos; &#125;, &#123; url: require(&apos;../assets/love/leaf4.png&apos;), icon: &apos;el-icon-date&apos;, name: &apos;时刻&apos; &#125;, &#123; url: require(&apos;../assets/love/leaf5.png&apos;), icon: &apos;el-icon-news&apos;, name: &apos;留言&apos; &#125;, &#123; url: require(&apos;../assets/love/leaf6.png&apos;), icon: &apos;el-icon-printer&apos;, name: &apos;影集&apos; &#125; ], cardType: 0, menuIndex: -1, activeName: &apos;first&apos;, // 当前标签 &#125;&#125;,methods: &#123; // 菜单缩放 runCircle (name, index) &#123; let _this = this; // 缩放 this.runCircleSign = ! this.runCircleSign; this.menuIndex = index; // 赋值名称 this.cardName = name; // 显示卡片 this.showCard = true; // 卡片颜色 switch (index) &#123; case 0: _this.cardGround = &apos;rgba(129,15,175,0.4)&apos;; _this.cardType = 0; break; case 1: _this.cardGround = &apos;rgba(12,136,145,0.6)&apos;; _this.cardType = 1; break; case 2: _this.cardGround = &apos;rgba(255,235,45,0.6)&apos;; _this.cardType = 2; break; case 3: _this.cardGround = &apos;rgba(196,0,83,0.6)&apos;; _this.cardType = 3; break; case 4: _this.cardGround = &apos;rgba(87,174,157,0.6)&apos;; _this.cardType = 4; break; case 5: _this.cardGround = &apos;rgba(255,125,0,0.6)&apos;; _this.cardType = 5; break; &#125; &#125;, // 心 缩放 heartScale () &#123; this.heartScaleSign = ! this.heartScaleSign; &#125;, // 消失卡片 &amp;&amp; 菜单复原 backSign () &#123; let _this = this; _this.cardMiss = true; _this.runCircleSign = ! _this.runCircleSign; setTimeout(() =&gt; &#123; _this.showCard = false; _this.cardMiss = false; &#125;, 3000) &#125;,&#125;, 2. 弹幕效果 1.输入内容；2.循环展示；3.随即高度及标签颜色；4.利用本地存储持久化;5.动画漂移效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// template&lt;div class=&quot;haveWords&quot;&gt; &lt;!-- 展示内容 --&gt; &lt;div class=&quot;cont&quot;&gt; &lt;el-tag v-for=&quot;el in ku&quot; :key=&quot;el.id&quot; class=&quot;fly&quot; :type=&quot;el.type&quot; :style=&quot;&#123;top:el.top + &apos;px&apos;&#125;&quot; &gt; &#123;&#123; el.msg &#125;&#125; &lt;/el-tag&gt; &lt;/div&gt; &lt;!-- 输入内容 --&gt; &lt;div class=&quot;dealBox&quot;&gt; &lt;el-input type=&quot;textarea&quot; :autosize=&quot;&#123; minRows: 2, maxRows: 5&#125;&quot; placeholder=&quot;请输入留言&quot; v-model.trim=&quot;msg&quot; size=&quot;small&quot;&gt; &lt;/el-input&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; @click=&quot;sendData&quot;&gt;Biu~&lt;/el-button&gt; &lt;/div&gt;&lt;/div&gt;// scriptdata() &#123; return &#123; msg: null, //缓存 ku: JSON.parse(localStorage.kuArr), //存取数据 msgKu: [] &#125;&#125;,methods: &#123; // 弹幕 sendData () &#123; // 5中标签模式 let typeArr = [&apos;&apos;,&apos;success&apos;,&apos;info&apos;,&apos;warning&apos;,&apos;danger&apos;]; let localArr = this.ku; //判空 不为空则继续 为空则提示输入 if(this.msg !== &apos;&apos; &amp;&amp; this.msg !== null) &#123; let num1 = Math.random() * 500; let num2 = Math.random() * 5; let arrMark = Math.floor(num2); let top = Math.floor(num1); let obj = &#123;msg:this.msg,top:top,type:typeArr[arrMark]&#125;; localArr.push(obj); localStorage.kuArr = JSON.stringify(localArr); this.msg = &quot;&quot;; &#125; else &#123; this.$message.warning(&apos;要先输入哦~&apos;); &#125; &#125;,&#125;, &emsp;&emsp;别的功能点基本上都是element-ui中组件自带或基于组件开发的，熟悉element-ui的小伙伴应该极为熟悉。有感兴趣的朋友可自行去element-ui官网学习。element飞机票 后&emsp;&emsp;有对本demo感兴趣的或者想要作者源码的可以关注公众号流眸，回复“520源码”拿到代码哦~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js页面全屏]]></title>
    <url>%2F2019%2F05%2F13%2Fjs%E9%A1%B5%E9%9D%A2%E5%85%A8%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[需求 背景&emsp;&emsp;在做前端PC端项目中，我们经常会遇到让页面全屏的需求。大多情况下，这样可以使得用户在该页面更加专注，屏蔽掉该页面之外的干扰。 需求分析 状态判断 事件操作1. 状态判断首先，我们需要给出一个默认状态，即非全屏。然后，在此基础上我们进行DOM操作，每次用户进行操作时，我们先判断当前状态，进行相应的操作，操作过后改变当前状态即可。2. 事件操作注：下表中de代表document.documentElement 操作 浏览器 代码 全屏 W3C de.requestFullscreen() 全屏 CHROME de.webkitRequestFullScreen() 全屏 FIREFOX de.mozRequestFullScreen() 全屏 IE de.msRequestFullscreen() 还原 W3C document.exitFullscreen 还原 CHROME document.webkitCancelFullScreen 还原 FIREFOX document.mozCancelFullScreen 还原 IE document.msExitFullscreen 代码注： 本demo在vue中使用。如果使用正常.html，自行将@click转为正常点击事件(如onclick)即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445// html&lt;div @click=&quot;handleFullScreen&quot;&gt; 一个按钮&lt;/div&gt;// jsdata() &#123; return &#123; fullscreen: false // 是否全屏 &#125;&#125;,methods: &#123; // 全屏事件 handleFullScreen()&#123; let element = document.documentElement; // 判断是否已经是全屏 // 如果是全屏，退出 if (this.fullscreen) &#123; if (document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if (document.webkitCancelFullScreen) &#123; document.webkitCancelFullScreen(); &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if (document.msExitFullscreen) &#123; document.msExitFullscreen(); &#125; console.log(&apos;已还原！&apos;); &#125; else &#123; // 否则，进入全屏 if (element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if (element.webkitRequestFullScreen) &#123; element.webkitRequestFullScreen(); &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if (element.msRequestFullscreen) &#123; // IE11 element.msRequestFullscreen(); &#125; console.log(&apos;已全屏！&apos;); &#125; // 改变当前全屏状态 this.fullscreen = !this.fullscreen; &#125;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>全屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 3.x 打包白屏、清除console及IE白屏问题解决]]></title>
    <url>%2F2019%2F05%2F06%2Fvue-cli-3-x-%E6%89%93%E5%8C%85%E7%99%BD%E5%B1%8F%E3%80%81%E6%B8%85%E9%99%A4console%E5%8F%8AIe%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[问题 打包白屏 IE白屏 打包后清除控制台所有console信息 js\css压缩问题 解决问题1. 打包白屏描述npm run build打包后，生成dist文件夹。从该文件夹打开dist/index.html页面，发现页面空白，且控制台报错。原因是路径配置有问题。方案根目录打开/新建vue.config.js，配置路径：1234module.exports = &#123; // 基本路径配置 publicPath: &apos;./&apos;&#125; 重新打包验证，问题得以解决。 问题2. IE白屏描述在打包完成之后，如果是pc项目，或者移动端低版本兼容项目，则会有许多问题，其中白屏问题困扰着很多开发者，在安卓4.0、IE多个版本环境中体现的尤为别致。方案 下载相关插件 1npm install @babel/core @babel/plugin-transform-runtime @babel/preset-env es6-promise babel-polyfill --save-dev-dev 根目录新建文件.babelrc： 123456&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;], &quot;plugins&quot;: [ &quot;@babel/plugin-transform-runtime&quot; ]&#125; [注: 基于vue-cli 3.x] 修改根目录下的文件babel.config.js： 123456789101112131415161718192021222324// ... some other codes// 打包时删除consoleconst plugins = [];if ([&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV)) &#123; plugins.push(&quot;transform-remove-console&quot;)&#125;module.exports = &#123; presets: [ [ &apos;@vue/app&apos;, &#123; &quot;useBuiltIns&quot;: &quot;entry&quot;, polyfills: [ &apos;es6.promise&apos;, &apos;es6.symbol&apos; ] &#125; ] ], plugins: plugins&#125; 创建/修改根目录下的文件vue.config.js： 123456789module.exports = &#123; // 显式转义依赖 transpileDependencies: [&apos;webpack-dev-server/client&apos;], chainWebpack: config =&gt; &#123; // 指定入口 es6转es5 config.entry.app = [&apos;babel-polyfill&apos;, &apos;./src/main.js&apos;]; &#125;&#125; 入口引入相关插件src/main.js 1234// 解决ie白屏问题import &apos;@babel/polyfill&apos;import Es6Promise from &apos;es6-promise&apos;Es6Promise.polyfill() 重启服务/重新打包页面正常显示，控制台无报错信息。问题解决。 问题3. 打包后清除控制台所有console信息描述在开发环境中，我们调试过程中会添加些许的console.log或者debugger相关代码，来帮助我们完成开发。但是有时候此类代码太多或者马虎了，上线前没有删除干净，那么打包后生产环境中就会在控制台留下相关信息。那么为了避免这一不友好行为，我们采取插件来在打包时，清除所有打印信息。方案 安装插件 1npm install uglifyjs-webpack-plugin --save-dev 配置vue.config.js 1234567891011121314151617181920212223242526272829// 去除consoleconst UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);const env = process.env.NODE_ENV;module.exports = &#123; // ... other codes // 去除console configureWebpack: (config) =&gt; &#123; if (env !== &apos;development&apos; || env !== &apos;test&apos;) &#123; config.plugins.push( new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_debugger: true, // 注释console drop_console: true, pure_funcs:[&apos;console.log&apos;] // 移除console &#125;, &#125;, sourceMap: false, parallel: true, &#125;), ); &#125; &#125;,&#125; 重新打包配置完成后，重新打包npm run build，打开dist/index.html验证，console全部清除。 问题4. js\css压缩问题描述在打包成功后，为了缩小包体积，提高页面响应速度，一般会对包进行压缩，此处主要针对js\css来处理。方案 安装插件 1npm install compression-webpack-plugin --save-dev 配置vue.config.js中的configureWebpack 123456789101112131415// 压缩css、jsconst CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;);// 要压缩的文件const productionGzipExtensions = [&apos;js&apos;, &apos;css&apos;];configureWebpack: (config) =&gt; &#123; if (env !== &apos;development&apos; || env !== &apos;test&apos;) &#123; config.plugins.push(new CompressionWebpackPlugin(&#123; algorithm: &apos;gzip&apos;, test: new RegExp(`\\.($&#123;productionGzipExtensions.join(&apos;|&apos;)&#125;)$`), threshold: 10240, minRatio: 0.8, &#125;)); &#125;&#125; 重启服务完成陪之后重启服务/重新打包，处理完成，搞定收工！ 附赠这里附上基于vue-cli3的一些简单配置文件 vue.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124const path = require(&apos;path&apos;);const resolve = dir =&gt; path.resolve(__dirname, dir);// const IS_PROD = [&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV);// const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;// 去除consoleconst UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);// 压缩css、jsconst CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;);// 要压缩的文件const productionGzipExtensions = [&apos;js&apos;, &apos;css&apos;];// const productionGzipExtensions = /\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i;const env = process.env.NODE_ENV;module.exports = &#123; // 基本路径配置 publicPath: &apos;./&apos;, // 显式转义依赖 transpileDependencies: [&apos;webpack-dev-server/client&apos;], // 配置less css: &#123; loaderOptions: &#123; less: &#123; javascriptEnabled: true, &#125; &#125; &#125;, configureWebpack: (config) =&gt; &#123; if (env !== &apos;development&apos; || env !== &apos;test&apos;) &#123; config.plugins.push(new CompressionWebpackPlugin(&#123; algorithm: &apos;gzip&apos;, test: new RegExp(`\\.($&#123;productionGzipExtensions.join(&apos;|&apos;)&#125;)$`), threshold: 10240, minRatio: 0.8, &#125;)); config.plugins.push( new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_debugger: true, // 注释console drop_console: true, pure_funcs:[&apos;console.log&apos;] // 移除console &#125;, &#125;, sourceMap: false, parallel: true, &#125;), ); &#125; &#125;, chainWebpack: config =&gt; &#123; // 指定入口 es6转es5 config.entry.app = [&apos;babel-polyfill&apos;, &apos;./src/main.js&apos;]; // 修复HMR config.resolve.symlinks(true); // //修复 Lazy loading routes Error // config.plugin(&apos;html&apos;).tap(args =&gt; &#123; // args[0].chunksSortMode = &apos;none&apos;; // return args; // &#125;); // 添加别名 config.resolve.alias .set(&apos;@&apos;, resolve(&apos;src&apos;)) .set(&apos;assets&apos;, resolve(&apos;src/assets&apos;)) .set(&apos;static&apos;, resolve(&apos;src/static&apos;)); // //压缩图片 // config.module // .rule(&quot;images&quot;) // .use(&quot;image-webpack-loader&quot;) // .loader(&quot;image-webpack-loader&quot;) // .options(&#123; // mozjpeg: &#123;progressive: true, quality: 65&#125;, // optipng: &#123;enabled: false&#125;, // pngquant: &#123;quality: &quot;65-90&quot;, speed: 4&#125;, // gifsicle: &#123;interlaced: false&#125;, // webp: &#123;quality: 75&#125; // &#125;); // // 打包分析 // if (process.env.IS_ANALYZ) &#123; // config.plugin(&apos;webpack-report&apos;) // .use(BundleAnalyzerPlugin, [&#123; // analyzerMode: &apos;static&apos;, // &#125;]); // &#125; &#125;, // 是否使用包含运行时编译器的 Vue 构建版本 // runtimeCompiler: true, // 去除打包.map后缀文件 // productionSourceMap: false, // devServer: &#123;//跨域 // port: 8080,// 端口号 // open: true, //配置自动启动浏览器 // proxy: &#123;// 配置跨域处理 可以设置多个 // &apos;/api&apos;: &#123; // target: &apos;&apos;, // ws: true, // changeOrigin: true // &#125;, // &#125; // &#125;&#125; babel.config.js123456789101112131415161718192021222324252627282930// 打包时删除consoleconst plugins = [];if ([&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV)) &#123; plugins.push(&quot;transform-remove-console&quot;)&#125;module.exports = &#123; presets: [ [ &apos;@vue/app&apos;, &#123; &quot;useBuiltIns&quot;: &quot;entry&quot;, polyfills: [ &apos;es6.promise&apos;, &apos;es6.symbol&apos; ] &#125; ] ], // 配置babel-plugin-import, 用于按需加载组件代码和样式 plugins: [ [ &quot;import&quot;, &#123; libraryName: &quot;ant-design-vue&quot;, libraryDirectory: &quot;es&quot;, style: true &#125; ] ],&#125; .babelrc123456&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;], &quot;plugins&quot;: [ &quot;@babel/plugin-transform-runtime&quot; ]&#125; main.js123456789101112131415161718192021222324import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;import router from &apos;./router&apos;import store from &apos;./store&apos;// 解决ie白屏问题import &apos;@babel/polyfill&apos;import Es6Promise from &apos;es6-promise&apos;Es6Promise.polyfill()// 使用antd-vue Button组件import &#123; Button &#125; from &apos;ant-design-vue&apos;// Button组件Vue.component(Button.name, Button);Vue.config.productionTip = falsenew Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&apos;#app&apos;)]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3.x及相关配置]]></title>
    <url>%2F2019%2F05%2F05%2Fvue-cli3-x%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[vue-cli 3.x1.安装123npm install -g @vue/cli# ORyarn global add @vue/cli 2.环境(windows)1234567891011E:\stydy&gt;node -vv8.12.0E:\stydy&gt;webpack -v4.29.6E:\stydy&gt;npm -v6.4.1E:\stydy&gt;vue -V3.7.0 3.创建项目我在此处想使用ant-design-vue，所以创建了一个antd的项目：1vue create antd 4.项目配置我选择的项目配置如下：12345678Vue CLI v3.7.0? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors? Use history mode for router? (Requires proper server setup for index fallback in production) Yes? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Less? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files? Save this as a preset for future projects? No? Pick the package manager to use when installing dependencies: NPM 5.运行依赖安装完成后，cd到该项目路径下，运行：1234567891011$ cd antd $ npm run serveDONE Compiled successfully in 4229ms App running at: - Local: http://localhost:8080/ - Network: http://192.168.100.111:8080/ Note that the development build is not optimized. To create a production build, run npm run build. 此时浏览器会访问 http://localhost:8080/ ，看到 Welcome to Your Vue.js App 的界面就算成功了。 6.目录结构12345678910111213141516├── README.md├── babel.config├── package.json├── package-lock.json├── postcss.config.js├── public│ ├── favicon.ico│ └── index.html├── src│ ├── assets│ │ └── logo.png│ ├── components│ │ └── HelloWorld.vue│ ├── App.vue│ └── main.js└── .gitignore 使用ant-design-vue由于在实际开发工程中，加载全部样式/组件会影响前端性能，因此我们直接采取按需加载组件及样式。 1.安装123npm install ant-design-vue --save-devnpm install less less-loader --save-dev 2.引入src/main.js123// 以 Button 组件为例import &#123; Button &#125; from &apos;ant-design-vue&apos;Vue.component(Button.name, Button); 3.组件使用12345&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;a-button type=&quot;danger&quot;&gt;Danger&lt;/a-button&gt; &lt;/div&gt;&lt;/template&gt; 4.babel-plugin-import4.1安装1npm install babel-plugin-import --save-dev 4.2修改babel.config.js123456789101112module.exports = &#123; presets: [ &apos;@vue/app&apos;, ], // 配置babel-plugin-import, 用于按需加载组件代码和样式 plugins: [ [ &quot;import&quot;, &#123; libraryName: &quot;ant-design-vue&quot;, libraryDirectory: &quot;es&quot;, style: true &#125; ] ],&#125; 4.3报错解决方案此时重启项目，会遇到报错情况。以下两种方案任选其一即可。两种方案： 配置vue.config.js在根目录下新建vue.config.js： 12345678910module.exports = &#123; // 配置less css: &#123; loaderOptions: &#123; less: &#123; javascriptEnabled: true, &#125; &#125; &#125;,&#125; 修改babel.config.js 1234567// ...plugins: [ [ &quot;import&quot;, &#123; libraryName: &quot;ant-design-vue&quot;, libraryDirectory: &quot;es&quot;, style: &apos;css&apos; &#125; ]] 4.4完成保存，重启项目：1npm run serve 可以看到，antd 组件的 js 和 css代码都会按需加载。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《复联4之终局之战》随笔]]></title>
    <url>%2F2019%2F05%2F02%2F%E3%80%8A%E5%A4%8D%E8%81%944%E4%B9%8B%E7%BB%88%E5%B1%80%E4%B9%8B%E6%88%98%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;复仇者联盟4：终局之战（Avengers: Endgame）是安东尼·罗素和乔·罗素执导的美国科幻电影，改编自美国漫威漫画，漫威电影宇宙（Marvel Cinematic Universe，缩写为MCU）第22部影片，由小罗伯特·唐尼、克里斯·埃文斯、克里斯·海姆斯沃斯、马克·鲁法洛、斯嘉丽·约翰逊、杰瑞米·雷纳、保罗·路德、布丽·拉尔森、唐·钱德尔、凯伦·吉兰、乔什·布洛林等主演。 ###]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>电影</tag>
        <tag>复仇者联盟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js模拟信号灯]]></title>
    <url>%2F2019%2F04%2F29%2Fjs%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E7%81%AF%2F</url>
    <content type="text"><![CDATA[效果图 需求给出一个div元素块，模拟一个如下条件的交通信号灯： 绿灯亮x毫秒，转黄灯 黄灯亮y毫秒，转红灯 红灯亮z毫秒，转绿灯 无限循环执行 需求分析&emsp;&emsp;首先，div元素块设置css变圆；其次，每隔一定时间，转换元素块背景色；接着，控制显示时长；然后，将上两步组合；最后，无限循环执行。 应用技术栈 css border-radius background js setTimeout Promise async/await while 技术栈分析 类别 技术 用途 样式 border-radius 元素形状 样式 background 元素背景色 脚本 setTimeout 定时器 脚本 Promise 处理回调 脚本 async/await 配合使用 脚本 while 循环 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// html&lt;div id=&quot;signal-lamp&quot;&gt;&lt;/div&gt;&lt;button class=&quot;btn&quot; onclick=&quot;run()&quot;&gt;执行&lt;/button&gt;&lt;span id=&quot;showText&quot;&gt;&lt;/span&gt;// css#signal-lamp &#123; width: 100px; height: 100px; border-radius: 50%; border: 1px solid #ffcecc;&#125;// js// 定义函数sleepfunction sleep(ms)&#123; // 返回一个Promise实例 return new Promise(function(resolve)&#123; setTimeout(resolve, ms); &#125;)&#125;// 改变颜色 等待参数时间 （时间及颜色均为参数）async function ChangeColor(ms, color)&#123; // 改变颜色 document.getElementById(&quot;signal-lamp&quot;).style.background = color; // 打印出显示时间 document.getElementById(&quot;showText&quot;).innerText = `$&#123;color&#125;:显示$&#123;ms&#125;ms`; // 睡眠ms毫秒 await sleep(ms);&#125;// 循环依次执行async function run()&#123; // while 循环 while (true) &#123; // 绿灯 1.8s await ChangeColor(1800,&quot;green&quot;); // 黄灯 0.8s await ChangeColor(800, &quot;yellow&quot;); // 红灯 1.2s await ChangeColor(1200, &quot;red&quot;); &#125;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Promise</tag>
        <tag>信号灯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js执行——Promise]]></title>
    <url>%2F2019%2F04%2F28%2Fjs%E6%89%A7%E8%A1%8C%E2%80%94%E2%80%94Promise%2F</url>
    <content type="text"><![CDATA[Promise Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理且更强大。它最早由社区提出并实现，ES6将其写进了语言标准，统一了用法，并原生提供了Promise对象。 特点 对象的状态不受外界影响 （3种状态） Pending状态（进行中） Fulfilled状态（已成功） Rejected状态（已失败） 一旦状态改变就不会再变 （两种状态改变：成功或失败） Pending -&gt; Fulfilled Pending -&gt; Rejected 用法创建Promise实例123456789var promise = new Promise(function(resolve, reject)&#123; // ... some code if (/* 异步操作成功 */) &#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;) &emsp;&emsp;Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。&emsp;&emsp;resolve作用是将Promise对象状态由“未完成”变为“成功”，也就是Pending -&gt; Fulfilled，在异步操作成功时调用，并将异步操作的结果作为参数传递出去；而reject函数则是将Promise对象状态由“未完成”变为“失败”，也就是Pending -&gt; Rejected，在异步操作失败时调用，并将异步操作的结果作为参数传递出去。 then&emsp;&emsp;Promise实例生成后，可用then方法分别指定两种状态回调参数。then 方法可以接受两个回调函数作为参数： Promise对象状态改为Resolved时调用 （必选） Promise对象状态改为Rejected时调用 （可选） 基本用法示例123456function sleep(ms) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(resolve, ms); &#125;)&#125;sleep(500).then( ()=&gt; console.log(&quot;finished&quot;)); &emsp;&emsp;这段代码定义了一个函数sleep，调用后，等待了指定参数(500)毫秒后执行then中的函数。值得注意的是，Promise新建后就会立即执行。 执行顺序&emsp;&emsp;接下来我们探究一下它的执行顺序，看以下代码：12345678910let promise = new Promise(function(resolve, reject)&#123; console.log(&quot;AAA&quot;); resolve()&#125;);promise.then(() =&gt; console.log(&quot;BBB&quot;));console.log(&quot;CCC&quot;)// AAA// CCC// BBB &emsp;&emsp;执行后，我们发现输出顺序总是 AAA -&gt; CCC -&gt; BBB。表明，在Promise新建后会立即执行，所以首先输出 AAA。然后，then方法指定的回调函数将在当前脚本所有同步任务执行完后才会执行，所以BBB 最后输出。 与定时器混用&emsp;&emsp;首先看一个实例：123456789101112let promise = new Promise(function(resolve, reject)&#123; console.log(&quot;1&quot;); resolve();&#125;);setTimeout(()=&gt;console.log(&quot;2&quot;), 0);promise.then(() =&gt; console.log(&quot;3&quot;));console.log(&quot;4&quot;);// 1// 4// 3// 2 &emsp;&emsp;可以看到，结果输出顺序总是：1 -&gt; 4 -&gt; 3 -&gt; 2。1与4的顺序不必再说，而2与3先输出Promise的then，而后输出定时器任务。原因则是Promise属于JavaScript引擎内部任务，而setTimeout则是浏览器API，而引擎内部任务优先级高于浏览器API任务，所以有此结果。 拓展 async/awaitasync&emsp;&emsp;顾名思义，异步。async函数对 Generator 函数的改进，async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。特点体现在以下四点： 内置执行器 更好的语义 更广的适用性 返回值是 Promise await&emsp;&emsp;顾名思义，等待。正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象。 混合使用&emsp;&emsp;先看示例：123456789101112131415function sleep(ms) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(resolve,ms); &#125;)&#125;async function handle()&#123; console.log(&quot;AAA&quot;) await sleep(5000) console.log(&quot;BBB&quot;)&#125;handle();// AAA// BBB (5000ms后) &emsp;&emsp;我们定义函数sleep，返回一个Promise。然后在handle函数前加上async关键词，这样就定义了一个async函数。在该函数中，利用await来等待一个Promise。 Promise优缺点 优点 缺点 解决回调 无法监测进行状态 链式调用 新建立即执行且无法取消 减少嵌套 内部错误无法抛出]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Promise</tag>
        <tag>es6</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue吸顶效果]]></title>
    <url>%2F2019%2F04%2F26%2Fvue%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[关于吸顶 吸顶效果在使得用户在滑动读取数据的时候把产品需要持续展示的控件及信息一直固定在屏幕上方，以便用户操作和交互。 产生背景&emsp;&emsp;随着技术不断更新与用户审美不断提升，一些App中/浏览器中的常用交互也在对用户更加友好，在某些数据展示较多页面或者导航栏页面，为了将栏目划分，使得视图模块更加明显，吸顶效果便在此背景下孕育而生。&emsp;&emsp;那么，我们如何在web端来做一个吸顶效果呢？ 切入正题——吸顶简单效果展示 需求分析 有了效果图，首先我们要分析一下结构： 吸顶上方数据 需要吸顶的元素 吸顶下方数据 接着我们逻辑走一下：(我们设吸顶元素为X) 在页面滑动距离 &lt;= 吸顶元素距离顶端距离时，不吸顶 否则，吸顶 有了这个大前提，继续考虑，如何做到吸顶呢？ 设置该元素的position为fixed属性 动态控制是否展示该样式 扩展：加点动画效果(这里以渐变为示例) 代码及注释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// html&lt;template&gt; &lt;div class=&quot;scrollFixed&quot;&gt; &lt;!-- 上方数据 --&gt; &lt;div class=&quot;sTop&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(ietm, index) in 10&quot;&gt;这是吸顶上方的第&#123;&#123;index + 1&#125;&#125;条数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 吸顶元素 --&gt; &lt;nav class=&quot;nav&quot; id=&quot;searchBar&quot; :class=&quot;scrollFixed === true ? &apos;isFixed&apos; :&apos;&apos;&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/nav&gt; &lt;!-- 下方数据 --&gt; &lt;div class=&quot;sBottom&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(ietm, index) in 30&quot;&gt;这是吸顶下方的第&#123;&#123;index + 1&#125;&#125;条数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;// js&lt;script&gt; export default &#123; data() &#123; return &#123; text: &apos;需要吸顶&apos;, scrollFixed: false, offsetTop: 0 &#125; &#125;, methods: &#123; windowScroll () &#123; // 滚动条顶部 距 滚动原点的高度 let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; /** * 三目运算 * 两个高度比较 * 如果滑动距离 &gt; 吸顶元素到页面顶端距离 动态添加 */ scrollTop &gt;= this.offsetTop ? (this.scrollFixed = true, this.text = &apos;已吸顶&apos;) : (this.scrollFixed = false, this.text = &apos;需要吸顶&apos;); &#125; &#125;, mounted() &#123; // 需吸顶元素 距 离浏览器顶端的高度 this.offsetTop = document.querySelector(&apos;#searchBar&apos;).offsetTop; // 滚动监听 window.addEventListener(&apos;scroll&apos;, this.windowScroll); &#125;, destroyed () &#123; // 关闭 销毁监听 window.removeEventListener(&apos;scroll&apos;, this.windowScroll); &#125; &#125;&lt;/script&gt;&lt;style scoped type=&quot;text/scss&quot; lang=&quot;scss&quot;&gt;.isFixed&#123; position:fixed; top:0; left: 0; z-index:999; background: #12d168; transition: all 1s; color: #7511ff;&#125;// 基本样式略// ......&lt;/style&gt; 备注&emsp;&emsp;此demo在流行浏览器中运行问题不大，但是没有详测兼容性。如果要在生产上运用，务必做好各端兼容。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>吸顶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[v-html指令渲染出的内容如何添加样式]]></title>
    <url>%2F2019%2F04%2F22%2Fv-html%E6%8C%87%E4%BB%A4%E6%B8%B2%E6%9F%93%E5%87%BA%E7%9A%84%E5%86%85%E5%AE%B9%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[关于v-html&emsp;&emsp;在vue使用中，指令v-html渲染页面经常用到，类似于jQuery的$(‘x’).html()去渲染。通过指令v-html渲染出来的内容还会带有原来的标签及其样式，如果需要修改或者重设其样式，应该如何去做吗？ 采坑&emsp;&emsp;首先，我在style中用子级选择器去选中并修改样式，经过猛如虎的操作后，并没生效。F12打开Elements调试，发现在style里面样式根本没加载上去，没有class中也没有类名出现。除此之外，渲染非该指令元素时，所有的类名会跟有[data-v-xxxxxx]的东西。 爬坑解决方案现给出3中方案来解决此问题： 去掉style中的scoped; watch监测数据变化; 深度选择器&gt;&gt;&gt; 方案1实践 去掉style中的scoped &emsp;&emsp;在vue组件中，我们写style时，为了防止页面样式冲突，在每个组件中会加上scoped属性。经测试，去掉该属性即可渲染样式成功。但是在组件过多或者项目中大时，经常会出现页面样式冲突，因此该方法不建议使用。 方案2实践 watch监测数据变化 &emsp;&emsp;在script &gt; export default中,watch属性可监听v-html所绑定值的变化。如果是后台请求的数据，那么可以在watch中监听改数据变化，当数据发生改变驱动视图后，动态绑定一个class来改变子级元素样式。此方法有一定局限性。 方案3实践 深度选择器 &gt;&gt;&gt; &emsp;&emsp;此时，深度选择器的应用则脱颖而出。深度选择器&gt;&gt;&gt;，可深度改变子级样式。例：12345678910111213&lt;template&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;// ***&lt;/script&gt;&lt;style scoped&gt; .test &gt;&gt;&gt; *&#123; width: 100%; &#125;&lt;/style&gt; &emsp;&emsp;如果使用scss或者less等css扩展语言，则用/deep/替代：1234567&lt;style scoped type=&quot;text/scss&quot; lang=&quot;scss&quot;&gt; .test&#123; /deep/ *&#123; width: 100%; &#125; &#125;&lt;/style&gt; tips&emsp;&emsp;scoped属性导致css仅对当前组件生效，而html绑定渲染出的内容可以理解为是子组件的内容，一般情况下子组件不会被加上对应的属性，所以不会应用带有scoped的css。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>样式渲染</tag>
        <tag>v-html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue嵌套路由]]></title>
    <url>%2F2019%2F04%2F20%2Fvue%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[关于嵌套路由&emsp;&emsp;在实际项目中，多个前端页面由于需求而通常由多层嵌套的组件组合而成,尤其是多导航界面。此时，路由嵌套(vue-router)的优点则表现了出来。嵌套路由就是在一个被路由过来的页面下，可以继续使用路由来加载新的组件。所谓嵌套，也可以理解成父子路由。 应用场景 各样式导航栏切换； 标签/选项卡切换； 案例&emsp;&emsp;此处以常用布局F形导航当作分析案例： 1.效果 2.解析12345678/App/about/blog /App/about/msg +------------------+ +-----------------+| about | | about || +--------------+ | | +-------------+ || | blog | | +------------&gt; | | msg | || | | | | | | || +--------------+ | | +-------------+ |+------------------+ +-----------------+ 3.目录拆分观察效果图，容易得出可将图拆分为多个组件。在主要vue中挂载首页和关于组件，然后在关于组件中再次挂载子路由博客和信息组件。项目中src目录拆分如下：1234567891011├── src │ ├── page │ │ ├── index.vue // 主页组件│ │ ├── about.vue // 关于组件│ │ ├── about │ │ │ ├── blog.vue // 博客子组件│ │ │ ├── msg.vue // 信息子组件│ ├── router │ │ ├── index.js │ ├── App.vue │ ├── main.js 4.通用代码从目录中可以轻易的看出每个组件及所代表的模块。其中，index &amp; blog &amp; msg 三个组件均为一个带文字描述的块级元素，此处给出一个示例，不再赘述。12345&lt;template&gt; &lt;div&gt; 这是xx模块内容 &lt;/div&gt;&lt;/template&gt; 5.路由管理router/index.js进行路由管理，代码如下。此处使用懒加载模式处理。开篇已经描述，嵌套路由可以理解为父子路由，不仅如此描述，事实上我们在做路由管理也是这么处理的。注：在children中的path不必再添加/，否则会出错。123456789101112131415161718192021222324252627import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;Vue.use(VueRouter)export default new VueRouter(&#123; routes: [ &#123; path: &apos;/index&apos;, component: resolve =&gt; require([&apos;@/page/index&apos;],resolve), &#125;, &#123; path: &apos;/about&apos;, component: resolve =&gt; require([&apos;@/page/about&apos;],resolve), children: [ &#123; path: &apos;blog&apos;, component: resolve =&gt; require([&apos;@/page/about/blog&apos;],resolve), &#125;, &#123; path: &apos;msg&apos;, component: resolve =&gt; require([&apos;@/page/about/msg&apos;],resolve), &#125; ] &#125;, ]&#125;) 6.根组件配置App.vue需要挂载首页组件和关于组件。值得一提的是，由于在点击关于的时候，应该直接跳往第一项子级项，也就是博客，因此注意路由路径。此外，切记to:”[路径]” 中的[路径]一定要加上/，否则多次路由会出现路由重复而无法正确找到路由问题。123456789101112131415161718192021&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;router-link to=&quot;/index&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/about/blog&quot;&gt;关于&lt;/router-link&gt; &lt;/header&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;App&apos;, &#125;&lt;/script&gt;&lt;style type=&quot;text/scss&quot; lang=&quot;scss&quot;&gt; /*略*/&lt;/stylle&gt; 7.about组件配置所谓嵌套，或者说父子路由，在此组件表现出来，也就是将此组件当成父组件，再次挂载两个(或多个)子组件。同样，要注意路径一定要加上/。如下：12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div class=&quot;about&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;router-link to=&quot;/about/blog&quot;&gt;博客&lt;/router-link&gt; &lt;router-link to=&quot;/about/msg&quot;&gt;信息&lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;about&quot; &#125;&lt;/script&gt;&lt;style scoped type=&quot;text/scss&quot; lang=&quot;scss&quot;&gt; .about&#123; display: flex; .left&#123; width: 100px; border-right: 1px solid #aaa; height: calc(100vh - 46px); display: flex; flex-direction: column; a&#123; line-height: 40px; text-align: center; font-size: 12px; text-decoration: none; color: #6260ff; &#125; &#125; .right&#123; flex: 1; &#125; &#125;&lt;/style&gt; 8.完成其实步骤就这么多，不过在实际项目中还是要多加动脑灵活运用，理解嵌套路由含义及路由配置规则，一切就会变得简单起来~ 注&emsp;&emsp;有几点注意事项，包括上面也有提到过： 子路由要写在children下； router-link 中，to中的路径要加/，代表根路径； 每一个子路由都可以嵌套多个组件； style中加入scoped属性，防止样式互相干扰。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios全局拦截器配置]]></title>
    <url>%2F2019%2F04%2F17%2Faxios%E5%85%A8%E5%B1%80%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于请求拦截器&emsp;&emsp;项目中，我们经常遇到请求后台接口时要做后天返回的code码验证判断。code码通常是一个特定的数值，比如一般返回200作为正常请求，返回其他作为数据异常或者请求异常等。如果接口量足够大，那么每一个接口都需要做正常/异常处理。为满足统一管理，那么在全局请求拦截器便应劫而出。 作用 统一管理 路由请求拦截 =&gt; request 路由响应拦截 =&gt; response 实例1.安装axios及qs123npm install axios --save-dev //安装axiosnpm install qs --save-dev //安装qs 2.新建一个js文件123456789101112131415161718192021├── project │ ├── build │ ├── config│ ├── node_modules │ ├── src │ │ ├── assets │ │ │ ├── request.js // 我在这里新建了一个js文件来配置拦截器│ │ ├── components │ │ ├── router │ │ ├── App.vue │ │ ├── main.js │ ├── static │ ├── test │ ├── .babelrc │ ├── .editorconfig │ ├── .gitignore │ ├── .postcssrc.js │ ├── index.html │ ├── package-lock.json │ ├── package.json │ ├── README.md 3.js拦截器配置如下：123456789101112131415161718192021222324252627282930313233343536import axios from &apos;axios&apos; //引入axiosimport qs from &apos;qs&apos; //引入qs qs可将数据转换为FormData格式// axios默认配置axios.defaults.timeout = 10000; // 超时时间axios.defaults.baseURL = &apos;https://www.demo.com&apos;; // 公用地址// 路由请求拦截// http request 拦截器axios.interceptors.request.use((config) =&gt; &#123; // 数据格式化 config.data = qs.stringify(config.data); // 给请求头加键值对 config.headers[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; return config;&#125;, (error ) =&gt; &#123; // 错误信息 return Promise.reject(error.response);&#125;);// 路由响应拦截// http response 拦截器axios.interceptors.response.use( (response) =&gt; &#123; if (response.data.code !== 200) &#123; // 异常请求要做的事 &#125; else &#123; // 正常请求要做的事 &#125; &#125;,(error) =&gt; &#123; // 返回接口返回的错误信息 return Promise.reject(error.response) &#125;);export default axios; 4.main.js配置12345// 引入该配置文件import axios from &apos;./assets/axiosRequest&apos;// 注册到全局Vue.prototype.$axios = axios; 5.使用1234567891011121314// 要发送的数据let params = &#123; name: &apos;AAA&apos;, number: &apos;10100110&apos;, age: &apos;18&apos;&#125;;// post请求为例 url不用写公共部分，直接写后面即可this.$axios.post(&apos;/test&apos;,params).then((res) =&gt; &#123; debugger;&#125;).catch((error) =&gt; &#123; debugger;&#125;) 总结&emsp;&emsp;http全局拦截器配置完毕，不仅可在response中统一管理返回状态，而且可在request中动态添加request headers，在实际项目中有很大的运用空间。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue之data中数组改变如何驱动视图]]></title>
    <url>%2F2019%2F04%2F09%2Fvue%E4%B9%8Bdata%E4%B8%AD%E6%95%B0%E7%BB%84%E6%94%B9%E5%8F%98%E5%A6%82%E4%BD%95%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;熟悉vue的小伙伴们都知道vue属于MVVM框架，数据可以驱动视图。一般来说，vue中的data发生变化，视图中绑定的data值也会随之发生变化。然而还是有特殊情况的，例如关于数组|对象的某些操作。&emsp;&emsp;根据官方文档定义： 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。 问题&emsp;&emsp;例：data中有一对象数组arr，如下：123456789101112131415161718192021222324252627282930313233343536// html&lt;ul&gt; &lt;li v-for=&quot;(item, index) in arr&quot;&gt; &#123;&#123; index + 1 &#125;&#125; - &#123;&#123; item &#125;&#125; &lt;button @click=&quot;change(index)&quot;&gt;change&lt;/button&gt; &lt;/li&gt;&lt;/ul&gt;// jsdata: &#123; arr: [ &#123; id: 0, son: [ &#123; name: &apos;son1&apos; &#125;, &#123; name: &apos;son2&apos; &#125; ] &#125;, &#123; id: 1, son: [ &#123; name: &apos;son1&apos; &#125;, &#123; name: &apos;son2&apos; &#125; ] &#125; ],&#125; &emsp;&emsp;在将数据绑定到视图中以后，点击change将当前点击的数组子项添加了一个id：12345678// ...methods: &#123; change (index) &#123; this.arr[index].son.forEach((item, index) =&gt; &#123; item.id = index + 1; &#125;); &#125;,&#125; &emsp;&emsp;点击之后，data中的arr数组发生了改变，按理说即将出现的效果应是数据更新后的视图，但是惊讶的发现视图并没有改变。那么如何解决此问题呢？ 解决方案&emsp;&emsp;使用Vue.set可得到解决。 this.$set(this.data, index, obj)// this.data: 要改变的数据// index: 下标// obj: 修改后的对象 &emsp;&emsp;如刚才所举之例，解决如下：123456change (index) &#123; this.arr[index].son.forEach((item, index) =&gt; &#123; item.id = index + 1; this.$set(this.arr[index].son, index, item); &#125;);&#125;, &emsp;&emsp;此时，点击change按钮，则视图实时改变。&emsp;&emsp;问题得以解决。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目搭建及基本配置]]></title>
    <url>%2F2019%2F03%2F27%2Fvue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言注：适用于windows系统本文讲述要点： vue-cli项目搭建基本环境配置； 常用插件描述及分享； 项目运行、调试及打包； 项目配置及优化； 适用人群： vue小白； 有html\css\js编程基础； vue项目整体优化（打包后压缩空间）； 一、准备阶段准备阶段会将项目环境配置完毕,包含node、npm、webpack和vue-cli。已经完成的小伙伴可以跳过此步骤看第二阶段。 1.安装node及npm&emsp;&emsp;从node.js中文网下载并安装nodejs点击下载.msi的32/64位安装包，然后双击本地文件一路点击下一步完成nodeJs的安装即可。注意安装8.10以上版本哟!安装完成后，打开命令行工具，输入node -v，如下：12E:\&gt;node -vv8.12.0 //版本号 顺便在此处继续输入npm -v12E:\&gt;npm -v6.4.1 //版本号 你会惊讶的发现npm已经神奇的安装完成了。这是因为npm在安装nodeJs的时候顺带已经装好了。 2.安装webpack注：以下所有npm操作，由于国内速度较慢甚至出现失败，可用淘宝镜像cnpm替代。下列所有npm命令，用cnpm替代即可。方式如下：1npm install -g cnpm --registry=https://registry.npm.taobao.org &emsp;&emsp;继续刚才的命令行工具，输入npm install webpack -g，-g代表全局安装。安装完成后继续输入webpack -v，出现相应版本号，代表安装成功。我在安装时出现如下状况：12345One CLI for webpack must be installed. These are recommended choices, delivered as separate packages: - webpack-cli (https://github.com/webpack/webpack-cli) The original webpack full-featured CLI.We will use &quot;npm&quot; to install the CLI via &quot;npm install -D&quot;.Do you want to install &apos;webpack-cli&apos; (yes/no): 解决方案是：输入npm install webpack-cli -g。安装成功后执行webpack -v查看版本号，如下：12345678910E:\&gt;npm install webpack-cli -g** 安* 装 省* 过 略* 程*E:\&gt;webpack -v4.29.6 //版本号 3.安装vue脚手架vue-cli&emsp;&emsp;继续上面的命令行工具。接下来就是安装配置今天的主角了，vue脚手架工具vue-cli。方法一样，键入命令行npm install vue-cli -g全局安装，然后输入vue -V注：是大写的-V检测是否安装成功。如下：12E:\&gt;vue -V2.9.6 //版本号 4.小结&emsp;&emsp;至此，我们已经完成了准备阶段的工作。主要完成的是node、npm、webpack和vue-cli四个工具的环境配置。目前为止，我们在命令行工具的总结应该是如下：版本号不必一致1234567891011E:\&gt;node -vv8.12.0E:\&gt;npm -v6.4.1E:\&gt;webpack -v4.29.6E:\&gt;vue -V2.9.6 二、项目搭建本阶段讲述vue-cli项目搭建及相关配置，包含创建项目、修改基础配置、项目运行三个模块，可自行选择阅读或跳过。 1.项目创建&emsp;&emsp;建立一个空文件夹，最好以纯英文命名。例，我项目路径为E&gt;stydy。打开命令行工具，cd到该文件目录下，执行vue init webpack name，name可替换为你要创建的项目名。回车之后，会要求输入一系列的信息，大部分可直接回车略过，注释如下，没有注释的回车略过即可：1234567891011121314E:\stydy&gt;vue init webpack blog? Project name blog //项目名? Project description A Vue.js project //项目简介? Author xuan0146 &lt;zxm0146@163.com&gt; //作者? Vue build runtime? Install vue-router? Yes //使用项目路由? Use ESLint to lint your code? No //不开启ESLint语法检测 注意选No? Set up unit tests Yes? Pick a test runner jest? Setup e2e tests with Nightwatch? Yes? Should we run `npm install` for you after the project has been created? (recommended) npm vue-cli · Generated &quot;blog&quot;. 最后一步选择npm或者yarn则会自动执行npm install安装项目所有依赖包。不选择的话，自己安装也是同样效果。安装步骤为： cd到项目路径； 执行npm install； 等待完成安装即可; 2.项目介绍&emsp;&emsp;cd到该项目，或者打开文件夹，项目目录及备注如下：1234567891011121314151617181920212223242526272829303132├── project //项目目录│ ├── build //webpack相关配置│ │ ├── build.js //生产环境构建│ │ ├── check-versions.js //版本检查│ │ ├── utils.js //构建相关工具│ │ ├── vue-loader.conf.js //处理vue文件的配置信息│ │ ├── webpack.base.conf.js //webpack基础配置│ │ ├── webpack.dev.conf.js //webpack开发环境配置│ │ ├── webpack.prod.conf.js //webpack生产环境配置│ ├── config //vue基本配置│ │ ├── dev.env.js //开发环境配置│ │ ├── index.js //主要配置│ │ ├── prod.env.js //生产环境配置│ │ ├── test.env.js //测试环境配置│ ├── node_modules //依赖包 忽略│ ├── src //项目核心文件│ │ ├── assets //静态资源 如公用js\css\image\媒体资源等│ │ ├── components //公用组件│ │ ├── router //项目路由│ │ │ ├── index.js //路由控制文件│ │ ├── App.vue //根组件│ │ ├── main.js //入口文件│ ├── static //静态资源│ ├── test //模拟测试│ ├── .babelrc //babel参数│ ├── .editorconfig //代码格式│ ├── .gitignore //git上传相关配置│ ├── .postcssrc.js //css相关工具│ ├── index.html //主页│ ├── package-lock.json //记录当前状态下实际安装的各个npm package的具体来源和版本号│ ├── package.json //项目信息│ ├── README.md //项目说明 3.启动项目&emsp;&emsp;命令行工具键入npm run dev，等待片刻，直到提示如下，则表示启动成功：1234567E:\stydy\blog&gt;npm run dev* * * * * * * ** 启动过程忽略 ** * * * * * * *Your application is running here: http://localhost:8080 然后复制http://localhost:8080，在浏览器地址栏输入该url，进入如下页面： 4.移动端调试&emsp;&emsp;有的人可能要问了，如果我做移动端项目，不能用localhost去访问了吧？当然不能，只需要稍微改一下配置即可。当然，端口号8080一样可以修改，不过一般不做变动。&emsp;&emsp;用代码工具（自己习惯的IDE）打开本项目。首先查看本机电脑ip,键入命令ipconfig，查看如下：1234567891011E:\stydy\blog&gt;ipconfig* ** *以太网适配器 以太网: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::da7:800d:d148:e06%10 IPv4 地址 . . . . . . . . . . . . : 192.168.200.127 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : fe80::48:5112:9520:564f%10 192.168.200.1 &emsp;&emsp;其中，IPv4 地址即为我们所需要的ip。在项目/config/index.js中，找到host: &#39;localhost&#39;，改成IPv4 地址，例:我的地址为192.168.200.127:123456module.exports = &#123; dev: &#123; host: &apos;192.168.200.127&apos;, //localhost改为ip port: 8080, //端口号 &#125;&#125; &emsp;&emsp;然后，我们重新启动项目。注意上次项目启动后，由于修改了配置文件，因此需要停止项目然后重新启动。停止项目的命令为Ctrl + C。重启项目后，如下：12345E:\stydy\blog&gt;npm run dev* * * * * * * ** 启 动 过 程 ** * * * * * * *Your application is running here: http://192.168.200.127:8080 &emsp;&emsp;注意要在同一网络下&emsp;&emsp;最后，我们复制该地址，即可在所有端PC、手机、pad等查看该项目啦~ 三、常用插件本章节记录一些vue常用插件，如axios、echarts、sass/scss、lib-flexible等等。所有命令均可用cnpm替代。如不需要可直接跳过。 1.sacc/scss用途：可用sass/scss进行css书写代码。命令行工具依次键入如下命令：12npm install node-sass --save-devnpm install sass-loader --save-dev 安装完成后，.vue里的style里添加lang=&quot;scss&quot;来指定语言，即可用sass/scss编写css代码。如下：123&lt;style lang=&quot;scss&quot; scoped&gt;...&lt;/style&gt; 2.axios用途：平时前后端交互使用Ajax，在vue官方，给出vue-resource和axios的作为ajax的替代。在此处使用vue官方推荐首选的axios作为案例讲述。 安装 1npm install axios 全局引入在项目/src/main.js中引入如下代码，然后随意走个请求，发现……报错？并且在页面F12控制台Newwork&gt;Headers里面发现数据并没有Form Data形式提交，如何处理呢？见下一步解决。 1import axios from &apos;axios&apos; 解决数据格式问题 1234567891011121314151617181920212223242526272829//完整请求代码 post为例this.$axios.post(&apos;url&apos;, &#123; //路径 key1: &apos;value&apos;, //参数 key2: &apos;value&apos; //参数&#125;, /* ** 添加如下代码* * * * * * start * * * * * &#123; transformRequest: [function (data) &#123; let ret = &apos;&apos;; for (let it in data) &#123; ret += encodeURIComponent(it) + &apos;=&apos; + encodeURIComponent(data[it]) + &apos;&amp;&apos;; &#125; return ret &#125; ], headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;&#125;/* * * * * * end * * * * *).then((response) =&gt; &#123; //返回数据 console.log(response)&#125;).catch((error) =&gt; &#123; //请求异常捕捉 console.log(error)&#125;) 3.axios解决方案&emsp;&emsp;另外一个axios数据格式问题的解决方案。 重磅推荐★★★★★此方案不仅解决数据格式问题，还顺便解决了跨域问题。第一步当然还是安装axios，同上一步。然后，安装qs，命令行工具键入npm install qs --save-dev。然后在项目/src/main.js中配置如下：12345import axios from &apos;axios&apos;import qs from &apos;qs&apos; Vue.prototype.$axios = axios;Vue.prototype.$qs = qs; 然后在项目/config/index.js中，找到proxyTable，配置及说明如下：12345678910proxyTable: &#123; &apos;/api&apos;: &#123; //设置url公用部分 target: &apos;http://192.168.1.100:8080/&apos;, changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos; //这里理解成用‘/api’代替target里面的地址 &#125; &#125;&#125;, 配置完成之后，在.vue文件中，请求用例如下：12345678910//参数let params = this.$qs.stringify(&#123; key: value&#125;);//请求this.$axios.post(&apos;/api/test&apos;, params).then((response) =&gt; &#123; console.log(response);&#125;).catch((error) =&gt; &#123; console.log(error);&#125;) 最后，键入命令npm run dev，发现请求数据格式已经成为Form Data的格式，并且即使后端不处理跨域问题，也依然正常可用。原因是proxy作为中间层，先将数据请求回本地，此过程是中间层node请求后台，不存在跨域。然后请求过来的数据放在本地，前端再去请求这个数据，就可以解决跨域问题了。 4.echarts可视化&emsp;&emsp;如今相信大家不少项目需要用到数据可视化吧？各种统计图表、炫酷可视化效果等等，都需要一个不错的插件去支撑，比如D3、AnyChart、echarts、HighCharts等等。本案例用百度的echarts作为案例讲解。 安装依赖惯例，先装依赖。命令行工具执行npm install echarts --save-dev。 全局配置安装完成后，全局引入。引入方法：进入项目/src/main.js，如下操作： 123import echarts from &apos;echarts&apos;Vue.prototype.$echarts = echarts 使用在***.vue组件中即可正常使用。我在此处用Hello.vue写示例： 1234567891011121314151617181920212223242526//template&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;//scriptlet myChart = this.$echarts.init(document.getElementById(&apos;demo&apos;)); //初始化//myChart.clear(); //根据需求配置myChart.setOption(&#123; // 图表配置 xAxis: &#123; type: &apos;category&apos;, data: [&apos;Mon&apos;, &apos;Tue&apos;, &apos;Wed&apos;, &apos;Thu&apos;, &apos;Fri&apos;, &apos;Sat&apos;, &apos;Sun&apos;] &#125;, yAxis: &#123; type: &apos;value&apos; &#125;, series: [&#123; data: [820, 932, 901, 934, 1290, 1330, 1320], type: &apos;line&apos;, smooth: true &#125;]&#125;);//style#demo&#123; width: 500px; height: 500px;&#125; 效果图 按需引入试过之后会发现echarts的包很大，会导致打包之后文件过大，因此如果不是刚需的情况下，建议按需引入来完成页面，会节省许多资源及开销。首先，将刚才项目/src/main.js中的两行代码注释掉。接下来，依然以Hello.vue举例，如下：12345678910111213141516//template &amp;&amp; style 不作变动//scriptconst echarts = require(&apos;echarts/lib/echarts&apos;); //基本模板require(&apos;echarts/lib/chart/line&apos;); //折线图组件require(&apos;echarts/lib/component/title&apos;); //标题组件 // 初始化实例let myChart = echarts.init(document.getElementById(&apos;demo&apos;));// 图表配置myChart.setOption(&#123; title: &#123; text: &apos;引入title组件可使用标题&apos; &#125;, * * * * * * * * * 别的配置不变 * * * * * * * * *&#125;); 5.lib-flexible | px2rem-loader&emsp;&emsp;lib-flexible作用在于写页面的时候实现自适应效果，包括文图排本等。需要配合px2rem-loader使用。步骤如下： 安装依赖 123npm i lib-flexible --save-devnpm install px2rem-loader --save-dev 引入项目/src/main.js中做如下配置： 1import &apos;lib-flexible 主页添加视口配置项目/index.html中的head中添加： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; px2rem配置项目/build/utils.js中如下配置，然后重启项目即可： 12345678910111213//自适应字体配置const px2remLoader = &#123; loader: &apos;px2rem-loader&apos;, options: &#123; remUnit: 37.5 //设计稿的宽度除以 10，现阶段一般设计稿的宽度都为750px。如果基于iPhone5设计则为32.0(320 / 10 = 32) &#125;&#125;function generateLoaders (loader, loaderOptions) &#123; const loaders = options.usePostCSS ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader, px2remLoader] * * *&#125; 更多关于px2rem的介绍请移步官网 四、项目打包本章节介绍打包以及去除打包后资源中的.map文件。开发完成后，怎么打包到线上呢？emm…this is a problem. 1.打包命令行工具cd到该项目下，执行npm run build来构建项目：1234567891011121314E:\stydy\blog&gt;npm run build Asset Size Chunks Chunk Names static/js/vendor.38756a8637fc194013f9.js 442 kB 0 [emitted] [big] vendor static/js/app.0b5326236ed4caddb252.js 1.1 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 857 bytes 2 [emitted] manifest static/css/app.26e0081e2c66d97635076ad7fefbb5b6.css 164 bytes 1 [emitted] appstatic/css/app.26e0081e2c66d97635076ad7fefbb5b6.css.map 348 bytes [emitted] static/js/vendor.38756a8637fc194013f9.js.map 2.38 MB 0 [emitted] vendor static/js/app.0b5326236ed4caddb252.js.map 8.47 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js.map 4.97 kB 2 [emitted] manifest index.html 571 bytes [emitted] Build complete. 2.位置打包完成后，去哪儿了呢？然后会发现在项目路径下，出现了一个dist的文件夹，这里面就是所谓的 包 了。如下：123456789101112131415161718├── project │ ├── build │ ├── config │ ├── dist // 包 │ │ ├── static // 压缩后的资源│ │ ├── index.html // 主页│ ├── node_modules │ ├── src │ ├── static │ ├── test │ ├── .babelrc │ ├── .editorconfig │ ├── .gitignore │ ├── .postcssrc.js │ ├── index.html │ ├── package-lock.json │ ├── package.json │ ├── README.md 3.问题&amp;解决细心的你可能发现了，dist/static/css(或js)里面，每个css文件和js文件下有一个同名的.map文件，非常占空间，那它是做什么的呢？又怎么消除呢？ 作用查过资料的小伙伴知道了，.map文件的作用就是：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。有了map就可以像未加密的代码一样，准确的输出是哪一行哪一列有错。 如何解决那么该如何处理这些文件呢？进入项目/config/index.js，定位到productionSourceMap，将其值改为false即可。如下： 1productionSourceMap: false, 重新打包验证在命令行工具重新执行npm run build，发现.map文件已经消失，问题解决。如下： 12345678910E:\stydy\blog&gt;npm run build Asset Size Chunks Chunk Names static/js/vendor.38756a8637fc194013f9.js 442 kB 0 [emitted] [big] vendor static/js/app.3c96ecd23cc6dc073a3e.js 1.05 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 799 bytes 2 [emitted] manifeststatic/css/app.26e0081e2c66d97635076ad7fefbb5b6.css 95 bytes 1 [emitted] app index.html 571 bytes [emitted] Build complete. 五、包优化&emsp;&emsp;在项目逐渐壮大之后，虽然说上面已经讲述过了如何去除.map文件，但是其中许多.js文件的体积也不容小觑。尤其是发布到线上以后，某些css/js单个文件体积极可能超上兆的大小，如果项目服务器带宽不够，但是页面迸发量不低的话，分分钟就可能挂掉。有没有什么方法能进一步将包优化呢？ 1.gzip打包压缩 安装gzip惯例，打开命令行工具，安装gzip 1npm install compression-webpack-plugin@1.1.11 --save-dev 配置项目/config/index.js中，定位到productionGzip，改为true： 1productionGzip: true, 重新打包npm run build走起，会发现打包的文件中多了同名的.gz文件，体积大概压缩了2/3，很棒的体验。如下： 1234567891011E:\stydy\blog&gt;npm run build Asset Size Chunks Chunk Names static/js/vendor.38756a8637fc194013f9.js 442 kB 0 [emitted] [big] vendor static/js/app.3c96ecd23cc6dc073a3e.js 1.05 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 799 bytes 2 [emitted] manifeststatic/css/app.26e0081e2c66d97635076ad7fefbb5b6.css 95 bytes 1 [emitted] app index.html 571 bytes [emitted] static/js/vendor.38756a8637fc194013f9.js.gz 155 kB [emitted] Build complete. nginx配置虽然很给力的节省了许多资源，但是需要运维配合，在gninx.conf配置文件中做如下配置： 1234567891011http &#123; gzip on; gzip_disable &quot;msie6&quot;; gzip_vary on; gzip_proxied any; gzip_comp_level 8; //压缩级别 gzip_buffers 16 8k; #gzip_http_version 1.1; gzip_min_length 100; //不压缩临界值 gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;&#125; 2.采用cdn加速&emsp;&emsp;顾名思义，即将一些比较大的插件放在第三方服务器上去加载，这样不仅快很多，也能更加节约自己的服务器资源及宽带资源。我们一般选用unpkg或者BootCDN来作为第三方。在此处我们使用BootCDN来作为第三方加速使用。想了解更多相关知识请点击unpkg BootCDN。 查找包打开BootCDN，在搜索栏搜索想要的第三方资源。如，我想要替换的是echarts、Vue、axios，则依次搜索echarts…，然后查找我想要的版本，然后复制&lt;script&gt;标签。 插入在项目/index.html中将标签插入，如下： 12345678&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;//插入在这里&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.20/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts-en.common.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; webpack配置打开项目/build/webpack.base.conf.js中，添加externals: 1234567891011module.exports = &#123; context: path.resolve(__dirname, &apos;../&apos;), //.. externals:&#123; &apos;vue&apos;: &apos;Vue&apos;, &apos;vue-router&apos;: &apos;VueRouter&apos;, &apos;echarts&apos;:&apos;echarts&apos;, &apos;axios&apos;:&apos;axios&apos;, &#125;&#125; main配置打开项目/src/main.js，将Vue等注释掉即可。不注释也可。 1// import Vue from &apos;vue&apos; 打包最后，见证奇迹的时刻就要到了~ 1234567891011E:\stydy\blog&gt;npm run build Asset Size Chunks Chunk Names static/js/vendor.1f9d0533037be66c61cf.js 12.3 kB 0 [emitted] vendor static/js/app.912fd568ff845fde7c09.js 1.36 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 799 bytes 2 [emitted] manifeststatic/css/app.edc64bd802cdc531977a30fcc8a9d6e1.css 62 bytes 1 [emitted] app index.html 876 bytes [emitted] static/js/vendor.1f9d0533037be66c61cf.js.gz 4.62 kB [emitted] Build complete. 搞定上次打包，vendor大小为442kB，本次打包，疯狂缩小至12.3kB。神不神奇~厉不厉害~ 结语&emsp;&emsp;到这里，vue项目从环境配置、项目搭建，到结构介绍、常用插件依赖安装使用做了比较详细的介绍，最后将项目优化也做了一定的补充。&emsp;&emsp;学而时习之，温故而知新。至此，以上。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《面纱》随笔]]></title>
    <url>%2F2019%2F03%2F25%2F%E3%80%8A%E9%9D%A2%E7%BA%B1%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[简介面纱 （英国毛姆创作长篇小说） &emsp;&emsp;《面纱》是英国作家威廉·萨默塞特·毛姆创作的一部长篇小说，首次出版于1925年。&emsp;&emsp;小说的故事发生在英国的殖民地香港和中国内陆一个叫“湄潭府”的地方。女主人公凯蒂·费恩因为和香港助理布政司查理通奸，被丈夫瓦尔特（香港政府的细菌学家）发现后胁迫她去了霍乱横行的湄潭府，最终瓦尔特不幸染病死去，凯蒂回到香港，重投查理怀抱后羞愧不已，最终回到英国和父亲和解，并和父亲同往巴哈马群岛生活。&emsp;&emsp;从《面纱》一书中，读者能看到一个表面漠然中立的叙事者背后的模糊性和矛盾性：作为帝国叙事的一分子，作者的面纱之下隐藏着东方主义的政治文化观；作为一个关注人性的个体作家，他的面纱之下隐藏着他对爱的怀疑和渴求、对人性的嘲讽和宽容。 内容&emsp;&emsp;女主人公凯蒂是生活于伦敦名利场的一位富家小姐，她容貌娇美，但精神空虚；她向往爱情，但爱慕虚荣；她待字闺中，但处处受到母亲的责备与“逼婚”。面对这种种“危机”，她决定给自己的爱情来一次“历险”：匆匆嫁给了性格孤僻、沉默寡言但却深爱着她的医生瓦尔特，并随其来到了英国的殖民地——香港。冲动的历险为其婚后的出轨埋下了伏笔。婚前，凯蒂对幸福美满的生活充满了憧憬，但丈夫的刻板严肃、疯狂工作和乏味无趣，使她顿觉寂寞、孤独和失落，不久就被花言巧语、生性多情的有妇之夫查理·唐森俘获，坠入婚外情而迷失自我。奸情败露之后，丈夫的疯狂报复、情人的无情冷落和自己的无限悔恨使凯蒂再次陷入了人生的危机。无望的她决心再次历险：陪丈夫奔赴霍乱肆虐的偏远山村——湄潭府。&emsp;&emsp;在湄潭府，凯蒂经历了绝境下的自省，看清了查理的虚伪，体验了修女的博爱、无私以及对信仰的坚定，得到了宗教与道德的救赎，亲历了丈夫的死亡，彻悟了他的博爱与爱情的狭隘，遭遇了与查理的欲火复燃，经历了对情感本能、人性污点的幡然醒悟，坚定了追寻自我的意志和决心，最后她毅然踏上回家的路，重新开始了一段崭新的人生。 随笔由于看的是译本，不是原本，所以对语言的优美和辞藻的华丽与否暂不做赏析。&emsp;&emsp;《面纱》作者毛姆被很多评论家评论为“二流作家”，原因无他，创新性、逻辑性及技巧性不足够高。艺术来源于生活又高于生活，这部《面纱》我不知道能否到达“艺术”之境界，不知道是否升华于生活，但是它一定是贴切生活，深入到生活中去的。小说中所描述出的爱、责任、被判、救赎与觉醒深入人心，也编织成了全篇小说的脉络。&emsp;&emsp;故事从爱与责任讲起。女主凯蒂从小缺乏疼爱，母亲势力且强势，害怕26岁的自己变成老处女。男主瓦尔特不善言辞、沉默寡言，是一个缺乏生活趣味的细菌学家。从社交舞会上与女主相识，追到手后匆匆结婚。一次偶然发现了奉若上宾的妻子却与他人（沃丁顿）有染，随后给妻子凯蒂两个选择，要么离婚要么陪同自己到湄潭府瘟疫区，这个地方可以说九死一生。随后二人到香港霍乱区开始“新”生活。男主在湄潭府疯狂工作，尝试用工作去洗刷与妻子情感的污垢，而妻子凯蒂则终日彷徨，浑浑噩噩，直到那一天，走进了教堂。&emsp;&emsp;走进教堂的那一天，是自我救赎的开始。以前，自己容貌娇美，但精神空虚；向往爱情，但爱慕虚荣；待字闺中，却被“逼婚”…种种因果，造成了当下不可逆转之局势后，直到这天，在教堂帮忙了一天，蓦然回首，才开始自省。之后便成了教堂的常客，甚至工作于此。在这里，凯蒂体验了修女的博爱、无私以及对信仰的坚定，甚至后来得知丈夫对于霍乱区的贡献，以及丈夫染上霍乱也未曾停歇，直至生命的尽头，理解了丈夫瓦尔特的博爱以及对爱情的不圆满，甚至狭隘。在此过程中，女主凯蒂内心逐渐完成自我救赎，看到光亮，理解生活的意义。在男主病逝后，女主凯蒂回到香港（当时香港是英国殖民地），随后又遇到了查理。在欲火复燃之后，沃丁顿妻子出现。沃丁顿妻子是一位满洲格格，外貌特征符合西方对东方宫廷女性的想象与审美。与她见面却没有直接的言语对白，只有“心理交流”，但是却让自己感受到了这位格格身上所代表的的灿烂文明。与此同时，自己算是经历了一场领悟，坚定了追寻自我的意志和决心。最后毅然踏上回家的路，与父亲和好，走向新的人生。 关于爱与责任&emsp;&emsp;对于男主瓦尔特来讲，从原文我知道你愚蠢、轻佻、头脑空虚，然而我爱你。我知道你的企图、你的理想，你势力、庸俗，然后我爱你。我知道你是个二流货色，然而我爱你。开始，已是深情告白，而女主凯蒂却不为所动。对于沃尔特来说，自己的伤悲只有自己可以理解，非常单纯的爱。即使发现妻子不忠，开始唇枪舌战，也依然保持镇定姿态和绅士风度。也同样由于爱之深所以恨之切，从而走向报复道路，去到霍乱区。&emsp;&emsp;瓦尔特却一直深爱凯蒂不肯放手，沃丁顿深爱满洲格格（他的妻子），唐森深爱自己妻子，修道院姐们们走在前线与病魔抗争，一系列的周边情感感染着凯蒂，渐渐地凯蒂也有了希望和勇气，学会慈悲与爱，放下心魔。 关于人格觉醒&emsp;&emsp;某乎上有话题：为什么永远不要去考验人性？而其中高票回答：因为大多数时候，人是选择做一个好人，而不是本性如此。小说中女主从最开始的人格为精神空虚、爱慕虚荣，此后与男主结婚后，依然是处于精神空虚状态，因而让得第三者沃尔顿有机可乘。东窗事发之后，由于沃尔顿的劝告甚至不想卷入其中，导致精神萎靡不振、浑浑噩噩。去到霍乱区之后，更加严重。到修道院开始，内心仿佛有了些许光亮。进而经常去修道院帮忙之后，从修女姐妹们的日常生活中得到救赎，找到了一些生活的意义以及开始忠于内心。神秘的面纱一角被掀开之后，开始审视自己，自我救赎，最终完成内心的升华。 作品评价&emsp;&emsp;贴切生活，以故事的尖锐以及矛盾来铺垫人物的内心世界，加上道德冲突、人性考验，不矢为一部杰作。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种境界]]></title>
    <url>%2F2019%2F03%2F24%2F%E4%B8%89%E7%A7%8D%E5%A2%83%E7%95%8C%2F</url>
    <content type="text"><![CDATA[前言古今之成大事业、大学问者，罔不经过三种之境界。 三种境界123昨夜西风凋碧树。独上高楼，望尽天涯路。衣带渐宽终不悔，为伊消得人憔悴。众里寻他千百度，回头蓦见，那人正在灯火阑珊处。 原文 &emsp;&emsp;古今之成大事业、大学问者，罔不经过三种之境界：“昨夜西风凋碧树。独上高楼，望尽天涯路。”此第一境界也。“衣带渐宽终不悔，为伊消得人憔悴。”此第二境界也。“众里寻他千百度，回头蓦见（当作‘蓦然回首’），那人正（当作‘却’）在灯火阑珊处。”此第三境界也。此等非大词人不能道。然遽依此意解释诸词，恐为晏、欧诸公所不许也。 译文&emsp;&emsp;古今那些成就大事业、大学问的人，都必然经历三种境界：“昨夜西风凋碧树。独上高楼，望尽天涯路。”这是第一层境界。“衣带渐宽终不悔，为伊消得人憔悴。”这是第二层境界。“众里寻他千百度，回头蓦见，那人正在灯火阑珊处。”这是第三种境界。像这样的语言，只有大词人才讲得出来。但是，我竟然这样来解释上面的词，恐怕晏殊、欧阳修这些大词人是不会同意的吧。 赏析&emsp;&emsp;《人间词话》赖以成名的数段话中，这一段毫无疑问占据了一个重要位置。这段话比喻贴切，佳句宛如浑然天成般镶嵌其中，让人称绝。王老先生正是“成大学问者”，说的这些话也正是他的切身感触。&emsp;&emsp;昨夜西风凋碧树。独上高楼，望尽天涯路。第一境界即入门前茫无头绪、求索无门的疑惑与痛苦。王国维最得意的学问在于史学、古文学和美学。这几门学问千头万绪，典籍浩如烟海，那种想要入门之前的彷徨、痛苦与渴求，用独上高楼，望尽天涯路来比喻，实在是再贴切不过。&emsp;&emsp;衣带渐宽终不悔，为伊消得人憔悴。第二境界是叩门时以苦做舟、以勤为径、上下求索的执着于忍耐。古往今来的大师无不经历过此阶段。不执着，无以成。既已入门，注定将为心中的伊人把此生消磨。王国维在乱世之中，一心治学，那种执着、悲愤、孤苦的心境，恐怕不是现代人所能理解的。唯有这种执着于隐忍，才成就了他在近代史上第一无二的大师地位。&emsp;&emsp;众里寻他千百度，回头蓦见，那人正在灯火阑珊处。第三境界则是功夫到处，灵犀一点、参透真谛、已入门中的喜悦与释然。以勤为径，很多人都如此，但是要攀上顶峰，就不是一般人能做到了。那种灵犀一点参透真谛的大智慧、大喜悦，也只有古今中外各个领域中的天才们感悟得到。这种顿悟就好比掉在牛顿身边的那个苹果，释迦牟尼眼前的那颗菩提，一切的一切忽然间都豁然开朗，往西追寻之中的种种艰辛苦楚，在这一瞬间都得到了完美补偿。&emsp;&emsp;当然，这些都不可能是词作者的愿意，所以王国维接着又说：此等非大词人不能道。然遽依此意解释诸词，恐为晏、欧诸公所不许也。这段话鞭辟入里，贴切浑融，其深致款曲已经不止于词话的范围了，即使晏、欧诸公在世，香叶不容置喙，不得不叹服王氏的才情与睿智吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js监测页面滑至底部响应事件]]></title>
    <url>%2F2019%2F03%2F18%2Fjs%E7%9B%91%E6%B5%8B%E9%A1%B5%E9%9D%A2%E6%BB%91%E8%87%B3%E5%BA%95%E9%83%A8%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[需求&emsp;&emsp;页面滑动至底部时候，触发响应 应用场景 服务协议滑动完毕可点击同意按钮; 页面滑至底部加载更多(新闻、列表等); 自动加载下一页等… 分析&emsp;&emsp;首先，既然是监听，则首要条件便是监听页面滑动(滚动)事件；其次，由于一般页面不会一屏展示完，因此需要依赖BOM来辅助完成一些计算。最后，达到某种条件，触发方法。 代码12345678910111213 window.onscroll = function()&#123; //滚动条滚动时，距离顶部的距离 let scrollTop = document.documentElement.scrollTop||document.body.scrollTop; //可视区的高度 let windowHeight = document.documentElement.clientHeight || document.body.clientHeight; //滚动条的总高度 let scrollHeight = document.documentElement.scrollHeight||document.body.scrollHeight; //滚动条到底部的条件 if(scrollTop + windowHeight &gt;= scrollHeight)&#123; //此处触发响应事件 ... &#125;&#125; 附录12345678910111213网页可见区域宽：document.body.clientWidth网页可见区域高：document.body.clientHeight网页可见区域宽：document.body.offsetWidth (包括边线的宽)网页可见区域高：document.body.offsetHeight (包括边线的高)网页正文全文宽：document.body.scrollWidth网页正文全文高：document.body.scrollHeight网页被卷去的高：document.body.scrollTop网页被卷去的左：document.body.scrollLeft//对应的dom元素的宽高有以下几个常用的：元素的实际高度：document.getElementById(&quot;div&quot;).offsetHeight元素的实际宽度：document.getElementById(&quot;div&quot;).offsetWidth元素的实际距离左边界的距离：document.getElementById(&quot;div&quot;).offsetLeft元素的实际距离上边界的距离：document.getElementById(&quot;div&quot;).offsetTop]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《惊奇队长》随笔]]></title>
    <url>%2F2019%2F03%2F10%2F%E3%80%8A%E6%83%8A%E5%A5%87%E9%98%9F%E9%95%BF%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[简介 &emsp;&emsp;卡罗尔·丹弗斯（布丽·拉尔森饰）是克里人的精英部队一员，但她挣扎着回忆过去，对于怎么获得超能力、以及之前的人生等超能力之前的人生，她只在梦中有片段不成章的记忆，这层困扰引起的情绪波动也进而影响她对超能力的掌控。所幸，在星际战队指挥官（裘德·洛饰）的调教之下，卡罗尔·丹弗斯学会如何控制自己的超能力。&emsp;&emsp;一次外星任务中，卡罗尔·丹弗斯因故来到了地球，并遇到还是低阶探员的尼克·弗瑞（塞缪尔·杰克逊饰），卡罗尔·丹弗斯与尼克·弗瑞一起追捕在地球惹事的变形人塔罗斯（本·门德尔森饰），同时，也发现自己如何获得超能力。 起&emsp;&emsp;时间回到前天(2019年3月8日18:00:00)。这是不寻常的一天，不仅仅是女神节，更是跟基友约好看惊奇队长首映的日子。&emsp;&emsp;下午6点，准备下班。但是作为猿，按时下班显然不是我们的风格，于是噼里啪啦一顿操作又改了个产品刚提出的优化，并且自测完毕。ok，天儿也不早了，赶紧挤地铁回家准备观影去吧。没想到的是，为了一场电影，会有一场场刺激等待着我们。 Then&emsp;&emsp;19:35，超市购物了一波回到家，小憩了一下下，喝点酸奶补补体力。&emsp;&emsp;20:35，嘀嘀了一辆优享专车，下楼跟基友等车。&emsp;&emsp;上车。&emsp;&emsp;堵车。&emsp;&emsp;司机人很nice，一个看起来有修养的大龄先生。&emsp;&emsp;两分钟后，我们在后排毫无感觉，司机下了车，前面司机也下了车。&emsp;&emsp;嗯，追尾。&emsp;&emsp;ok,下车，换车。&emsp;&emsp;重新嘀嘀。&emsp;&emsp;“耐心”等待中…&emsp;&emsp;上车。&emsp;&emsp;驾驶过堵车区，一路飞……额，红灯。&emsp;&emsp;“铃铃铃铃铃铃”电话响起来~&emsp;&emsp;“…………”&emsp;&emsp;基友：“完了，一个需求忘记处理”&emsp;&emsp;“……看急不急，不急了明天上午公司处理”&emsp;&emsp;下车。&emsp;&emsp;取票。&emsp;&emsp;21:03，等待进场。&emsp;&emsp;21:05，开始检票。&emsp;&emsp;21:06,，“不行，我得回去先处理需求去了……”。&emsp;&emsp;于是，检票只检了一张，有了下图： So&emsp;&emsp;被迫一个人看完了整场。 随笔关于剧情&emsp;&emsp;一向的漫威思维，并且在女神节这么个档期，祭出目前最强大的主角英雄，且为女英雄，应景至极。前半篇在不停的铺垫，以及给出一些断断续续的女主回忆。从女主发现自己被骗之后，一系列举动将剧情推向高潮。&emsp;&emsp;故事发生于上世纪90年代，在此之时，复仇者联盟尚未建立。居中也道出了神盾局局长独眼的原因以及建立复仇者联盟的初心。&emsp;&emsp;斯克鲁人怕猫，检测猫为“噬元兽”，克里人怕尬舞。然而关键时刻，猫吞噬“魔方”，吞噬“敌军”，真的救了神盾局长。 关于彩蛋&emsp;&emsp;很多评论说，又是“看彩蛋送电影”，第一个彩蛋比正片好看。确实，在漫威宇宙中，自打复联出来之后，新出的超级英雄好像都与复联有着密不可分的联系，甚至都是为了复联去添砖加瓦。但是在多方面关于复联四的猜测中，惊奇队长却是救世中不可或缺且极为重要的一环。如果只是粗略的一笔带过，进而在复联四中直接使用其几乎藐视现阶段复联所有人所有技能的特殊能力，那在复联四中将会显得极为仓促且莫名其妙。因此，此英雄作为一部新的超级英雄，极有必要对齐以及复联历史进行一些必要的补充，以及填坑。 关于斯坦●李&emsp;&emsp;老爷子去年过世，与东方的金庸大侠先后将生命挪出了时间。至此，东方再无江湖，漫威再无宇宙。&emsp;&emsp;剧中老爷子作为路人，在公交车上看书，与惊奇队长偶遇。上一次同样是在公交车看书，遇到了奇异博士。&emsp;&emsp;所以是不是为我们敲响警钟，多出门，多读书，不要总在家里宅着，说不定也能偶遇超级英雄呢。 猜测&emsp;&emsp;《蚁人2》片尾彩蛋中，蚁人进入量子域，在入口处，小女友及其父母随着灭霸的响指化为了灰烬，因此是否在复联四中也会贡献在即的一份力量呢？ 等待ing复联四…]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>读书笔记</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js/vue输入联想功能]]></title>
    <url>%2F2019%2F03%2F04%2Fjs-vue%E8%BE%93%E5%85%A5%E8%81%94%E6%83%B3%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[实现功能如下 介绍&emsp;&emsp;最近需求要有一个输入框模糊搜索功能，且需要匹配输入字符联想。从网上看了一些demo，总结出来一套思路，配合vue将其开发并稍做优化处理。 思路基础： 1.一个输入框（输入字符）、一个ul框（展示匹配数据） 2.将输入字符与列表中字符比对 3.新建空数组，将比对结果匹配项放入此数组中 4.将数组数据铺到ul中 优化： 5.鼠标滑入某一项变更背景色 6.点击选中数据展示到input框中 7.键盘上下键控制上一个下一个 8.回车键将选中项目展示到input框中 代码1.HTML1234567891011121314151617//input框 &lt;input type=&quot;text&quot; @keydown.down=&quot;changeDown&quot; //键盘事件 @keydown.up=&quot;changeUp&quot; v-model=&quot;searchVal&quot; //绑定输入的值 @keyup=&quot;searchFn&quot; @keyup.enter=&quot;enter&quot; //回车将选中项目展示到input框中 placeholder=&quot;input name&quot;/&gt; //选项框 判断如果新数组中有值则显示本备选框&lt;ul class=&quot;ulAdd&quot; v-if=&quot;searchResult&quot;&gt; &lt;li v-for=&quot;(item, index) in searchResult&quot; :class=&quot;&#123;bgColor: index === now&#125;&quot; //渲染样式 @click=&quot;alertFn&quot; //点击将选中项目展示到input框中 @mouseenter=&quot;mouseEnter(index)&quot; //渲染鼠标移入/移出样式 @mouseleave=&quot;mouseleave&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 2.数据12345678searchVal: &apos;&apos;, //绑定namesearchResult: [], //匹配结果now: -1, //索引nameList: [ //name列表 &#123;name: &apos;张三&apos;,id: &apos;9001&apos;&#125;, &#123;name: &apos;张四&apos;,id: &apos;9002&apos;&#125;, &#123;name: &apos;李三&apos;,id: &apos;9003&apos;&#125;] 3.事件处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//过滤searchFn (e) &#123; let val = e.target.value; //输入的值 this.searchResult = []; //清空存结果的数组 if (val) &#123; this.nameList.forEach(function(item) &#123; let pattern = new RegExp(&apos;&apos;+val, &apos;g&apos;); //正则校验 if (pattern.test(item.name)) &#123; this.searchResult.push(&#123;name: item.name,id: item.id&#125;); &#125; &#125;.bind(this)); // 绑定当前实例对象 &#125;&#125;//将选中项目展示到input框中alertFn () &#123; this.searchVal = this.searchResult[this.now].agentname; this.searchResult = [];&#125;,//按键盘↓键changeDown () &#123; this.now ++; if(this.now == this.searchResult.length) &#123; this.now = -1; &#125;&#125;,//按键盘↑键changeUp () &#123; this.now --; if (this.now === -2) &#123; this.now = this.searchResult.length; &#125;&#125;,//回车将选中项目展示到input框中enter () &#123; this.searchVal = this.searchResult[this.now].agentname; this.searchResult = [];&#125;,//清空结果deleteList () &#123; this.searchResult = [];&#125;,//鼠标移入mouseEnter (index) &#123; this.now = index;&#125;,//鼠标移出mouseleave (index) &#123; this.now = -1;&#125; 注&emsp;&emsp;样式自定义即可。 总结功能实现，且完成了一定的优化，但存在一定的不足： 数组循环可用新语法； 多个方法可合并； 可以进一步优化，做出输入字母也同样联想。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>输入框联想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目打包后资源路径与背景图路径问题]]></title>
    <url>%2F2019%2F02%2F28%2Fvue%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%90%8E%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E4%B8%8E%E8%83%8C%E6%99%AF%E5%9B%BE%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言本文主要解决基于vue/vuex打包后经常出现的两个问题： 静态资源路径错位问题 css背景图路径错位问题 问题的出现&emsp;&emsp;一般通过vue-cli脚手架开发的时候，开发模式使用npm run dev进行开发，一切配置正常。但是当打包后会出现各种问题，其中两个最为常见且致命的问题莫过于上述的两个资源路径错位问题，但是当我们分析后，发现依旧是配置问题。尤其是当好多猿把assetsPublicPath: &#39;/&#39;的&#39;/&#39;改为&#39;./&#39;后，一般的资源路径包括css、js、图片音视频等都能校正，然而唯独css设置的背景图却全部失效。接下来请看此bug图。 bug图：1. 资源路径4042. 背景图路径404可以看到背景图的路径错且重复。 解决方案1. 静态资源路径错位问题解决方案：在项目/config/index.js中找到module.exports中的build，其中的assetsPublicPath项改为：1assetsPublicPath: &apos;./&apos;, //解决静态资源路径错位问题 2. css背景图路径错位问题解决方案：在项目/build/utils.js中找到ExtractTextPlugin.extract，追加publicPath: &#39;../../&#39;：代码片段为：12345return ExtractTextPlugin.extract(&#123; use: loaders, fallback: &apos;vue-style-loader&apos;, publicPath: &apos;../../&apos; //解决css背景图路径错位问题 &#125;) 测试结果：ok，配置完毕，打包测试下~npm run build 倒数10个数：10,9,8,7,6…控制台空空如也~完美！]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[to 2019]]></title>
    <url>%2F2019%2F02%2F25%2Fto-2019%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;2019悄然来袭，且2月将逝。值此春天即醒之际，万物复苏之时，应对2018正式告别，并在充满期待的2019之中完成一些目标来积累沉淀自己。 规划规划大致分为以下四（+1）个大方面： 学习 工作 生活 财务 其他 （愿世界和平） 其详细信息将通过X-Mind作导图式的png图片展示，如下： 规则 完成后做“√”标记； 定期更新：月更，更新文本及感受类图文；季更，更新图片及日期； 不定期更新： 完成后更新； 更新准则：上传新图，标明日期； 训练自律;随心所欲的日子里，大部分时候都怅然若失。 更新0226完成 可乐鸡翅，招待朋友songleitravel,于2019.02.16完成； 建站，GitHub+Hexo+nexT，于2019.02.20完成； 发表博文，包括读书随笔与技术随笔； 小结&emsp;&emsp;本月前期学习阮一峰老师的《ES6》，后期项目压力上来，暂搁一旁。这种行为不可取，在此反思。另，本季度读书及笔记均会在本站博客中体现，已完成《小狗钱钱1》随想。 更新0401本期更新主要如下： 读书篇 《小狗钱钱1》随想 《面纱》随笔 工作篇 es6学习 博客更新，包括如下： 文章 更新时间 Vue打包后map文件处理 02-22 vue-cli自适应/flexible屏幕字体自适应布局及配置 02-23 vue中axios跨域问题 02-24 vue项目打包后资源路径与背景图路径问题 02-28 js/vue输入联想功能 03-04 js监测页面滑至底部响应事件 03-18 post_link vue项目搭建及基本配置 03-27 生活篇 影音娱乐 《惊奇队长》随笔 《探清水河》小调 做菜 红烧肉 麻婆豆腐 可乐鸡翅 财务篇 存款达到目标1/3； 被动收益达到目标1/5； 公益方面利用支付宝月捐，按月自动捐出； 蚂蚁森林领养两棵树，完成全年2/3 小结完成度尚可，但是1个/月的训练项目未完成。继续努力！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中axios跨域问题]]></title>
    <url>%2F2019%2F02%2F24%2Fvue%E4%B8%ADaxios%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言兴冲冲的开始用vue封装组件、自定义指令之后，开始实战。诶，等等，貌似少了……交互？大致研究了一下axios，但是存在以下两个问题： 跨域问题 数据格式问题跨域信息示例：1234Failed to load http://localhost:8080/login:Response to preflight request doesn&apos;t pass access control check:No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://localhost:8080&apos; is therefore not allowed access. 所以针对该问题给出一套解决方案（以post请求为例）： 1.跨域处理cinfig/index.js中对proxyTable做如下配置：123456789proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;https://0.0.0.0:8080/login&apos;, //设置url公用部分，记得加http/https和端口号 changeOrigin: true, pathRewrite: &#123; &apos;^/api&apos;: &apos;/&apos; //这里理解成用‘/api’代替target里面的地址，后面组件中我们掉接口时直接用api代替 比如我要调用&apos;http://40.00.100.100:3002/user/add&apos;，直接写‘/api/user/add’即可 &#125; &#125; &#125;, main.js中引入axios并作为Vue属性使用123import axios from &apos;axios&apos;Vue.prototype.HOST = &apos;/api&apos; 在调取数据组件中，axios配置如下（可以自行封装）：12345678910111213141516getData () &#123; this.$axios(&#123; method: &apos;post&apos;, //请求方式 一般为get\post 此处以post为例 url: this.HOST + &apos;/login&apos;, //url data: &#123; //数据 loginId: &apos;123456&apos;, password: &apos;123456&apos; &#125;, &#125;).then(function (res) &#123; console.log(res); debugger; &#125;.bind(this)).catch(function (err) &#123; //bind 绑定当前作用域 console.log(err); debugger; &#125;) &#125; ok，保存，然后npm run dev咦？发生了什么？没跨域啊？数据发过去了啊？为什么服务器给我抛异常==、12345&#123; code:100, data: &#123;&#125;, msg: &quot;服务器异常&quot; &#125; 检查发现错误原因：数据发送时没有走formdata，接下来处理该问题。 2.数据格式修正formdata形式提交数据处理方法则是在刚才配置的getData()中的this.$axios()加上一段格式化代码配置即可，代码如下：123456789101112//formdata transformRequest: [function (data) &#123; let ret = &apos;&apos;; for (let it in data) &#123; ret += encodeURIComponent(it) + &apos;=&apos; + encodeURIComponent(data[it]) + &apos;&amp;&apos;; &#125; return ret &#125;],//头信息 headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125; 注：说明步骤2 formdata形式提交数据，可直接解决跨域问题，不用执行步骤1完整axios的post配置如下：1234567891011121314151617181920212223242526getData () &#123; this.$axios(&#123; method: &apos;post&apos;, //请求方式 一般为get\post 此处以post为例 url: &apos;http://localhost:8080/login&apos;, data: &#123; //数据 loginId: &apos;123456&apos;, password: &apos;123456&apos; &#125;, transformRequest: [function (data) &#123; let ret = &apos;&apos;; for (let it in data) &#123; ret += encodeURIComponent(it) + &apos;=&apos; + encodeURIComponent(data[it]) + &apos;&amp;&apos;; &#125; return ret &#125;], headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125; &#125;).then(function (res) &#123; console.log(res); debugger; &#125;.bind(this)).catch(function (err) &#123; console.log(err); debugger; &#125;)&#125; 继续测试：保存之后npm run dev完美~~，接下来看返回数据： ok，解决方案到此结束，希望对大家有所帮助。继续快乐的采坑吧各位~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli自适应|flexible屏幕字体自适应布局及配置]]></title>
    <url>%2F2019%2F02%2F23%2Fvue-cli%E8%87%AA%E9%80%82%E5%BA%94-flexible%E5%B1%8F%E5%B9%95%E5%AD%97%E4%BD%93%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言：很多前端小伙伴在写页面尤其是移动端页面的时候，要求页面布局以及字体大小随屏幕宽度变化而随之按比例自适应【注：非响应式】，那么，在vue-cli脚手架中应该如何去实现呢？ 1.安装flexible库12//在项目库下运行：npm i lib-flexible --save-dev 2.引入项目入口文件main.js中引入lib-flexible:12//main.js中：import &apos;lib-flexible&apos; 3.配置meta在项目index.html的head中配置meta`：12&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 4.安装px2rem-loader12//在项目库下运行npm install px2rem-loader --save-dev 5.配置px2rem编译器在build/utils.js中，将px2rem-loader添加到cssLoaders中：123456789101112131415//自适应字体配置const px2remLoader = &#123; loader: &apos;px2rem-loader&apos;, options: &#123; remUnit: 37.5 //设计稿的宽度 除以 10，现阶段一般设计稿的宽度都为750px。如果基于iPhone5设计则为32.0(320 / 10 = 32) &#125;&#125;// generate loader string to be used with extract text plugin function generateLoaders (loader, loaderOptions) &#123; const loaders = options.usePostCSS ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader, px2remLoader] /** *其余的不用改 */ &#125; 6.启动项目1npm run dev 后语：启动项目之后会惊讶的发现已经完美解决了，即使在PC端也是适用的哦~想要了解更多关于px2rem的想伙伴可以戳下方飞机票去官方看介绍：点击飞机票：px2rem]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《小狗钱钱1》随想]]></title>
    <url>%2F2019%2F02%2F23%2F%E3%80%8A%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B11%E3%80%8B%E9%9A%8F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;相信大家都买过基金吧，比如支付宝的余额宝就是一种货币基金。我的钱一直也在支付宝存放。但是从去年（2018年）年初开始，收益好像走了下坡路。为了追求更高的收益，我便把目光转向了支付宝里面的基金市场，然后再零理财基础的情况下辛辛苦苦选了好几个（我认为）收益高的基金，结果一天掉一百多块……不到半个月 差不多赔了小一千，因此觉得开始学习并积累一些理财知识，但是迟迟没有行动。直到规划本年度（2019）目标时，才想起此事，并提上日程。一顿操作猛如虎，找到了一本理财的启蒙书《小狗钱钱》，并且用了一下午3小时26分钟的时间通读了一遍，由此感悟颇深。&emsp;&emsp;读书不写笔记犹如过眼云烟，学习重在输出。 介绍&emsp;&emsp;《小狗钱钱》讲述的是一个童话故事：有一天，吉娅发现一只受伤的猎狗，并把它带回了家。可是，有谁会想到，这只普通的四脚动物却是一个真正的理财天才呢？吉娅和小狗成为了朋友，并从它那里得知，原来所有的愿望都是可以实现的。&emsp;&emsp;从这个童话故事里可以了解一些金钱的秘密和真相，以及投资、理财的办法。这个故事描述了在实施这些方法的过程中可能遇到的挑战，并且说明了一些令人难以置信的结果。 钱钱语录 金钱有一些秘密和规律，要想了解这些秘密和规律，前提条件是，你自己必须真的有这个愿望。 如果你只是带着试试看的心态，那么你最后只会以失败而告终，你会一事无成。尝试纯粹是一种借口，你还没有做，就已经给自己想好退路了。不能试验。你只有两个选择：做，或者不做。 你是否能挣到钱，最关键的因素并不在于你是不是有一个好点子。你有多聪明也不是主要原因，决定因素是你的自信程度。 一个人把精力集中在自己所能做的，知道的和拥有的东西上的那一天起，他的成功就已经拉开了序幕。这也使得一个孩子完全有能力比成人挣到更多的钱。 你最好想清楚，你喜欢做什么，然后再考虑你怎么用它来挣钱。 你要每天不间断地去做对称的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。 欠债的人应当毁掉所有的信用卡。 应当尽可能少地偿还贷款。 应当将不用于生活的那部分钱中的一半存起来，另一半用于还债。最好不要申请消费贷款。 每次借债前问自己：“这真的有必要吗？” 当你定下了大目标的时候，就意味着你必须付付出比别人多得多的努力。 假如我没有了我的“鹅”，我就总是得为了赚钱而工作，但是一旦我有了属于自己的“鹅”，我的钱就会自动为我工作了。 幸运其实只是充分准备加上努力工作的结果。 钱只令留在那些为之付出努力的人身边，用非法手段取得不义之财的人，反而会比没钱的时候感觉更糟糕。 恐惧总是在我们设想事情会如何不顺的时候出现。我们对失败的可能性想得越多，就越害怕。而当你朝看积极的目标去思考的时候，就不会心生畏惧。 关于投资 确定自己希望获得财务上的成功。 自信，有想法，做自己喜欢做的事。 把钱分成日常开销、梦想目标和金鹅账户三部分。 进行明智的投资。 享受生活。 如果你没有做今天这件事情，你就永远不会知道，给自己一些压力之后，你能够做到些什么。一个人觉得最引以为自豪的事情，往往是那些做起来最艰难的事情。 挑选基金时的注意事项： 基金应该至少有十年历史。假如它在这么长时间内一直有丰厚的盈利，那我们可以认为，它在未来也会运作良好。 应该选择大型的跨国股票基金，这种基金在世界各地购买股票，以此分做风险，所以十分安全。 对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终获利最好。用72除以投资的年收益率的百分比，得出的数字就是这笔钱翻一倍所要的年数。 每当冬天过后，春天就来了，接着是夏天，每个夏天之后又跟着是秋天，然后又是冬天，年年如此。跟大自然的变化一样，交易所里也总有四季更替，循环往复。 最主要的是，在人们眼中钱应该是一种再自然、再普通不过的东西了。 感悟&emsp;&emsp;故事新颖，通俗易懂，并且道出挣钱的终极目的：让钱变得不再重要。&emsp;&emsp;对啊，曾几何时，我们为了生活奔波，打拼，一切都是为了钱。有人说，不忘初心。那货币的本质是一般等价物，一定程度上代替了以物易物。一路发展而来，初心早已更改，到如今的世道上已经完全演变为了“没钱万万不能”的时代。什么世外桃源，田间小居，都是在经济支撑下才能完成的愿望。&emsp;&emsp;书中也提到适量的方法、态度以及对理财中多个名词的通俗解释，都是让理财新人能够快速接受且消化的，不得不说作者是下了大工夫的。书中主人公吉娅以及其家庭遇到的问题相信在大多数人的生活中都有存在，比如： 是否遇到问题的时候经常说，我试着…… 从小被教导，金钱是万恶之源…… 常听父母说，小孩子不用想钱的事儿…… 是否常常入不敷出…… 是否用着信用卡，每个月都在大笔的分期付款…… 是否心里曾有过宏大的目标（精神或者物质），但又告诉自己这不大可能实现…… 是否做什么事情，在没行动前总想着，我没有这个条件，这个事情不能成功…… 是否每个月仍有结余，但是仅仅是存在银行里…… 是否不够自信，但又不知道怎么去提高……等等问题。吉娅出现的每一个问题，都与我们极其相似，但是我们常常只是想想，然后迷茫，彷徨，不自信，忘记。我们却能从这本书里学习到如何想，如何做，一步一步，一个个的习惯养成，大有裨益。 &emsp;&emsp;关于金钱的意义。钱是中性的，没有善恶之分。但是往往金钱能使人性的阴暗面暴露出来，因此怎么有钱，有了钱如何使用，便是一个很大的课题，终究取决于学习，修善，成长等。在此之前，我应该先考虑钱的用途，以及自己要成为怎样的人。 &emsp;&emsp;关于“小金鹅”。故事是这样的： &emsp;&emsp;从前有一个年轻的农夫，他每天的愿望就是从鹅笼里捡一个鹅蛋当早饭。有一天，他竟然在鹅笼里发现了一只金蛋。当然，一开始他不相信这是真的。他想，也许是有人在捉弄他。为了谨慎起见，他把金蛋拿去让金匠看，可是金匠向他保证说，这只蛋完全是纯金铸成的。于是农夫卖了这只金蛋，然后举行了一个盛大的庆祝会。&emsp;&emsp;第二天清晨，他起了个大早，赶到鹅笼处一看，那里果真又放着一个金蛋。这样的情况延续了好几天。&emsp;&emsp;可是这个农夫是一个贪婪的人，他对自己的鹅，非常不满意，因为鹅没法向他解释是怎么下出金蛋的，否则也许他自己就可以制造金蛋了。他还气呼呼地想，这只懒惰的鹅每天至少应该下两只金蛋，现在这样的速度太慢了。他的怒火越来越大，最后，他终于怒不可遏地把鹅揪出鹅笼，劈成两半。从那以后，他再也得不到金蛋了。 &emsp;&emsp;其实，理财不是针对有资产的人，而是所有人。《小狗钱钱》一书中，“养鹅”一事贯穿全文。鹅代表你的钱，如果你存钱，就会得到利息，利息就是金蛋。穷人越穷，每天鸡蛋都生不出来，富人越富，每天有金蛋甚至会有越来越多的鹅。两极分化不是没有道理的。书中将赚到的钱，分成三个账户，分别是“日常开销”、“梦想目标”、“金鹅账户”，并以此达到开源节流的目的。 关于72定理 用72除以年收益率百分比，得出的数字就是这笔钱翻一倍的年数。 在通货膨胀率下，我们的钱在多长时间贬值一半，用72除以通胀率，即可得知多少年后你的钱是现在的一半。 假如目前存（投）一笔1万人民币，年收益为12%，那么72 / 12 = 6年时间就可以翻倍本金。当然，至于如何达到年收益12%甚至更高，则需要继续努力学习相关知识并且不断的实践并积累了。假定以后每年通货膨胀率6%，那么在72 / 6 = 12年后你的钱将只能买到现在购买力能买的的一半。 结语《小狗钱钱》带来最大的收获便是让我获得了一把打开新世界的钥匙。后续需要持续学习不断提高，跑赢通货膨胀，养一只能下优质蛋的鹅。好在年轻即资本，生命不息，学习不止。 后记财商决定后半生是否富裕]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue打包后map文件处理]]></title>
    <url>%2F2019%2F02%2F22%2FVue%E6%89%93%E5%8C%85%E5%90%8Emap%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言最近踩坑vue，打包之后js中，会自动生成一些map文件，无形之中就增大了dist包的体积，可能会增加服务器压力。那我们怎么把它去掉呢？ 1.找到productionSourceMap在项目下进入目录：项目包/config/index.js找到productionSourceMap123456 /** * Source Maps */productionSourceMap: true,// https://webpack.js.org/configuration/devtool/#productiondevtool: &apos;#source-map&apos;, 2.改为false将productionSourceMap的true改为false即可123productionSourceMap: false,// https://webpack.js.org/configuration/devtool/#productiondevtool: &apos;#source-map&apos;, 3.打生产包打包:npm run build12345678910111213141516171819202122Hash: 450e46e5a578d8ed5832Version: webpack 3.12.0Time: 19211ms Asset Size Chunks Chunk Names static/js/2.f45baf9afd59da355a2c.js 17.9 kB 2 [emitted] static/img/healthIcon2.0a76940.png 21.7 kB [emitted] static/img/healthIcon1.7f9e278.png 21 kB [emitted] static/img/healthIcon3.a2530d6.png 20.3 kB [emitted] static/js/0.2623d3f24b6cb900e249.js 182 kB 0 [emitted] static/js/1.68a7b37dd5366d3385bc.js 62.6 kB 1 [emitted] static/img/healthIcon4.42cd92c.png 18.9 kB [emitted] static/js/3.dd658b712540b545b1a8.js 6.57 kB 3 [emitted] static/js/vendor.ed30b6e3d0cfb8529feb.js 962 kB 4 [emitted] [big] vendor static/js/app.ab727f325a694968cc20.js 1.22 kB 5 [emitted] app static/js/manifest.bad9ce278a16a20c8817.js 1.48 kB 6 [emitted] manifeststatic/css/app.e93cb55eadaef6e12f4bccfcc6e2e3cc.css 35.6 kB 5 [emitted] app index.html 555 bytes [emitted] Build complete. Tip: built files are meant to be served over an HTTP server. Opening index.html over file:// won&apos;t work. 4.解决打包成功，看项目/dist/static/js/xxxx.js已经没有各种.map文件，问题解决。 【注】.map文件的作用：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。有了map就可以像未加密的代码一样，准确的输出是哪一行哪一列有错。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮世三千]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%B5%AE%E4%B8%96%E4%B8%89%E5%8D%83%2F</url>
    <content type="text"><![CDATA[浮世三千，吾爱有三：日、月与卿。日为朝、月为暮，卿为朝朝暮暮 我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>

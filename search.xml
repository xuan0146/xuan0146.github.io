<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS来一个极简的每日毒鸡汤]]></title>
    <url>%2F2020%2F12%2F14%2FJS%E6%9D%A5%E4%B8%80%E4%B8%AA%E6%9E%81%E7%AE%80%E7%9A%84%E6%AF%8F%E6%97%A5%E6%AF%92%E9%B8%A1%E6%B1%A4%2F</url>
    <content type="text"><![CDATA[前言最近发现了基于node的一个发送邮件的小插件，逛论坛看别人用它做了一些有意思的东西，也模仿着搞一个分享下~重在分享，重在分享！ 期望1. 目标使用基于nodeJs的nodemailer定时发送随机文案给指定人。 2. 场景 定时发送情话给对象 每日发送给自己朋友圈文案内容 … 实现1. 所需技术 基础js即可 2. 所需环境/插件 nodeJs (环境) nodemailer(发送邮件插件) axios(获取邮件内容，如朋友圈文案、毒鸡汤等) schedule(定时任务插件) 3. 其他除上述内容，我们需要有邮件相关信息:自己邮箱和对方邮箱、邮箱服务器地址及端口号、自己邮箱的授权码等。下面会有比较详细的介绍。 实现过程1. node环境安装首先安装及配置node环境，官网下载安装即可。node中文网 2. 插件安装自己按照需求安装即可： 12345678// nodemailer：必须npm i nodemailer// axios：获取随机鸡汤（毒鸡汤）作为邮件内容；非必须npm i axios// schedule：定时任务；非必须npm i schedule 3. 项目配置 新建个空目录作为项目目录 在终端（或者cmd模式）—— npm init 项目目录下新建index.js 4. index详细配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const nodemailer = require('nodemailer');const &#123; default: Axios &#125; = require('axios');const schedule = require('node-schedule')// 获取文案const getMsg = () =&gt; &#123; // 提供几个文案获取接口,随便选即可。 // 毒鸡汤： https://du.shadiao.app/api.php // 朋友圈： https://pyq.shadiao.app/api.php // 彩虹屁： https://chp.shadiao.app/api.php // 骂人宝典： https://nmsl.shadiao.app/api.php let url = 'https://du.shadiao.app/api.php'; return Axios.get(url);&#125;// 发送邮件函数const sendEmail = async msg =&gt; &#123; let myEmail = "xxxxxx@163.com"; // 用户(自己)邮箱 let passCode = "xxxxxx"; // 用户(自己)邮箱授权码 let mailTo = "xxxxxx@xxx.xxx"; // 对方邮箱 // 用户账号信息,以163邮箱为例 let transporter = nodemailer.createTransport(&#123; host: 'smtp.163.com', // 服务器地址 port: 25, // 协议端口号 auth: &#123; user: myEmail, // 用户邮箱 pass: passCode // 授权码 &#125; &#125;); // 发送内容编辑 let mailMsg = await transporter.sendMail(&#123; from: myEmail, // 发件人(自己) to: mailTo, // 收件人 subject: 'mailer测试：毒鸡汤文案', // 标题 text: msg &#125;) // 成功后打印下~ console.log(`发送成功，发送内容为：$&#123;msg&#125;`);&#125;// 定时发送 每天中午12:30（自己随便改） 发送自己“喜欢”的内容给指定人schedule.scheduleJob(&#123; hour: 12, minute: 30&#125;, () =&gt; &#123; console.log(`启动任务：$&#123;new Date()&#125;`); getMsg().then(res =&gt; &#123; sendEmail(res.data); // 发送邮件 &#125;)&#125;)// 测试// console.log(`启动任务：$&#123;new Date()&#125;`);// getMsg().then(res =&gt; &#123;// sendEmail(res.data); // 发送邮件// &#125;) 小结通过上述代码，完成简易的每日毒鸡汤发送给相应邮箱。但我们可以看出，这只是基于node的一些个小插件的使用而已。虽然简单，但是发挥一下，在合适的时间用在合适的地方还是会有一些效果出现的~ 喜欢的可以关注公众号【流眸】回复【201219】获取该项目代码~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>node</tag>
        <tag>nodemailer</tag>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue首页白屏清除缓存解决方案]]></title>
    <url>%2F2020%2F12%2F03%2Fvue%E9%A6%96%E9%A1%B5%E7%99%BD%E5%B1%8F%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[发现问题近期vue项目在构建完成上线之后，每次往线上更新版本，总会收到一部分反馈——web页面白屏，需要清除缓存数据重新加载才能正常访问。 问题分析首先排除掉了publicPath设置问题，因为大部分用户能正常访问到页面，无报错。其次排除首页加载过慢问题，因为白屏无论多久都不会渲染页面。最终定位到缓存问题，产生原因如下： 在首次上线项目时，build生成的资源文件直接放到服务端上线即可。但是当第n（n&gt;1）次上线后，由于在用户端会默认缓存index.html入口文件，而由于vue打包生成的css/js都是哈希值，跟上次的文件名都不同，因此会出现找不到css/js的情况，导致白屏的产生。 优化方案1. meta标签1234&lt;meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /&gt;&lt;meta http-equiv="Pragma" content="no-cache" /&gt;&lt;meta http-equiv="Expires" content="0" /&gt;&lt;meta http-equiv="Cache" content="no-cache"&gt; 2. 时间戳区分在项目的配置页面添加打包配置，根据vue脚手架不同分以下两种情况： vue-cli@2.x 123456789// webpack.prod.conf.jsconst Timestamp = new Date().getTime();...output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].[chunkhash].' + Timestamp + 'js'), chunkFilename: utils.assetsPath('js/[id].[chunkhash].' + Timestamp + 'js')&#125; vue-cli@3.x 12345678910111213141516171819// vue.config.jsconst Timestamp = new Date().getTime();...module.exports = &#123; configureWebpack: config =&gt; &#123; config.output.filename = `js/[name].$&#123;Timestamp&#125;.js?t=[hash]`; config.output.chunkFilename = `js/[id].$&#123;Timestamp&#125;.js?t=[hash]`; &#125;, chainWebpack: config =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置... config.plugin('extract-css').tap(args =&gt; [&#123; filename: `css/[name].$&#123;Timestamp&#125;.css`, chunkFilename: `css/[name].$&#123;Timestamp&#125;.css` &#125;]) &#125; &#125;,&#125; 3. 服务端配置(nginx)这个有非常重要，需要跟服务端同事沟通，请他们在服务端配合配置nginx服务。服务端配置主要解决： 设置index.html在用户端不缓存，这样每次拉取的都是线上最新资源； 设置css和js文件一定的缓存期，合理利用缓存。 这样配置的好处是，如果线上资源没有更新，我们合理的利用缓存对大体积资源（样式脚本等）缓存，如果更新了资源，那么index.html文件则实时更新，用户端所得到的html文件也是最新资源，样式及脚本资源都会重新获取服务器最新资源缓存到本地。 12345678910111213141516171819202122232425262728293031323334353637383940server &#123; listen 90; server_name 22782.s1.natapp.cc; location / &#123; root /apps/laikePay/; try_files $uri $uri/ /index.html; &#125; location ^~ /beauty/&#123; alias /apps/laikeBeauty/; #以下配置解决html不缓存，css和js分别缓存7天和30天 if ($request_filename ~* .*\.(?:htm|html)$) &#123; add_header Cache-Control "private, no-store, no-cache"; &#125; if ($request_filename ~* .*\.(?:js|css)$) &#123; add_header Cache-Control max-age=604800; &#125; if ($request_filename ~* .*\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm)$) &#123; add_header Cache-Control max-age=2592000; &#125; try_files $uri $uri/ /beauty/index.html; &#125; location ^~ /beautyThemeChange/&#123; alias /apps/laikeBeautyThemeChange/; try_files $uri $uri/ /beautyThemeChange/index.html; &#125; location ^~ /retail/&#123; # alias /apps/laikeRetail/; # try_files $uri $uri/ /retail/index.html; proxy_pass http://22782.s1.natapp.cc/beauty/; &#125; #location ^~ /merchantPhoneApp/ &#123; #alias /apps/merchantPhoneApp/; #try_files $uri $uri/ /merchantPhoneApp/index.html; #&#125;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——JS打包工具]]></title>
    <url>%2F2020%2F10%2F28%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[前言前面篇章叙述了关于webpack的许多内容，从入门，打包第一个模块，到进阶，最后到本地、生产及打包的优化。本篇则提及一下在JavaScript社区中另外的一些类似的打包工具，它们有的更加轻量、简洁，有的则更专注于某类特定场景等。通过了解这些，希望会有助于我们开发时从更多的角度和方向来认识打包工具及其发展，进而选用更加适合我们项目的打包工具。 1. Rollup Rollup专注于JavaScript的打包。 它当然也支持其他类型的模块，但是总体而言在通用性是不及webpack，但讨论专注性，Rollup则更像一把手术刀，能精准的瞄准于JavaScript。如果有项目需求仅仅是打包JavaScript，那么Rollup则更可能是我们的第一选择。 1.1 配置简单示例下Rollup是如何工作的。 首先全局安装Rollup 1npm install rollup -g 然后创建Rollup配置文件rollup.config.js以及需要打包的项目文件app.js： 12345678// rollup.config.jsmodule exports = &#123; input: 'src/app.js', output: &#123; file: 'dist/bundle.js', format: 'cjs' &#125;&#125; 12// src/app.jsconsole.log('This is a App with Rollup ~'); 接下来执行指令进行打包： 1rollup -c rollup.config.js 其中，-c参数是告诉Rollup使用该配置文件。 打包结果如下： 12'use strict';console.log('This is a App with Rollup ~'); 从上可以看出，打包出来的资源文件非常干净，Rollup没有添加额外代码，甚至连第一行的use strict都可以通过配置去掉。而如果我们使用webpack去打包处理，则会多出许多冗余产物，即使我们将上述的一行js进行打包，打包后资源文件也至少会有几十行代码存在。 显然，如果针对于JavaScript进行打包处理，Rollup更为符合我们的预期。 1.2 tree shaking上一篇也描述过关于tree shaking，用来检测和去除死代码。而实际上最初tree shaking这个特性是由Roolup实现的，然后被Webpack借鉴。 Rollup的tree shaking也是基于ES6 Modules的静态分析，找出没有被引用的模块，将其从最后生成的bundle中排除。 例： 123// app.jsimport &#123; add &#125; from './util.js';console.log(`1 + 2 = $&#123;add(1, 2)&#125;`); 12345678// util.jsexport function add(a, b) &#123; return a + b;&#125;export function sub(a, b) &#123; return a - b;&#125; 可以看到，在这个简单工程中，sub方法没有被引用。 执行命令对其打包后，发现： 1234567'use strict';function add(a, b) &#123; return a + b;&#125;console.log(`1 + 2 = $&#123;add(1, 2)&#125;`); 从打包结果看，bundle也如我们所期望，输出的内容简洁，无任何附加代码，且sub函数也没有被打包进来。 1.3 可选的输出格式在webpack中，无法选择输出资源的模块形式，例如amd、esm、umd、system等，而在Rollup中可以通过配置output.format开发者选择输出资源的模块形式。 这个特性对于打包JavaScript库很有用，因为一个库往往需要支持多种不同的模块形式，而通过Rollup几个命令就可以将一份源代码打包为多份支持不同模式的资源文件。 例： 1234567'use strict';export function add(a, b) &#123; return a + b;&#125;export function sub(a, b) &#123; return a - b;&#125; 当output.format是cjs时（cjs:CommonJs），则输出是： 123456789Object.defineProperty(exports, '__esModule', &#123;value: true&#125;);function add(a, b) &#123; return a + b;&#125;function sub(a, b) &#123; return a - b;&#125;exports.add = add;exports.sub = sub; 当时esm时（ES6 Modules），输出则是： 1234567function add(a, b) &#123; return a + b;&#125;function sub(a, b) &#123; return a - b;&#125;export &#123; add, sub &#125; 1.4 使用Rollup构建JavaScript库在实际使用中，Rollup经常被用于打包一些库或框架（例如Vue、React等）。在React团队的一篇文章中曾提到使用Rollup的获益： 最低限度的附加代码 对ES6 Modules的良好支持 通过tree shaking去除开发环境代码 通过自定义插件来实现React的一些特殊的打包逻辑 Rollup在设计之初就是主要偏向于JavaScript库的构建，以至于它并没有像Webpack那样对于应用开发有很大的支持，所以我们使用Rollup之前要斟酌下是否偏向自己的项目需求。 2. ParcelParcel在前端打包工具中属于后起之秀：2017年8月才在npm上有版本记录。而其出名的则是打包速度：“Parcel官网中宣称自己是零配置的，在有缓存的情况下其打包速度比webpack快近8倍。”它的出现，则是正好契合了当时开发者对于Webpack打包速度慢和配置复杂的抱怨，从而吸引许多用户转用Parcel。 2.1 打包速度Parcel在打包速度的优化上主要做了3件事： 利用worker来并行执行任务 文件系统缓存 资源编译处理流程优化 这三点的前两点其实Webpack已经在做，在此不再详细分析。重点看第三点。 例如对于babel-loader的工作流程进行分析，大体为以下几步： 将ES6形式的字符串内容解析为AST（抽象语法树）； 对AST进行语法转换； 生成ES5代码，并作为字符串返回。 这是一个很正常的资源处理过程，但假设是多个loader一次对资源进行处理呢？ 对此，Parcel的处理流程很简单，它并没有loader的概念，而是自己的一套体系处理：它在不同的编译处理流程之间可以用AST作为输入和输出，不需要转换为字符串处理。对于单个的每一步来说，如果前面已经解析过AST，那么直接使用上一步解析和转换好的AST就可以，只需要在最后一步输出的时候再将AST转回字符串即可。如此说来，中间的流程处理由多次变为了一次，能够节省的时间可不是一星半点！ 2.2 零配置请看例子： 123456&lt;!-- index.html --&gt;&lt;html&gt;&lt;body&gt; &lt;script src="./bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12// index.jsdocument.write('Hello Parcel!'); 先全局安装parcel： 1npm install parcel -g 然后执行打包命令： 123parcel index.html// 如果要打包为文件，则执行如下：parcel build index.html 如果不加build，则是开发模式，使用浏览器则可以观察：localhost:1234。 如果打包为文件，则会创建一个dist文件目录，资源会添加到该目录下。 其实对于一个正常的前端项目来说，一般都会有一些配置的，不然也就失去了定制性。虽然parcel并没有配置文件，但是本质上它还是把配置进行了切分，交给babel、postHTML、postCSS等一些特定的工具进行了管理。 与Webpack相比，Parcel优势在于快速和灵巧，如果针对于不需要深度定制并且要求短时间搭建，那么Parcel则也可以作为一个比较好的选择来作为备选。 小结本篇介绍了JavaScript社区中两个除了webpack之外比较主流的两个打包工具：Rollup和Parcel。 Rollup更专注于JavaScript的打包，本身附加的代码更少，具备tree shaking，可以输出多种形式的模块。 Parcel则在资源处理流程方面做了改进优化，以追求更快的打包速度。同时零配置的特性可以减少很多项目开发中花费在环境维护上的成本。 在进行技术选型的时候，我们不仅要结合目前工具特性，更是要选择出针对我们项目进行特定考察，以及对项目之后的扩展也要考虑在内，从而结合多方面选择对项目最有利的工具来使用。同时我们也要看此工具在社区中的生态，是否能保持良好的社区生态以及维护状况，亦是我们需要考虑在内的因素之一。 webpack实战系列内容到此结束~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——打包优化【下】]]></title>
    <url>%2F2020%2F10%2F27%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E3%80%90%E4%B8%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[前言这是webpack打包优化【下】篇。前几篇针对性能要求高的项目从加快打包速度、减小资源体积方面入手，提出了一些优化政策，然后测试都可起到一定优化效果。本篇描述死代码的检测与去除。 tree shaking1 死代码检测去除首先抛出问题，什么是死代码？ 工程中没有被引用过的模块，这部分代码将永远无法被执行，称为“死代码”。 那知道了什么是死代码，如何检测去除呢？ 在前面我们介绍过，ES6 module 依赖关系的构建是在代码编译时而非运行时。基于这项特性webpack提供了tree shaking功能。这个功能便可以在打包过程中帮助我们检测没有被引用的模块，然后对这部分代码进行标记，并在资源压缩时将它们从最终的bundle中去掉。 例： 123// index.jsimport &#123; foo &#125; from './util';foo(); 1234567// util.jsexport function foo() &#123; console.log('this is foo');&#125;export function bar() &#123; // 没有被任何其他模块引用，因此属于死代码 console.log('this is bar');&#125; 那么在webpack打包时就会对bar()添加一个标记，在正常本地开发环境下它依然会存在，但是在生产环境压缩资源那一环节则会被移除掉。 tree shaking有时可以使得bundle资源体积显著减小，但需要一些前提条件。 2 ES6 Moduletree shaking 只对ES6 Module生效。 有时候我们发现算只引用了某个库中的一个接口，却把整个库都加载了进来，使得bundle体积并没有什么变化，可能原因是该库是用CommonJS导出的，而不是ES6 Module。当然，为了更好地向下兼容，自然是使用CommonJS形式是库依然很多。而排开第三方库，在我们自己书写模块或者库时，可以尽可能的选择ES6 Module形式导出，这样tree shaking的效率会更高。 3 使用webpack进行依赖关系构建一般我们都会在工程中使用到babel-loader，如果我们有使用到，那么一定要通过禁止它的模块依赖解析。原因是如果我们使用babel-loader来做依赖解析，那么webpack接收到的一般都是转化过的CommonJS形式的模块，那就无法对其进行tree shaking。 禁用babel-loader模块依赖解析配置如下： 1234567891011121314151617181920212223// webpack.config.jsmodule.exports = &#123; ... module: &#123; ryles: [ &#123; test: /\.js$/, exclude: /node_modules/, use: [ &#123; loader: 'babel-loader', options: &#123; presets: [ // 在这里加上modules: false [@babel/preset-env, &#123; modules: false &#125;] ] &#125; &#125; ] &#125; ] &#125;&#125; 4. 使用压缩工具去除死代码tree shaking本身只是为死代码添加上标记，而真正意义上去除死代码则是通过压缩工具来进行的，而此工具之前介绍过：terser-webpack-plugin。在此不再赘述。 小结通过【上】【中】【下】三篇描述，介绍的一些打包优化的方案均可以对项目有不同程度的优化，无论是打包速度还是减小资源体积，都有涉及。然而我们更需要清楚地了解到每一种优化策略都有其使用场景，并不是任何一个点放在一切项目中都有效。 当然，我们更需要不断培养自己的能力，当发现性能问题时，根据现有情况自己多加思考，分析出原因，然后对症下药。 下一篇介绍更多的JavaScript打包工具。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——打包优化【中】]]></title>
    <url>%2F2020%2F10%2F19%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E3%80%90%E4%B8%AD%E3%80%91%2F</url>
    <content type="text"><![CDATA[前言上篇从多线程打包和缩小打包作用域两个方面入手，对webpack打包层面做出优化。本篇描述从动态链接库思想方面继续深入探究打包层面的深度优化。 动态链接库与DLLPlugin 动态链接库（Dynamic Link Library 或者 Dynamic-link Library，缩写为 DLL），是微软公司在微软Windows操作系统中，实现共享函数库概念的一种方式。这些库函数的扩展名是 ”.dll”、”.ocx”（包含ActiveX控制的库）或者 “.drv”（旧式的系统驱动程序）。 当一段相同的子程序被多个程序调用时，为了减少内存消耗，可以将这段子程序存储为一个可执行文件，当被多个程序调用时只在内存中生成和使用同一个实例。 今天要介绍的主角“DLLPlugin”则借鉴了动态链接库的思路，对于第三方模块或者一些不常变化的模块预先进行编译和打包，然后再项目实际构建过程中直接取用。不过区别还是有的，DLLPlugin实际生成的文件是JS文件而不是动态链接库。在打包vendor的时候还会附加生成一份vendor的模块清单，这份清单将会在工程业务模块打包时起到链接和索引的作用。 1 vendor配置首先需要为动态链接库单独创建一个Webpack配置文件，例如：webpack.vendor.config.js，注意要与webpack.config.js区分开来。 例： 1234567891011121314151617181920// webpack.vendor.config.jsconst path = require('path');const webpack = require('webpack');const dllAssetPath = path.join(__dirname, 'dll');const dllLibraryName = 'dllExample';module.exports = &#123; entry: ['react'], output: &#123; path: dllAssetPath, filename: 'vendor.js', library: dllLibraryName &#125;, plugins: [ new webpack.DllPlugin(&#123; name: dllLibraryName, path: path.join(dllAssetPath, 'manifest.json') &#125;) ]&#125; 其中，entry指定了将哪些模块打包为vendor，plugins的部分引入了DLLPlugin，并有如下配置： name: 导出的dll library的名字，需要与output.library的值对应； path: 资源清单的绝对路径，业务打包时将会使用这个清单进行模块索引； 2 vendor打包接下来就要打包vendor并且生成资源清单。为后续方便操作，可以在package.json中配置一条运行指令： 12345678// pachage.json&#123; ... "scripts": &#123; ... "dll": "webpack --config webpack.vendor.config.js" &#125;&#125; 然后执行npm run dll，会发现生成了一个dll目录，里面对应有两个文件： vendor.js： 库的代码 manifest.json： 资源清单 感兴趣的可以打开这两个文件阅读一下。 3 链接到业务代码试过之后，我们就要考虑将vendor链接到项目中去了。这里推荐与DLLPlugin配套的插件“DLLReferencePlugin”，它起到索引和链接作用。在工程的webpack配置文件中（注意是webpack.config.js，不是vendor的配置文件），通过DLLReferencePlugin来获取刚才打包好的资源清单，然后在页面中添加vendor.js就可以引用。 1234567891011// webpack.cinfig.jsconst path = require('path');const webpack = require('webpack');module.exports = &#123; ... plugins: [ new webpack.DllReferencePlugin(&#123; manifest: require(path.join(__dirname, 'dll/manifest.json') &#125;) ]&#125; 那么 index.html 引入会即可： 12345678...&lt;body&gt;...&lt;script src="dll/vendor.js"&gt;&lt;/script&gt;&lt;script src="dist/app.js"&gt;&lt;/script&gt;&lt;/body&gt; 设置完毕后，当页面执行到vendor.js时，会声明全局变量dllExample，而manifest相当于注入app.js的资源地图，app.js会通过name字段找到名为DLLExample的library，再进一步获取其内部模块。 4 潜在问题细心的小伙伴或许已经发现了，在当前配置中会存在一个问题：当打开manifest.json文件后，可以发现每个模块都会有一个id，其值是按照数字顺序递增的，而业务代码在引用vendor中模块时也是引用这个数字id，当我们更vendor时这个数字id也会随之发生改变。 现假设我们工程目录中有如下资源文件，并每个资源都加上了chunk hash： vendor@[hasn].js pageUser@[hasn].js pageIndex@[hasn].js util@[hasn].js 现在vendor中you一些模块，例如包含了react，其id为5.当尝试添加更多模块到vendor中的时候，那么重新进行Dll构建时，moment.js可能出现在react之前，此时react的id会变为6.而pageUser和pageIndex是通过id进行引用的，因此他们的文件内容也发生了改变。此时我们会面临如下情况： 两个页面的chunk hash均发生了改变。这是我们不希望看到的，因为他们本身并无变化，但是vendor的改变却驱使用户不得不重新下载所有资源。 两个页面chunk hash没有改变，但是这种情况更为糟糕：vendor中的模块id改变了，但是用户没有更新缓存，使用的还是旧版本的内容，而引用不到新的vendor模块，导致页面发生错误。并且对于开发者而言，这个错误却难以排查，因为开发环境下一切正常！ 针对上述的问题2，解决方法是在打包vendor时添加上HashedModuleIdsPlugin，如下： 123456789101112// webpack.vendor.config.jsmodule.exports = &#123; ... plugins: [ new webpack.DllPlugin(&#123; name: dllLibraryName, path: path.join(dllAssetPath, 'manifest.json') &#125;), // 添加HashedModuleIdsPlugin new webpack.HashedModuleIdsPlugin(); ]&#125; HashedModuleIdsPlugin是webpack3中被引入进来的，主要就是为了解决数字id的问题。HashedModuleIdsPlugin可以把id的生成算法修改为根据模块的引用路径生成一个字符串hash。 注：从webpack3开始，模块id不仅可以是数字，也可以是字符串。 小结本篇从动态链接库思想着手，介绍了DLLPlugin与其配套插件DLLReferencePlugin使用，将第三方库与一些不常改动的模块编译打包，处理为类似于动态链接库的JS文件，以此来节约服务器资源。下一篇介绍打包优化最后一个环节：死代码检测与去除。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——打包优化【上】]]></title>
    <url>%2F2020%2F10%2F10%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E3%80%90%E4%B8%8A%E3%80%91%2F</url>
    <content type="text"><![CDATA[前言本篇介绍一些webpack优化的配置方法，目的有二： 打包速度更快 输出资源更小 注意：在软件工程领域有一条十分重要的功能经验，不要过早优化。在项目初期不要看到一个可以优化的点就去做优化，这样极有可能会增加尤其开发及维护的复杂度，并且从整体效果看，优化效果不会太理想。 1. HappyPack HappyPack是一个通过多线程来提升webpack打包速度的工具 1.1 工作原理在打工过程中，非常耗时的一个工作是使用loader将各种资源进行转译处理，例如常见的使用babel-loader将ES6+语法代码转译为ES5等。代码转移的工作流程如下： 从配置中获取打包入口； 匹配loader规则，并对入口模块进行转译； 对转译后的模块进行依赖查找； 对新找到的模块重复步骤2)和3)，直到没有新的依赖模块。 从上述步骤中可以看出，从步骤2)到步骤4)其实是一个递归的过程，webpack需要一步步地获取更下一级的资源然后逐个进行转译。为什么逐个？问题就在于webpack是单线程的。而HappyPack便将这里作为切入口，它的核心特性是可以开启多个线程，并行的对不同模块进行转译，这样便更加充分的利用计算机资源来提升打包速度。 1.2 工程目标HappyPack显然更加适用于转译任务比较繁重的工程，当我们把类似babel-loadre，ts-loader等迁移到HappyPack之上后，一般会有比较不错的效果，而对于sass-loader等本身消耗时间并不太多的功能则效果一般。 1.3 单个loader优化以babel-loader为例： 12345678910111213141516// 初始webpack.config.jsmodule.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel-loader', options: &#123; presets: ['react'], &#125; &#125; ] &#125;&#125; 使用HappyPack： 1234567891011121314151617181920212223242526// 使用HappyPack：const HappyPack = require('happypack');module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, loader: 'happypack/loader' &#125; ] &#125;, plugin: [ new HappyPack(&#123; loaders: [ &#123; loader: 'babel-loader', options: &#123; presets: ['react'] &#125; &#125; ] &#125;) ]&#125; 在module.rules中，我们使用happypack/loader替换掉了原来的babel-loader，而在plugins中添加了HappyPack插件，将原来的bebel-loader及其配置插入进去即可。 1.4 多个loader优化在使用HappyPack对多个loader进行优化时，需要为每一个loader配置一个id，否则HappyPack无法知道rules与plugins的对应关系。 这里以babel-loader及ts-loader为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243// webpack.config.jsconst HappyPack = require('happypack');module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, loader: 'happypack/loader?id=js' &#125;, &#123; test: /\.ts$/, exclude: /node_modules/, loader: 'happypack/loader?id=ts' &#125; ] &#125;, plugin: [ new HappyPack(&#123; id: 'js', loaders: [ &#123; loader: 'babel-loader', options: &#123; // babel配置 &#125; &#125; ] &#125;), new HappyPack(&#123; id: 'ts', loaders: [ &#123; loader: 'ts-loader', options: &#123; // ts配置 &#125; &#125; ] &#125;) ]&#125; 除上述配置之外，可以查阅官方文档查看更多的配置，例如线程数，debug模式等。 2. 缩小打包作用域从宏观角度看，提升性能的方式总结为两种： 增加资源： 使用更多的CPU和内存，用更多的计算能力来缩短任务执行时间； 缩小范围： 针对任务本身，去除冗余流程，不做重复性工作或使其简单化； 而上面我们所了解的HappyPack明显属于增加资源，那接下来介绍从缩小范围的几个方案。 2.1 exclude 和 include在前面章节（预处理器(loader)【上篇】）中，介绍过exclude和include，在配置loader的时候一般都会对其进行配置。对于JS来说，一般需要把node_modules目录排除掉，另外当exclude和include规则有重叠部分时，exclude优先级更高。 那对于此处，我们使用include让babel-loader只生效于源码目录： 123456789// webpack.config.js...module: &#123; rules: [ test: /\.js$/, include: /src\/scripts/, loader: 'babel-loader' ]&#125; 2.2 noParse有些库我们希望webpack完全不要去解析，那此时可以使用noParse对其进行忽略，如： 12345678// webpack.config.js// ...module.exports = &#123; noParse: &#123; // fullPath是绝对路径，如 /User/me/app/webpack/noparse/lib/lodash.js return /lib/.test(fullPath); &#125;&#125; 如上配置将忽略所有lib目录下的资源解析。 2.3 IgnorePluginexclude和include是确定loader的规则范围，noParse是不去解析但仍会打包到bundle中，那接下来介绍一个插件——IgnorePlugin，他可以完全排除一些模块，被排除的模块即使被引用也不会被打包进资源文件中。一般作用于排除一些库相关文件。 一个由库产生的额外资源我们用不到但没办法去掉时，可以考虑使用此方法处理。 例，一个日期时间处理的相关插件Moment.js，为了做本地化会加载许多语言包，但一般我们只会用到本地的语言包而不会使用其他地区的语言包，而语言包会占用很大体积，这时可以使用IgnorePlugin来做处理： 12345678// webpack.config.js...plugins: [ new webpack.IgnorePlugin(&#123; resourceRegexp: /^\.\/locale$/, // 匹配资源文件 contextRegExp: /moment$/ // 匹配检索目录 &#125;)] 2.4 Cache我们在使用某些loader时会有一个cache的配置项，用来在编译代码后同时保存一份缓存，在执行下一次编译前会优先检查源码文件是否有变化，没有则直接使用缓存结果，也就是上次编译的结果。这样一来，只有在发生变化时编译变化了的文件，对于整体而言也属于一种优化处理。 小结本篇从多线程打包和缩小打包作用域两个方面入手，对webpack打包层面做出优化。下一篇描述从动态链接库思想与死代码检测方面继续深入探究打包层面的深度优化。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——生产环境配置【下】]]></title>
    <url>%2F2020%2F09%2F18%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E3%80%90%E4%B8%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[前言这是webpack实战系列第12篇。 上两篇中，描述了一些关于生产环境的配置：环境变量的使用、配置文件描述、source-map配置、资源压缩等，从这几个方面入手来对生产环境进行一定的配置。 本篇将从缓存和资源bundle体积开始，来对生产环境进行进一步的处理。 1. 缓存 缓存是指重复利用浏览器已经获取过的资源。 合理的使用缓存是提升客户端性能的一个关键因素。具体的缓存策略（如指定缓存时间）由服务器来决定，浏览器会在资源过期前一直使用本地缓存进行响应。但同时也带来一个新的问题，比如我们想要对代码进行一个bug fix（故障修正程序），并且立即更新到用户的浏览器中，而不要让他们使用旧的缓存资源应该怎么处理呢？那此时最好的办法便是更改资源的URL，这样可迫使所有客户端资源都去下载最新的资源。 1.1 资源hash一个常用的方法是在每次打包的过程中对资源的内容计算一次hash，并作为版本号存放在文件名中，如*bundle@0sd5fd6fh8hf4g4d.js*。其中，bundle是文件本身的名字，而@后则跟随文件内容hash值，每当代码发生变化时，hash也会发生相应变化。 我们通常使用chunkhash来作为文件版本号，因为它会为每一个chunk单独计算一个hash值。如： 12345678// webpack.config.jsmodule.exports = &#123; entry: './src/index.js', output: &#123; filename: '[name]@[chunkhash].js' &#125;, mode: 'production'&#125; 打包结果： 1.2 输出动态HTML既然资源名字使用hash动态，那么也就意味着在HTML文件中引入的路径也会随之改变，而如果选择手动处理，不光是维护成本大，而且复杂程度相当高：如果有几十个文件变动……因此最理想的情况是打包结束后自动将最新的资源名字同步过去。此时，我们使用html-webpack-plugin来做到这一点： 1234567891011121314151617// webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; index: './src/index.js', &#125;, output: &#123; filename: '[name]@[chunkhash].js' &#125;, mode: 'development', plugins: [ new HtmlWebpackPlugin() ],&#125; 打包结果： 打包后，可以看到除了js文件之外还多出来了一个HTML文件： index.html 内容 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Webpack App&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="index%4061b65a6278687c007c6c.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 从html内容可以看出，html-webpack-plugin会自动将我们打包出来的资源名放入index.html中，如上述的src=&quot;index%4061b65a6278687c007c6c.js(其中 %40是@的编码 )，这样我们便不再需要手动的去更新资源url了。 HTML模板 虽然是我们通过html-webpack-plugin创建出来一个index.html文件，但是在大多数情况下，此种条件并不符合我们项目工程中的常规操作，因为我们需要在HTML中引入一些个性化的内容，这这是，我们可以传入一个已有的HTML模板，如： 1234567891011121314&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;自定义配置模板&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;p&gt;随便一些内容...&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; webpack配置 12345678910const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; ... plugins: [ new HtmlWebpackPlugin(&#123; template: './index.html' &#125;) ]&#125; 然后再次打包，结果如下： 2. 体积监控和分析为保证良好的用户体验，我们可以对打包输出的bundle体积进行持续的监控，以防止不必要的冗余模块被添加进来。 介绍两个工具来协助我们对体积进行监控和分析。 2.1 Import Cost在VS Code中，安装插件Import Cost，这个插件可以帮助我们对引入的模块大小进行实时监测。每在我们代码中引入一个新的模块后，它会为我们计算该模块压缩后及gzip后将占用体积的大小。 当我们检测到引入的某些模块包过大时，我们可以想办法处理它，比如寻找一些更小的包或模块作为替代方案，或者引入其子模块而不是全局引入。 2.2 webpack-bundle-analyzer 作用：分析一个bundle的构成。 安装123yarn add webpack-bundle-analyzer// ornpm install webpack-bundle-analyzer --save-dev 配置1234567891011121314151617// webpack.config.jsconst WebpackBundleAnalyzer = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;module.exports = &#123; entry: &#123; index: './src/index.js', &#125;, output: &#123; filename: '[name]@[chunkhash].js' &#125;, mode: 'development', plugins: [ new WebpackBundleAnalyzer() ],&#125; 打包执行打包命令，然后会从本地浏览器自动打开一个包体积监测的页面，如下： 从上图我们可以直观的看到生成的 index@hash.js 文件中包含的各个模块及其占体积占比，这样我们也能直观的看出需要从某个模块进行优化。 2.3 bundlesize 自动化监测那刚才所描述的只是打包后查看，如果希望自动化的对资源体积进行监控呢？bundlesize 这个工具则可以协助我们做到。 同样，先安装： 123yarn add bundlesize// ornpm install bundlesize 然后在 package.json 中配置： 123456789101112131415&#123; "name": "w1", "version": "1.0.0", "main": "index.js", "bundlesize": [ &#123; "path": "./src/index.js", "maxSize": "10 kB" &#125; ], "scripts": &#123; "test:size": "bundlesize" &#125; ...&#125; 可以看到，我设置了 bundlesize 的路径及最大体积限制，然后在 scripts 中添加了一条脚本命令。然后在终端执行该脚本，如图： 小结对生产环境配置做个小结。 在开发环境中，我们注重打包速度，而生产环境中我们则关注资源输出体积大小及如何优化客户端缓存来缩短页面渲染时间，通过一系列配置可以优化，如：设置环境变量、代码压缩、资源体积检测监控等方法。我们也对缓存的控制有一定的了解，缓存的控制主要依赖于chunk内容生成hash作为版本号，并添加到资源文件名中，使得资源更新后客户端可以及时更新最新资源。 此外，source map主要用于线上问题的追溯，不过存在安全隐患，可以通过一些特殊的配置来兼顾追溯及安全问题。 描述完了生产环境配置，那么下一阶段来到打包优化问题。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——生产环境配置【中】]]></title>
    <url>%2F2020%2F09%2F07%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E3%80%90%E4%B8%AD%E3%80%91%2F</url>
    <content type="text"><![CDATA[前言上一篇中，描述了一些关于生产环境的配置：环境变量的使用、配置文件描述、开启生产模式、环境变量自定义配置等，从这几个方面入手都可以对生产环境产生一些有利影响。 那么本篇，从source map和资源压缩方面入手，继续深入探究。 1. source map source map 指的是将编译、打包、压缩后的代码映射回源代码的过程。 经过webpack打包压缩后的代码基本上已经不具备可读性，此时若是代码抛出错误，想要回溯它的调用栈是非常困难的，而有了source map，加上浏览器调试工具（dev tools），要做到这一点就会变得很容易。同时，它对于线上问题的追查也有一定帮助。 1.1 原理工作原理：webpack对于工程源代码的每一步处理都有可能会改变代码的位置、结构、甚至是所处文件，因此每一步都需要生成对应的source map。如果我们启用了devtool配置，那么source map就会跟随源代码一步步被传递，直到生成最后的map文件。这个文件默认就是打包后的文件名字上加上后缀[.map]，例如bundle.js.map。 在生成map文件的同时，bundle文件中会追加一句注释来标识map文件的位置，例如： 123456// bundle.js(function() &#123; // bundle的内容 ...&#125;)()// # sourceMappingURL=bundle.js.map 而当我们打开浏览器开发者工具后，其实map文件同时也会被加载进来，这时浏览器会使用它来对打包后的bundle文件来进行解析，分析出源代码的目录结构和内容。 亲自尝试过的朋友可能会发现，打包后，map文件会比较大，甚至超出源文件几倍的体积大小，不过不用担心，不打开开发者工具是不会加载这些map文件的，因此对于普通用户来讲没有什么影响。但是要注意的是，虽然普通用户看不到，不过有经验的“特殊人群”还是可以通过dev tools看到工程源码的。因此建议如果是生产环境，还是要解决一下。如何解决呢？下面会提到。 1.2 配置在webpack.config.js中添加devtool即可完成对source map的配置。 12345// webpack.config.jsmodule.exports = &#123; // ... devtool: 'source-map'&#125; 而对于CSS、SCSS及Less来说，则需要添加额外的source map配置项。如： 12345678910111213141516171819202122232425262728const path = require('path');module.exports = &#123; // ... devtool: 'source-map', module: &#123; rules: [ // scss &#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; sourceMap: true, &#125; &#125;, &#123; loader: 'sass-loader', options: &#123; sourceMap: true &#125; &#125; ] &#125; ] &#125;&#125; webpack给出多种source map形式： source-map cheap-source-map eval-source-map … 在开发环境中，通常使用module-eval-source-map，因为在打包速度和源码信息还原程度都属于良好程度。 而在生产环境中，通常我们会对代码进行压缩，而最常见的压缩插件UglifyjsWebpackPlugin目前只支持source-map形式。 1.3 安全在1.1中我们抛出一个安全问题，就是在开启source-map的时候任何人都可以通过浏览器的开发者工具devtool来看到工程源码，因此对于安全性来讲是一个极大的隐患。那么如何能在保持其功能的同时又能防止暴漏源码呢？ webpack提供了两种安全策略： hidden-source-map nosources-source-map hidden-source-map hidden-source-map意味着Webpack仍然会产出完整的map文件，但是不会在bundle文件中添加对于map文件的引用。这样当打开浏览器开发者工具时，是无法看到map文件的，自然也就无法解析。如果我们自己想要追溯源码，可使用一些第三方服务，将map文件上传到第三方服务中。目前比较流行的是Sentry（错误跟踪平台），有兴趣的可以自行搜索了解一下。 nosources-source-map 它对于安全性保护不如hidden-source-map，但是使用方式相对简单。当打包部署后，我们可以在浏览器开发者工具的sources选项卡中看到源码的目录结构，但是文件内容会被隐藏起来。这样，对于错误来讲，我们仍然可以在console控制台中查看源代码的错误栈，或者console日志的准确行数。对于追溯错误来说基本上够使用。 另外的方案则是服务端配合处理，例如正常打包出source map，服务端通过服务器的nginx配置，将.map文件只对固定的白名单（如公司内网）开放，这样其余用户就无法获取到它们了，也不失为一个小妙招。 2. 资源压缩 资源在发布到生产环境之前，通常会进行代码压缩，也叫uglify，意思是移除多余的空格、换行、执行不到的代码块等，同时缩短变量名，在执行结果不变的前提下替换为更短的形式。 一般工程代码在被压缩后整个体积会显著缩小。 但同时，uglify之后的代码基本上不具有可读性，从另一个层面讲，一定程度上提高了代码的安全性。 2.1 压缩JavaScript压缩JS（JavaScript）的工具terser(optomization)在webpack中已集成（webpack4），并且支持ES6+的代码压缩，偏面向未来。 示例： 1234567891011// webpack.config.jsmodule.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js' &#125;, // 压缩配置 optomization: &#123; minimize: true &#125;&#125; 2.2 压缩CSSCSS文件的压缩前提是使用相关插件处理，先将样式提取出来，然后进行压缩。例如常使用extract-text-webpack-plugin或mini-css-extract-plugin将样式提取，然后使用optimize-css-assets-webpack-plugin来进行压缩。这个插件本质上使用的是压缩器cssnano，当然我们可以对其进行配置： 12345678910111213141516171819202122232425262728293031323334353637// webpack.config.jsconst ExtractTextPlugin = require('extract-text-webpack-plugin');const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin')module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: 'css-loader' &#125;) &#125; ] &#125;, // css 压缩 plugins: [new ExtractTextPlugin('style.css')]; optimization: &#123; minimizer: [new OptimizeCssAssetsPlugin(&#123; // 生效范围，只压缩匹配到的资源 assetNameRegExp: /\.optimize\.css$/g, // 压缩处理器指定，默认为 cssnano cssProcessor: require('cssnano'), // 压缩处理器配置 cssProcessorOptions: &#123; discardComments: &#123; removeAll: true &#125; &#125;, // 是否打印log canPrint: true &#125;)] &#125;&#125; 小结本篇介绍了关于生产环境配置中比较重量级的两种配置：source-map和资源压缩。 开发环境中我们关注打包速度，而在生产环境中我们关心的则是线上错误处理、输出资源的体积以及资源渲染等问题，而比较好的利用source-map和资源压缩都可以帮助我们处理处理或优化生产环境中的一些问题，因此比较重要，但同时也要注意解决所存在的安全隐患问题。 下一篇则从缓存和bundle体积监控入手继续描述生产环境配置的其他方面优化问题。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——生产环境配置【上】]]></title>
    <url>%2F2020%2F09%2F02%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E3%80%90%E4%B8%8A%E3%80%91%2F</url>
    <content type="text"><![CDATA[前言这是webpack实战系列笔记的第10篇记录——生产环境配置【上篇】。 在前面的几篇中，介绍了webpack的大部分使用方法，使用其实就是为了上线，牵扯到生产环境，就会出现新的问题，比如： 如何让用户更快的加载资源 如何压缩资源 如何添加环境变量优化打包 如何最大限度的利用缓存 … 在生产环境配置篇中，将会一一介绍。本篇大致分为三个小篇，以上中下结构拆开描述。本篇描述：环境配置的封装、开启production模式、环境变量。 1. 环境变量的使用在开发环境中，我们设置过mode模式，而生产环境中，我们这需要更多的配置，如：mode、环境变量、版本号等，webpack可以使用两种方式来按照不同环境采用不同配置。 1.1 使用相同配置文件例如之前的webpack.config.js，可以在构建开始前将当前环境作为一个变量传进去，然后在js中通过判断来决定使用某个配置： 12345678// package.json&#123; ... "scripts": &#123; "dev": "ENV=development webpack-dev-server", "build": "ENV=production webpack" &#125;&#125; 12345678910// webpack.config.jsconst ENV = process.env.ENV;const isProd = ENV === 'production';module.exports = &#123; output: &#123; filename: isProd ? 'bundle@[chunkhash].js' : 'bundle.js' &#125;, mode: ENV,&#125; 从上配置可以看出，首先通过npm脚本传入了一个ENV的环境变量，而后在输出时，webpack中用三元表达式判断环境，生产环境则添加哈希值为版本信息，本地则直接输出。 1.2 多配置文件顾名思义：为不同环境创建不同的配置信息文件。 例如，可以单独创建一个webpack.development.config.js来配置开发环境信息，再创建一个webpack.production.config.js来配置生产环境信息。然后在package.json中修改： 1234567&#123; ... "scripts": &#123; "dev": "webpack-dev-server --config=webpack.development.config.js", "build": "webpack --config=webpack.prodection.config.js" &#125;&#125; 可以看到，上述的json文件中，通过 –config 来指定了打包时用哪一个文件，但其实会有一些小问题，比如两个配置文件会有重复的内容，不利于维护等，这时可以将重复配置提取出来写成公共配置文件，比如再新建一个文件 webpack.common.config.js 来存放公共部分： 123456// webpack.common.config.jsmodule.exports = &#123; entry: './src/index.js', // 公共配置 ...&#125; 写完之后，在开发与生产环境的webpack配置文件中，都引入该公共文件，然后加上自身的专属配置即可。 2. production模式在前面我们多次用到一个叫做mode的配置，其实这个配置时webpack4及之后才新添加的一个配置项，开发者可以直接使用这个配置来切换打包模式。例如： 12345// webpack.config.jsmodule.exports = &#123; ... mode: 'production'&#125; 这便意味着当前模式处于生产环境，那么webpack则会自动添加许多适用于生产环境的配置项，减少手动操作配置。而目的也是为了提供更加有利的开发环境，更少的代码，更少的配置，做更多的事儿。 然而，多数情况下，仅仅配置mode是难以达到我们希望的需求的，因此还是需要用到其他与生产环境配置相关联的其他配置项。 3. 环境变量通常，我们需要为生产环境和本地环境添加不同的环境变量，在webpack中可以试用DefinePlugin来进行设置。 3.1 字符串类型如： 1234567891011121314// webpack.config.jsconst webpack = require('webpack');module.exports = &#123; entry:'./src/index.js', output: &#123; filename: 'bundle.js' &#125;, mode: 'production', plugins: [ new webpack.DefinePlugin(&#123; ENV: JSON.stringify('production') &#125;) ]&#125; 12// index.jsconsole.log(ENV); 如上所示。通过配置DefinePlugin设置了ENV的环境变量，最终页控制台上打印的字符串会是production。 注意上面用到了JSON.stringify，因为DefinePlugin在替换环境变量时对于字符串类型的值是完全替换，如果不加的话，在替换后就会成为变量名而不是字符串。因此需要添加JSON.stringify。 3.2 其他类型在上面演示了字符串类型，当然也可以设置其他类型的环境变量。 123456789101112131415// webpack.config.jsmodule.exports = &#123; ... plugins: [ new webpack.DefinePlugin(&#123; ENV: JSON.stringify('production'), IS_PRODUCTION: true, ENV_ID: 80808888, CONSTANTS: JSON.stringify()&#123; TYPES: ['foo', 'bar'] &#125; &#125;) ]&#125; 3.3 其他说明很多框架中都会采用process.env.NODE_ENV来作为一个区别开发环境和生产环境的变量。 process.env是Node.js用于存放当前进程环境变量的对象 NODE_ENV则可以让开发者指定当前的运行时环境，值为production时代表生产环境。 在上述中，当库和框架在打包时如果发现是生产环境，那么就会去掉一些开发环境中的代码和配置，如警告信息，日志打印，断点等，也有助于提升生产环境的代码运行速度，并且优化包体积。 具体配置如下： 12345678910// webpack.config.jsmodule.exports = &#123; ... plugins: [ new webpack.DefinePlugin(&#123; process.env.NODE_ENV: 'production' &#125;) ]&#125; 如果启用了mode: production，那么webpack则已经设置好了process.env.NODE_ENV，自己则无需再手动操作 小结本篇描述了关于生产环境的一些配置：环境变量的使用，配置文件描述，生产模式开启，环境变量自定义配置等。从这几个方面入手都可以对生产环境产生一些有利影响。 下一篇更新从 [source map] 方面和 [ 资源压缩 ] 方面进行配置和优化处理。 更多关于webpack的基础讲解和进阶及性能调优方面欢迎关注公众号【流眸】回复关键词【webpack】获取~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——代码分片]]></title>
    <url>%2F2020%2F08%2F27%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E5%88%86%E7%89%87%2F</url>
    <content type="text"><![CDATA[前言这是webpack实战系列笔记的第9篇记录——代码分片，前几篇记录如下： 打包第一个应用 模块化与模块打包 资源输入与输出 一切皆模块 预处理器【上篇】 预处理器——常用loader【下篇】 样式文件分离 样式预处理 代码分片 实现高性能应用其中重要的一点就是尽可能的让用户每次只加载必要的资源，优先级不太高的资源则采用延迟加载（懒加载）等技术渐进式的获取，这样可以保证首屏页面加载的速度。代码分片是Webpack作为打包工具所特有的一项技术，通过这项技术我们可以把代码按照特定的形式进行拆分，使用户按需加载。 通过入口划分代码通过入口配置进行一些简单有效的代码拆分。 对于web应用来说通常会有一些库和工具是不常变动的，可以将它们放在一个单独的入口中，由该入口产生的资源不会经常更新，因此可以有效地利用客户端缓存，让用户不必在每次请求页面时都让资源重新加载。 1234567// webpack.config.js...entry:&#123; app: './src/app.js', lib: ['lib-a', 'lib-b', 'lib-c']&#125; 12345&lt;!--index.html--&gt;...&lt;script src="./dist/lib.js"&gt;&lt;/script&gt;&lt;script src="./dist/app.js"&gt;&lt;/script&gt; 这种拆分方法主要适用于那些将接口绑定在全局对象上的库，因为业务代码中的模块无法直接引用库中的模块，而这属于不同的依赖树。 但这样仍会带来新的问题：公共模块与业务模块处于不同依赖树的问题以及很多页面并不需要公共模块的问题。 optimization在webpack4之前，做代码切片使用的是CommonsChunkPlugin，而在4及之后，取而代之的是optimization。 optimization.SplitChunks简称optimization，是Webpack4为了改进CommonChunkPlugin而重新设计和实现的代码分片特性。 举例1. 安装1234// 两种方式二选一yarn add optimization react// 或npm install optimization react 2. a.js &amp; b.js1234// a.jsimport React from 'react'import('./b.js');document.write('a.js', React.version) 123// b.jsimport React from 'react'console.log('b.js', React.version) 3. webpack配置1234567891011121314// webpack.config.jsmodule.exports = &#123; entry: './src/a.js', output: &#123; filename: 'a.js', publicPath: '/dist/' &#125;, mode: 'development', optimization: &#123; splitChunks: &#123; chunks: 'all' &#125; &#125;&#125; 4. 打包123yarn build// 或npm run build 结果如图所示： 特性首先观察上面的配置，从上面的配置项中可以看到： 指定了chunks的值是all，含义是：SplitChunks将会对所有的chunks生效； mode：之前也一直在用，其实是Webpack4中新增的配置项，可以针对当前是开发环境还是生产环境自动添加一些对应的Webpack配置。 而从上图打包结果中看，可以看到三个文件包：0.a.js、a.js和vendors~main.a.js。其中，vendors~main.a.js则是将react提取到了里面。 提取条件 提取后的chunk可悲共享或者来自node_modules目录。 提取后的JS chunk体积大于30kB（压缩和gzip前），CSS chunk体积大于50kB。 按需加载过程中，并行请求的资源最大值小于等于5。 首次加载时，并行请求的资源数最大值小于等于3。 需要注意的是，默认提取方式为异步提取。 配置分为四类： 匹配模式通过chunks可以配置Splitchunks的工作模式：async（默认），initial和all。async即只提取异步chunk，initial只对入口chunk生效，all则两种模式同时开启。 匹配条件minSize、minChunks、maxAsyncRequests、maxInitialRequests都属于匹配条件。 命名配置项name默认为true，意味着SplitChunks可以根据CacheGroups和作用范围自动为新生成的chunk命名，并且以automaticNameDelimiter分割。 CacheGroups可以理解为分离chunks时的规则。 默认配置1234567891011121314151617181920212223242526272829module.exports = &#123; ... splitChunks: &#123; chunks: 'async', miSize: &#123; javascript: 30000, style: 50000, &#125;, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\/]node_modules[\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125;&#125; 小结本篇了解了两种代码分片方式： 入口规划 SplitChunks 而借助这些方法，我们可以有效的缩小资源体积，更好的利用缓存，从而给用户更有好的体验度。 下一篇介绍生产环境优化中的一些配置，如环境配置封装、sourceMap等。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——样式预处理]]></title>
    <url>%2F2020%2F08%2F22%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%A0%B7%E5%BC%8F%E9%A2%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言这是webpack实战系列笔记的第8篇记录——样式与处理，前几篇记录如下： 打包第一个应用 模块化与模块打包 资源输入与输出 一切皆模块 预处理器【上篇】 预处理器——常用loader【下篇】 样式文件分离 在目前的前端项目中，经常可以看到使用SASS和LESS来对CSS进行处理，那么在webpack中如何配置？ 样式预处理 样式预处理，指的是在开发中使用到的一些预编译语言，如SCSS. LESS等，在项目打包过程中再将这些预编译语言转换为CSS。 借助这些语言强大和便捷的特性，可以降低项目的开发及维护成本。 1. Sass 与 SCSS1.1 关系我们经常看到Sass与SCSS，但是有什么关系呢？我们怎么选择呢？ Sass是对CSS的语法增强，它有两种语法，现在使用的更多的是SCSS。如果你两者都使用过，那么可以发现无论是安装还是配置，都是使用 sass-loader，而编写保存的文件后缀却是：.scss。 一般而言，我们使用它需要配置以下几个loader搭配使用： sass-loader css-loader style-loader node-sass 如上，样式预处理器的安装好理解，那么为什么要安装node-loader呢？因为loader本身只是编译核心库与Webpack的连接器，因此这里我们除了Sass-loader以外还需安装node-sass，node-sass才是真正用来编译SCSS的，而sass-loader只是起到黏合作用。 1.2 安装1234// 以下两种方式任选其一npm install sass-loader node-sass css-loader style-loader// 或yarn add sass-loader node-sass css-loader style-loader 1.3 webpack配置123456789// webpack.config.jsmodule: &#123; rules: [ &#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125; ]&#125; 1.4 测试写一段scss测试一下： 1234567// style.scss$default-color: #f00;.main&#123; &amp;_banner&#123; color: $default-color; &#125;&#125; 12// index.jsimport './style.scss' 1.5 查看结果从html中引入打包后的js，查看结果： 123.main_banner &#123; color: #f00; &#125; 1.6 其他配置如果希望在浏览器的firebug里面查看及调试源码，则需要打开sourceMap配置： 1234567891011121314151617181920212223242526272829303132333435module.exports = &#123; entry: &#123; index: './src/index.js', &#125;, output: &#123; filename: '[name].js' &#125;, mode: 'development', // loader配置 module: &#123; rules: [ // scss &#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; sourceMap: true &#125; &#125;, &#123; loader: 'sass-loader', options: &#123; sourceMap: true &#125; &#125; ] &#125; ], &#125;,&#125; 2. Less Less也是对CSS的扩展。 2.1 安装1234// 以下两种方式任选其一npm install less-loader less css-loader style-loader// 或yarn add less-loader less css-loader style-loader 2.2 webpack配置与SCSS配置比较类似： 12345678910111213141516171819202122modules: &#123; rules: [ &#123; test: /\.less/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; sourceMap: true &#125; &#125;, &#123; loader: 'sass-loader', options: &#123; sourceMap: true &#125; &#125; ] &#125; ]&#125; 2.3 测试1234567// style.less@default-color: red;.main&#123; .title&#123; color: @default-color; &#125;&#125; 12// index.jsimport './style.less' 2.4 编译结果与SCSS一样，打包，引入，浏览器中查看结果： 123.main .title&#123; color: red;&#125; 小结本篇介绍了处理样式的预处理器工具以及相关配置，通过SCSS、less等编译语言来提高CSS的开发效率且降低代码复杂度。 下一篇开始接触与性能相关的问题——代码分片。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——分离样式文件]]></title>
    <url>%2F2020%2F08%2F11%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%88%86%E7%A6%BB%E6%A0%B7%E5%BC%8F%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言这是webpack实战系列笔记的第7篇记录——分离样式，前几篇记录如下： 打包第一个应用 模块化与模块打包 资源输入与输出 一切皆模块 预处理器【上篇】 预处理器——常用loader【下篇】 在之前篇章里面主要是对js的打包应用和处理，而打包方面另外一个重要工作就是样式处理。 在实际工程中，如果项目具有一定规模，那么CSS的维护成本则会比较高昂，这个时候就需要更友好且更低价的方式来处理样式问题。本篇介绍webpack结合样式编辑器、转换器及相关插件来提升样式方面的开发效率。 分离样式1. 分离样式文件概念在之前写的简单demo中，处理过关于CSS，并且在预处理器篇介绍过关于CSS的预处理器：style-loader和css-loader。通过JS引入CSS样式去打包，在编写阶段可以直观的描述出来模块之间的依赖关系。 但是问题随之而来：在打包后，我们对css样式的添加，是通过标签&lt;style&gt;来引入的，可生产环境下，一般我们希望样式存在于CSS文件中而不是style标签中，因为文件更有利于客户端进行缓存。那么我们怎么输出单独的CSS文件呢？ 2. mini-css-extract-plugin 该插件主要是用于提取样式到CSS文件的。 特性： 可处理多样式文件 支持按需加载 3 安装两种方式 选择一种即可 123yarn add mini-css-extract-plugin// 或npm install mini-css-extract-plugin 4. 举例举个例子： a.js引入自身a.css样式，并引入b.js，而b.js也有自身相应的b.css样式，那么最终样式会被同步加载，通过index.html的link标签加载进来。 a.js1234import './a.css'import './b.js'document.write('A.JS&lt;br/&gt;'); a.css123body&#123; background: deepskyblue;&#125; b.js123import './b.css'document.write('B.JS&lt;br/&gt;'); b.css123body&#123; background: thistle;&#125; webpack.config.js1234567891011121314151617181920212223242526272829303132333435363738const MiniCssExtractPlugin = require('mini-css-extract-plugin')module.exports = &#123; entry: &#123; index: './src/a.js', &#125;, output: &#123; filename: '[name].js' &#125;, mode: 'development', // loader配置 module: &#123; rules: [ // css &#123; test: /\.css$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: '../' &#125; &#125;, 'css-loader' ] &#125; ], &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].css', chunkFilename: '[id].css' &#125;) ]&#125; 打包123yarn build// 或npm run build HTML引入123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;link rel="stylesheet" href="./dist/index.css"&gt; &lt;title&gt;style&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="./dist/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果运行引入了脚本和样式的HTML文件，查看结果： 小结其实本篇就是单独拎出来了一个loader预处理器来介绍：mini-css-extract-plugin。目的就是生产环境下，通过link引入样式存在于CSS文件中而不是style标签中，这样更有利于客户端进行缓存。 下一篇介绍样式预处理。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>样式分离</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——预处理器(loader)【下篇】]]></title>
    <url>%2F2020%2F08%2F03%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8loader%2F</url>
    <content type="text"><![CDATA[写在前面这是webpack实战系列笔记的第6篇记录，前几篇记录如下： 打包第一个应用 模块化与模块打包 资源输入与输出 一切皆模块 预处理器【上篇】 在上一篇中根据一切皆模块的思想，学习了解了loader：概述、引入、配置及使用。本篇接着上篇的话题，讲述常用loader。 在我们项目开发中，尤其是目前流行的单页面应用，一些新手经常会在loader配置中有一些疑问，比如： 对于xx资源应该使用哪个loader？ 实现xx功能配置哪个loader？ … 常用loader介绍其实，在社区上每天都会有很多loader发布，开发者在选择loader的时候要多读一下loader文档，了解loader用法，优缺点，然后根据需求去挑选。接下来介绍几种常用loader。 1. babel-loader作用 babel-loader是用来处理ES6+并将其编译为ES5 安装1npm install babel-loader @babel/core @babel/preset-env 看这条安装指令，有几个参数，代表着什么呢？ babel-loader：它是使Babel与Webpack协同工作的模块 @babel/core：Babel编译器的核心模块 @babel/preset-env：Babel官方推荐的预置器，可根据用户设置的目标环境自动添加所需要的插件和补丁来编译ES6+代码 示例当然，知道了参数，也需要根据loader文档注意一些小细节，例如： 12345678910111213141516171819rules: [ &#123; test: /\.js$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; cacheDirectory: true, presets: [ [ 'env', &#123; modules: false &#125; ] ] &#125; &#125; &#125;] 说明 babel-loader一般对于js后缀文件生效， 而在node_modules中所有插件有大量的js后缀文件，因此需要使用exclude将其排除，避免打包时速度过慢； 可以看到上面配置中添加了cacheDirectory: true的配置，意味着会启用缓存机制，在多次打包时，如果没有做过改变的模块不会二次编译，打包时只重新编译更改的模块，以此来加快打包速度； 另外可以看到@babel/presets-env中配置为modules: false，原因是 @babel/presets-env会自动将ES6 Module转化为CommonJS形式，会导致Webpack中的tree-shaking特性失效，而将modules配置为false后悔禁用模块化语句的转化，将Module的语法交给Webpack本身去处理，来避免这一问题的发生。 babel-loader支持从.babelrc文件读取Babel配置，因此也可以将presets和plugins从Webpack配置文件中提取出来，也能达到相同效果。 2. ts-loader作用 用于连接Webpack与TypeScript的模块 安装1npm install ts-loader typescript 配置123456rules: [ &#123; test: /\.ts$/, use: 'ts-loader' &#125;] 说明学习或使用过typescript的开发者都知道，typescript的配置信息在工程目录下的tsconfig.jsson中，因此在ts-loader中不配置，直接对tsconfig.json进行配置即可。如： 123456&#123; "compilerOptions": &#123; "target": "es5", "sourceMap": true &#125;&#125; 3. html-loader作用 用于将HTML文件转化为字符串并进行格式化，这使得我们可以把一个HTML片段通过JS加载进来 安装1npm install html-loader 配置123456rules: [ &#123; test: /\.html$/, use: 'html-loader' &#125;] 使用示例1234&lt;!-- header.html --&gt;&lt;header&gt; &lt;h1&gt;This is a Header.&lt;/h1&gt;&lt;/header&gt; 123// index.jsimport Header from './header.html'document.write(Header) 4. vue-loader作用 vue-loader用于处理.vue组件，类似如下示例形式，常与vue-template-compiler、css-loader配合使用。 安装1npm install vue-loader vue vue-template-compiler css-loader 包含有： vue vue-loader vue-template-compiler css-loader vue组件示例123456789101112131415161718192021// App.vue&lt;template&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'vue-loader', data() &#123; return &#123; msg: 'vue-loader' &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="css"&gt;h1&#123; color: #f00;&#125;&lt;/style&gt; 配置123456rules: [ &#123; test: /\.vue$/, use: 'vue-loader' &#125;] 此处展示基础vue-loader示例，更多配置可以参考vue-loader官网文档 5. file-loader作用 用于打包文件类型的资源，并返回其PublicPath 安装1npm install file-loader 配置以对图片（png、jpg、jepg、gif）为例来配置file-loader： 123456789101112131415161718// webpack.config.jsconst path = require('path');module.exports = &#123; entry: './index.js', output" &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.(png|jpg|jepg|gif)$/, use: 'file-loader' &#125; ] &#125;&#125; 123// index.js 测试import testPng from './test.png'console.log(testPng); // caj15a1123d2asf132c123cx132.jpg 6. url-loader作用 与file-loader类似，不同之处在于用户可以设置一个文件大小的阈值，小于该阈值时，返回的文件以base64形式编码，大于该阈值时返回publicPath 安装1npm install url-loader 配置12345678910111213rules: [ &#123; test: /\.(png|jpg|jepg|gif)$/, use: &#123; loader: 'url-loader', options: &#123; limit: 10240, name: '[name].[ext]', publicPath: './assets-path/' &#125; &#125; &#125;] 如此，如果目标文件资源大小小于设置的阈值，那么目标资源将会转化为base64形式编码。 小结本篇着重接上一篇的loader配置，介绍了几种常用的loader及其作用和意义，如babel-loader、html-loader、vue-loader等，并配有简单地配置介绍，目的是对loader有基础的使用来促进更深的了解。回归本质，loader就是一个函数，能够处理相应功能的函数。第一个loader是源文件，之后所有loader是上一个loader的输出，最后一个loader则是输出给webpack。 除了JavaScript外，在打包方面另外一个重要工作就是样式处理。下一篇介绍webpack中对样式处理的模块。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>loader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——预处理器(loader)【上篇】]]></title>
    <url>%2F2020%2F07%2F23%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-loader%2F</url>
    <content type="text"><![CDATA[写在前面这是webpack实战系列笔记的第5篇记录，前几篇记录如下： 打包第一个应用 模块化与模块打包 资源输入与输出 一切皆模块 上一篇简单描述了一切皆模块的思想，学以致用，来实践下~ 1. 关于 loader每个loader本质上都是一个函数，可用公式表达其本质： output = loader(input) input可能是工程源文件的字符串，也可能是上一个loader转化后的结果，包含： 字符串（转化后的结果） source map AST对象（抽象语法树） output同样包含上述几种信息。如果是最后一个loader，其结果直接被送到webpack中做后续处理；否则作为下一个loader的input向后传递。 举个例子 当使用 babel-loader 将 ES6+ 代码转化为 ES5 时，带入公式： ES5 = babel-loader(ES6+) 上述描述说过，loader本身是一个函数那么loader是如何工作的呢？ 12345678910module.exports = function loader (content, map, meta) &#123; var callback = this.async(); var result = handler(content, map, meta); callback( null, // error result.content, // 转换后的内容 result.map, // 转换source-map result.meta // 转换后的AST )&#125; 可以看出，该函数对接受到的内容进行转换，然后返回转换后的结果。 2. loader配置那在应用层面应该如何实施呢？ 在一切皆模块中说过静态资源的类型是各式各样的，比如静态HTML/CSS/JS、图片字体音视频等，webpack如何处理这各类资源呢？ok，loader的应用场景来了。 loader，字面意思是装载器，但在webpack中实际用途则是预处理器：webpack本身只认识JavaScript，对于其他类型的资源必须先定义一个或多个loader对其进行转译，输出为webpack能够接收的形式再继续进行，因此loader做的实际上是一个预处理的工作。 2.1 引入那loader到底应该如何使用呢？举例要在js中引入css文件： 12// index.jsimport './assets/common/css' 12345678/* common.css */body&#123; width: 100vw; height: 100vh; text-align: center; background: gray;&#125; ok,现在我们执行打包操作，build一下，会发现在终端报错： 为解决报错，我们需要用到的就是loader了~ 可以在上图报错内容除看到，提示我们没找到合适的loader来处理，并且给出css-loader提示，我们按提示安装： 12345// npmnpm install css-loader// 或者 yarn 与npm二选一即可yarn add css-loader 安装完成后，仍需在webpack.config.js中进行loader配置： 1234567891011121314151617181920212223const path = require('path')module.exports = &#123; entry: &#123; index: './src/index.js', &#125;, output: &#123; filename: '[name].js' &#125;, mode: 'development', // loader配置 module: &#123; rules: [ // css &#123; test: /\.css$/, use: ['css-loader'] &#125; ] &#125;&#125; 可以看到，对loader进行配置，配置项都在module对象中的rules模块。rules模块是一个数组，代表了要对模块进行处理的规则。在此处，我们使用到的规则有test和use： test：接收一个正则表达式或者一个元素为正则表达式的数组，只有正则匹配上的模块才会使用本条规则； use：接收一个数组，代表该规则所使用的loader。 然后进行打包操作： 12345// npmnpm run build// 或者 yarn 与npm二选一即可yarn build 然后发现，打包错误解决。 但，新的问题出现了：此时我们在浏览器打开index.html，发现样式并没有生效。原因是css-loader 的作用是处理css的加载语法而不是做style的样式渲染，因此我们需要添加一个 style-loader 来进行样式渲染。 2.2 链式loader在上面我们说了需要在引入一个 style-loader 来进行样式渲染处理，先安装： 12345// npmnpm install style-loader// 或者 yarn 与npm二选一即可yarn add style-loader 接着搭配之前的webpack配置，做一些修改： 1234567891011121314module.exports = &#123; ... // loader配置 module: &#123; rules: [ // css style &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; ] &#125;&#125; 可以看到，我们将style-loader写在了use的数组中，并且细心的朋友可能发现写在了css-loader之前，这就是链式loader。 那么为什么要区分顺序呢？在前面描述关于loader的公式中我们介绍过: output = loader(input) ， 在链式webpack打包中，是按照数组从后往前的顺序将资源交给loader去处理，因此最后生效的应该放在前面。 此时，我们在执行打包操作，然后可以在浏览器中看到index.html页面加载了样式： 2.3 其他配置2.3.1 options配置有些loader会有专门的配置项，形式上可能会有一些不同，如： 1234567891011121314151617181920212223module.exports = &#123; ... // loader配置 module: &#123; rules: [ // css &#123; test: /\.css$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; // css-loader相关配置 ... &#125; &#125; ] &#125; ] &#125;&#125; 当然，具体配置项参数和值则需要参考相应loader的文档来进行配置，用时参阅该loader文档即可。 2.3.2 exclude 和 include从字面意思理解，这两个分别是用来排除或者包含指定目录下模块的。 如： 123456789101112131415module.exports = &#123; ... // loader配置 module: &#123; rules: [ // css &#123; test: /\.css$/, use: ['style-loader', 'css-loader'], exclude: /node_modules/ &#125; ] &#125;&#125; 上面配置了exclude: /node_modules/，则代表着该目录下的所有模块都不会被此条规则限制，也就是说node_modules中的模块不会执行该规则。 同样，include用途与此类似： 123456789101112131415module.exports = &#123; ... // loader配置 module: &#123; rules: [ // css &#123; test: /\.css$/, use: ['style-loader', 'css-loader'], include: /src/ &#125; ] &#125;&#125; 可以看到此处使用的是include，代表该规则只对正则匹配到的模块生效，也就是说只对src下的模块生效。 在exclude和include同时存在的情况下，exclude优先级更高！ 通常情况下，在使用loader时，需要配置它，以此来加速打包速度，不配置的话打包会将所有模块打包，可能拖慢整体的打包速度。 2.3.3 resource 与 issuer有时候，我们会在项目中看到关于resource和issuer的相关配置，那么这两个配置是做什么的呢？ 其实与exclude和include类似，都是用于规定模块作用范围的配置。但是区别是exclude和include对规则的作用范围更加的精确。如： 12// index.jsimport './src/common.css' 在webpack中，我们认为被加载模块是resource，加载者是issuer，在上述代码中，css作为被加载者，而index作为加载者。 那么具体如何使用呢？ 12345678910111213141516171819module.exports = &#123; ... // loader配置 module: &#123; rules: [ // css &#123; test: /\.css$/, use: ['style-loader', 'css-loader'], exclude: /node_modules/, issuer: &#123; test: /\.js$/, include: /src/pages/ &#125; &#125; ] &#125;&#125; 在上面我们看到配置了issuer对象，限制是让src/pages目录下js可以引用使用规则css-loader。 我们看完后会发现一个风格问题： 代码可读性较差。可以稍加改善： 123456789101112131415161718192021module.exports = &#123; ... // loader配置 module: &#123; rules: [ // css &#123; use: ['style-loader', 'css-loader'], resource: &#123; test: /\.css$/, exclude: /node_modules/ &#125;, issuer: &#123; test: /\.js$/, exclude: /node_modules/ &#125; &#125; ] &#125;&#125; 通过添加resource对象来讲外层配置包裹起来，区分resource和issuer的规则，看上去即可一目了然，但实际本质一样。可选择一种风格进行配置。 小结本篇介绍了loader的作用和意义，以及在项目中实际使用时的一些配置，如引入、使用过程、链式loader、loader的配置等，从各大小方面均能做到对项目有优化或效率提升。下一篇介绍几个项目常用loader以及如何自定义loader。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——一切皆模块]]></title>
    <url>%2F2020%2F07%2F20%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%80%E5%88%87%E7%9A%86%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[写在前面这是webpack实战系列笔记的第4篇记录，简单描述一个思想：模块化思想——一切皆模块。本系列前几篇： 打包第一个应用 模块化与模块打包 资源输入与输出 一切皆模块一个web工程通常会包含一系列的静态资源，并且这些资源一般会存在某种相互依赖的关系。一般静态资源包含： HTML/CSS/JS 图片/音视频x 字体 模板 。。。 而其中可能存在的联系也容易举例，比如JS之间相互导出引入、HTML中会引入CSS、JS，而CSS和JS中又可能会引入图片、音视频等媒体资源。 但是对于webpack来说，这些静态资源却都是模块，我们可以像加载一个JS模块一样去加载它们，如： 12// main.jsimport '@/reset.css' 如果经常使用vue\react等单页面框架去构建项目的一定会非常熟悉这种写法，但如果没接触过的也一定会感觉这种写法比较新奇，甚至迷惑不解：从JS中加载CSS的意义何在呢？ 其实从显示结果来看各种方法所呈现的页面都一样，但是实际上，上述语句却将reset.css打包生成在了输出资源目录下，并且描述了JS与CSS文件之间的依赖关系。 举例举个场景：某页面模块需要用到按钮，于是我们加载它： 12// src/page/index.js'imort Button from './ui/button/button.js' 但是加载了JS文件之后发现需要各类样式，因此仍需要引入按钮组件的样式文件： 12// src/page/style.scss 以SCSS为例@import './ui/button/style.scss' 当然，在webpack中实际构建时，可以采用更加简洁的写法来处理： 1234567// src/page/index.jsimport Button from './ui/button/index.js'import './style.scss' // 引用页面自身样式// ./ui/button/index.jsimport './style.scss' // 引用组件自身样式 从上例子可以看到，在button的JS中加载了组件自身的样式，但对于需要该组件的页面来说，只需要引入button的js模块即可，不需要再这里引入button的样式了。 可以画出依赖图便于理解： 先看一般情况下的流程： 接下来看使用webpack： 可以看到，在一般情况下，JS和Style样式是分开处理的，我们需要分别维护组件JS和SCSS，每当我们增删一个或多个组件的时候，都需要多次操作操作：引入 JS&amp;SCSS 或者删除 JS&amp;SCSS。但在使用 webpack 的情况下，可以看到，button 模块被作为一个整体被引入进来，这样不仅可以直观且请清晰的看到依赖关系（JS和SCSS被作为一个整体引入到page/index.js），而且在进行组件的引入与删除时，直接操作一次即可达成目的。 在项目具有一定规模的情况下，可以更加清晰明了的总结出webpack对我们项目工程优化之处： 工程结构更简洁 让依赖关系更直观 代码可维护性更强 小结在前面我们也说过模块化的一些特性：高内聚性和可复用性，而本篇旨在描述出一切皆模块的思想，在学习webpack过程中，可以将这一思想尽情发挥到每一种静态资源上，从而使得项目系统更加简洁且健壮！下一篇继续发挥一切皆模块思想——预处理器（loader）。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——资源输入与输出]]></title>
    <url>%2F2020%2F07%2F13%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E8%B5%84%E6%BA%90%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[写在前面这是webpack实战系列笔记的第三篇记录：资源输入与输出。前两篇： 打包第一个应用 模块化与模块打包 1. 资源处理流程前两篇的博客中提及，webpack主要作用是对 解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，那么我们就要对资源处理的流程有一个了解。各个流程如下： 处理流程 指定入口(entry)： 告诉webpack从哪儿入手开始打包。 打包封装(chunk)： 存在依赖关系的模块在打包时被封装为一个chunk，chunk就像文件袋，里面包裹着很多文件（模块）。根据配置，可能会产生一个或者多个chunk。 打包产物(bundle)： 由上述chunk得到的打包产物则为bundle。 三者关系 2. 资源入口webpack决定入口文件路径需要通过两个配置项：context和entry。配置时做了两件事： 确定入口模块位置告诉webpack从哪儿开始打包 定义chunk name分两种情况，如果是单入口，那么默认chunk name是“main”，如果是多个入口，则需要为每个入口定义不同的chunk name来作为chunk的唯一标识。 2.1 contextcontext可以理解为资源入口的路径前缀，要求使用绝对路径的形式。以下两个案例效果相同： 注：入口文件为: ./src/js/index.js 12345678910111213141516171819202122232425// 案例1const path = require('path')module.exports = &#123; // 入口 context: path.join(__dirname, './src'), entry: './js/index.js', // 出口 output: &#123; filename: 'bundle.js' &#125;, // 打包模式：develop-开发，production-生产 mode: 'development',&#125;// 案例2const path = require('path')module.exports = &#123; ... context: path.join(__dirname, './src/js'), entry: './index.js', ...&#125; 如果存在多入口情况，使用context则可以使得入口编写更加整洁。如果忽略不写，那么默认值为当前工程的根目录。 2.2 entry在上面可以看到，entry指定确定的入口文件。而entry的写法则有多种，如：字符串、数组、对象、函数，那么根据不同的场景来选择使用即可。 注：假设入口文件为: ./src/index.js 2.2.1 字符串类型12345678module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js' &#125;, mode: 'development',&#125; 2.2.2 数组类型123456789101112module.exports = &#123; entry: ['babel-polyfill', './src/index.js']&#125;// 上面配置等同于↓// webpack.config.jsmodule.exports = &#123; entry: './src/index.js'&#125;// src/index.jsimport 'babel-polyfill'... 2.2.3 对象类型123456module.exports = &#123; entry: &#123; index: './src/index.js', main: './src/main.js' &#125;&#125; 其实对象类型是为定义多入口而设计的。如果资源入口有多个则必须使用对象类型来配置，其中，配置的属性名是chunk name，其对应的value值则是入口路径。如上述例子，main这条配置：chunk name为main,入口路径是 ./src/main.js。 2.2.4 函数类型函数类型的话可以返回上述介绍的三种类型的任意类型。如： 12345678910111213// 返回字符串类型module.exports = &#123; entry: () =&gt; './src/index.js'&#125;// 返回对象类型module.exports = &#123; entry: () =&gt; (&#123; // 返回对象类型，其中value的路径地址可以是数组类型 index: ['babel-polyfill', './src/index.js'], main: './src/main.js' &#125;)&#125; 2.3 实例我们现在应用前端一些主流框架来构建项目时，可能会发现我们构造出来的页面属于单页面应用（SPA：single page APP）。那么对于单页面应用来说，一般只需要定义一个入口即可，如： 123module.exports = &#123; entry: './src/app.js'&#125; 然后所有的库、模块等，均由该入口文件进行引用。此法其实利弊分明： 一方面只会产生一个JS文件，依赖关系清晰 另一方面则是项目过大时会造成资源体积包过大，降低页面渲染速度，从而影响用户体验度 为解决该问题，我们使用提取vendor的方法。 vendorvendor，小贩; 摊贩; 供应商。 在webpack中，vendor则指的是工程中用到的库、框架等第三方模块打包而产生的bundle。如： 123456789const path = require('path');module.exports = &#123; context: path.join(__dirname, './src'), entry: &#123; app: './app.js', vendor: ['react', 'react-dom', 'react-router'] &#125;&#125; 可以看到，app和以往一样无需改动，但我们新增了一个chunk name为 vendor的入口，通过数组形式放入了一些第三方模块。 但我们并没有设置vendor的入口路径，webpack如何去打包呢？此时我们可以采用optimization.splitChunks来将app和rendor这两个chunk中的公共模块给提取出来，然后app.js中只包含业务模块，第三方模块依赖都被抽取出来作为新的bundle。由于被抽取的模块不常变动，也可以利用这个特性来做客户端缓存，从而加快整体的渲染速度。 多入口刚才说了单页面应用，那么多页应用一般有多个入口，在此场景中，为了尽可能减小资源的体积，我们则是希望每个页面加载自身必要的逻辑，而不是都打包到一个bundle中。此时，就需要多入口配置来实现： 12345678910const path = require('path')module.exports = &#123; context: path.join(__dirname, './src'), entry: &#123; page1: './page1.js', page2: './page2.js', page3: './page3.js' &#125;&#125; 在上面配置中，入口与页面一一对应，如此的话每个html则只需要引入各自的js就可以加载其所需的模块。 另外，对于多页应用的场景，我们同样使用 vendor，将各个页面间的公共模块进行打包。如下： 1234567891011const path = require('path')module.exports = &#123; context: path.join(__dirname, './src'), entry: &#123; page1: './page1.js', page2: './page2.js', page3: './page3.js', vendor: ['react', 'react-dom'] &#125;&#125; 这样配置后，加上配置optimization.splitChunks将react和react-dom从各个页面中提取出来，生成单独的bundle即可。 3. 资源出口资源出口配置都集中在output对象中，包含了几十个配置项，但是大多数无需刻意配置，我们常用的一般有filename、path和publicPath。 3.1 filenamefilename，控制输出资源的文件名，值为字符串形式。如： 12345678module.exports = &#123; // 入口在 ./src/js/index.js entry: './src/js/index.js', output: &#123; filename: 'bundle.js' // 字符串形式，控制输出资源的名字 &#125;&#125; 虽说值为字符串形式，但是字符串中可以不仅仅是文件名，还可以加上路径，如： 12345678module.exports = &#123; // 入口在： ./src/js/index.js entry: './src/js/index.js', output: &#123; filename: './js/bundle.js' // 则会自动在dist下创建js目录，bundle会打包在js目录下 &#125;&#125; 执行打包操作后，可以看到在dist目录下生成了一个js目录，将bundle资源放在了js下： 那么如果是多入口场景，我们则需要为每个bundle指定不同的名字避免命名冲突。这时我们可以试用webpack提供的一种类似模板语言的形式动态生成，如： 12345678910module.exports = &#123; entry: &#123; index: './src/index.js', app: './src/app.js' &#125;, output: &#123; filename: [name].js' // [name]类似模板语言 &#125;&#125; 执行打包命令后生成的资源： 从上图打包结果可以看出，我们配置的[name]在资源输出时，会被替换为 chunk name，最后打包输出的资源分别是app.js和index.js。除了[name]之外，还有几个常用的配置： 名称 描述 [hash] webpack此次打包所有资源生成的hash值 [chunkhash] 当前chunk的hash [id] 当前chunk的id [query] filename配置项中的query 在这几个变量中，[name]、[id]和[chunkhash]在有多个chunk时可以使用，用来对chunk进行区分。另外一个比较好的效果控制缓存：[hash]和[chunkhash]都与chunk内容直接相关，当chunk内容改变时，可以同时引起资源文件名的改变，从而导致用户在下一次请求资源文件时会下载新版本的内容而不是用本地缓存。如果要控制客户端缓存，一般加上[chunkhash]，因为每个chunk所产生的chunkhash只与自身内容相关，不会影响到其他资源，可以精准的让客户端缓存得到更新。 在生产环境中，我们可以如下配置filename： 12345678910module.exports = &#123; entry: &#123; index: './src/index.js', app: './src/app.js', &#125;, output: &#123; filename: '[name]@[chunkhash].js' &#125;&#125; 3.2 pathpath指定输出资源的位置，值必须是绝对路径，如： 123456789const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.join(__dirname, 'dist') &#125;&#125; 注：在webpack4版本及之后版本，output.path的默认路径就是dist，如果我们需要更改则如上配置可修改，如无需修改则不需单独配置。 3.3 publicPathpublicPath相对于path还是比较容易混淆的。 path： 指定输出资源的输出位置 publicPath： 指定资源的请求位置 那么怎么理解输出位置和请求位置呢？ 输出位置： 打包后资源产生的目录，不自定义配置的话默认是dist目录 请求位置： JS或者CSS所请求的间接资源路径。页面中的资源分两种：一种是由HTML页面直接请求的，比如通过script标签加载的JS；另一种是由JS或者CSS请求的，比如异步JS、CSS请求的图片字体等。publicPath就是用来指定这部分间接资源请求位置的。 webpack-dev-server 第一篇得时候介绍过关于webpack-dev-server。在webpack-dev-server中，也配置了一个publicPath，作用是指定webpack-dev-server的静态资源服务路径。如： 12345678module.exports = &#123; ... devServer: &#123; publicPath: '/assets/', // 指定webpack-dev-server的静态资源服务路径 port: 8088 &#125;&#125; 4. 实例4.1 单入口单入口场景，通常不必设置动态的filename，直接输出文件名即可： 1234567891011121314const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundie.js' &#125;, // 如果需要使用webpack-dev-server，那么则配置devServer的publicPath即可 devServer: &#123; publicPath: '/dist/' &#125;&#125; 4.2 多入口多入口场景，则需要使用模板来配置filaneme，如： 1234567891011121314151617const path = require('path');module.exports = &#123; entry: &#123; index: './src/index.js', app: './src/app.js', &#125;, output: &#123; filename: '[name]@[chunkhash].js' &#125;, // 需要devServer的话添加即可 devServer: &#123; publicPath: '/dist/' &#125;&#125; 5. 小结本篇主要记录的是webpack打包控制资源的输入和输出流程，以及各自的一些常用配置，如entry、context、filename、path等。除此之外，还介绍了例如vendor方法来提取公共资源，更有效的利用缓存来提升页面渲染速度。下一篇简述“一切皆模块”的思想。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——模块打包]]></title>
    <url>%2F2020%2F07%2F06%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[写在前面这是webpack实战系列的第二篇：模块和模块打包。上一篇：webpack实战——打包第一个应用 记录了webpack的一些基础内容与一个简单地小例子，开启了webpack的实战之路，这一篇记录一下关于模块和模块打包。 模块先看一下模块的定义： 模块,是能够单独命名并独立地完成一定功能的程序语句的集合（即程序代码和数据结构的集合体）。它具有两个基本的特征：外部特征和内部特征。外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能；内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）。 可以从定义中看出，每个独立的模块负责不同工作，彼此之间又可以联系在一起共同保证整体系统运行。那么在webpack中，如何将其打包成一个（或多个）文件呢？ 想了解这些，我们还是先要熟悉在 Javascript 中的模块。在 Javascript 模块化中比较常见的有： CommonJS ES6 module AMD CMD UMD(AMD和CommonJS) … 但由于在目前的使用场景中 CommonJS 和 ES6 module 居多，因此暂时就这两者进行讨论。 1. CommonJS1.1 模块在 CommonJS 中规定每个文件都是一个模块。 在 CommonJS 中，变量及函数的声明不会造成全局污染。如： 1234567// add.jsvar name = 'name: add.js';// index.jsvar name = 'name: index.js';reuqire('./add.js');console.log(name); // name: index.js 在上面 index.js 中通过 require 函数来加载 add.js ，输出的结果是 name: index.js ，说明在 add 中定义的变量并不会影响 index ，可以得出使用 CommonJs 模块，作用域只针对于该模块，而不会造成全局污染，对外不可见。 1.2 导出前面说过模块拥有自己的作用域，那么模块是需要向外传递的，怎么办呢？导出是一个模块向外暴露自身的唯一方式。在 CommonJS 中，我们通过 module.exports 来导出模块中的内容。如： 1234567// add.jsmodule.exports = &#123; name: 'add', add: function(a, b) &#123; return a + b; &#125;&#125; 在 CommonJS 内部会有一个 module 对象用于存放当前模块的信息。而 module.exports 则指定向外暴露的内容。 1.3 导入导出自然是为了另外一个模块来使用，这时便使用到了导入功能。在 CommonJS 中，使用 require 来进行模块导入： 123456789101112// add.jsmodule.exports = &#123; name: 'add', add: function(a, b) &#123; return a + b; &#125;&#125;// index.jsconst add = require('./add.js');const sum = add.add(1, 2);console.log(sum); // 3 上面这个例子，便是在 index.js 中通过 require 导入了 add.js ，并且调用了其中的 add() 方法。 而我们在 reuqire 一个模块的时候，会分两种情况： 如果 require 的模块第一次被加载，那么会执行该模块然后导出内容； 如果非首次加载，那么该模块代码不会再次执行，而是直接导出上次代码执行后所得到的结果。 有时候我们只想通过加载执行某个模块让它产生某种作用而不需要获取它所导出的内容，则可以直接通过 require 来导入而不需要定义： 12require('./task.js');... 而通过这个特性，加上 require 函数可以接收表达式，那么我们则可以动态指定模块加载路径： 1234const moduleList = ['add.js', 'subtract.js'];moduleList.forEach(item =&gt; &#123; require(`./$&#123;item&#125;`);&#125;); 2. ES6 Module熟悉 JavaScript 语言的小伙伴知道，其实在 JavaScript 设计之初，并没有模块化这个概念。而伴随 JavaScript 不断的壮大发展，社区中也涌现出了不少模块化概念。一直到 ES6 ， JavaScript 终于正式的有了模块化这一特性。 2.1 模块在前面我们使用 CommonJS 实现了一个例子来展示 CommonJS 的模块、导出与导入，同样在此处也先来一个例子，只需将上面例子稍微改写即可： 123456789101112// add.jsexport default &#123; name: 'add', add: function(a, b) &#123; return a + b; &#125;&#125;// index.jsimport add from './add.js';const sum = add.add(-1, 1);console.log(sum); // 0 ES6 Module 也是将每一个文件都作为一个模块，并且每个模块拥有自身的作用域，但是与 CommonJS 相比， 不同的是导入、导出语句。在 ES6 Module 中，import 和 export 也作为关键字被保留。 2.2 导出在 ES6 Module 中，使用 export 来对模块进行导出。 export 导出的两种方式： 命名导出 默认导出 2.2.1 命名导出以下有两种写法，但其效果并无区别： 12345678910111213141516/*** 命名导出： 两种写法**/// 1. 声明和导出写在一起export const name = 'add';export const add = function(a, b) &#123; return a + b;&#125;// 2. 先声明，再统一导出const name = 'add';const add = function(a, b) &#123; return a + b;&#125;export &#123; name, add &#125; as关键字 在使用命名导出时，如果用写法2（先声明再统一导出），可以使用 as 关键字 来对导出的变量进行重命名。如： 123456const name = 'add';const add = function(a, b) &#123; return a + b;&#125;// add as sum ： 在导入时，使用 name 和 sum 即可export &#123; name, add as sum &#125; 2.2.2 默认导出说完了命名导出，来到默认导出：模块的默认导出只能导出一个。举例： 1234567// 默认导出export defailt &#123; name: 'add', add: function(a, b) &#123; return a + b; &#125;&#125; 由上可见，我们可以将默认导出理解为向外输出了一个命名为 default 的变量。 2.3 导入ES6 Module 中使用 import 进行模块导入。由于在 ES6 Module 的导出中，分为 命名导出 和 默认导出 ，因此在导入的时候也有对应的两种方式进行导入。 2.3.1 命名12345678910// add.jsconst name = 'add';const add = function(a, b) &#123; return a + b;&#125;export &#123; name, add &#125;// index.jsimport &#123; name, add &#125; from './add.js';console.log(name, add(1, 2)); // add 3 可以看到，在使用 import 对命名导出模块进行引入的时候， import 后面跟了一对花括号 { } 将导入的变量名包裹起来，并且变量名需要与导出时的变量命名一样。同样，我们还是可以使用 as 关键字 来对变量进行重命名： 123// index.jsimport &#123; name, add as sum &#125; from './add.js'sum(2, 2); // 4 值得注意的是，导入变量的效果相当于在当前作用域下声明了变量（如 name 和 add），但不可对这些变量不能修改，只可当成只读的来使用。 当然，我们还可以使用 * 来进行整体导入： 1234// index.jsimport * as add from './add.js';console.log(add.name); // addconsole.log(add.add(1, 1)); // 2 2.3.2 默认对于默认导出的导入处理如下： 1234567891011// add.jsexport default &#123; name: 'add', add: function(a, b) &#123; return a + b; &#125;&#125;// index.jsimport addMe from './add.js';console.log(addMe.name, addMe.add(2, 5)); // add 7 可以看到，如果是导入默认导出的模块，那么在 import 后面直接跟变量名即可，并且这个变量名无需与导出模块的变量名重复，可以自己指定新的变量名。 3. CommonJS 与 ES6 Module 的区别介绍了 CommonJS 与 ES6 Module 的基础应用之后，我们也要了解到在实际的开发过程中我们经常将这两者在同一个项目中混用。为了避免不必要的麻烦，还是要说一下两者的异同。 3.1 动态与静态CommonJS 对模块依赖的解决是动态的，而 ES6 Module 对模块依赖的解决是静态的。 首先要了解这里说的动态与静态是什么： 动态： 模块依赖关系的建立发生在代码运行阶段； 静态： 模块依赖关系的建立发生在代码编译阶段； 由于 ES6 Module 中导入导出语句都是声明式的，不支持导入表达式类路径，并且导入导出语句必须位于模块的顶层作用域。相比 CommonJS ，具备优势如下： 死代码检测和排除： 可以使用静态分析工具检测出没有被调用的模块，减小打包资源体积； 模块变量类型检查： 有助于确保模块之间传递的值或者接口类型的正确性； 编译器优化： ES6 Module 直接导入变量，减少层级引用，程序效率更高。 3.2 值拷贝和动态映射在导入一个模块时，对于 CommonJS 来说获取的是一份导出值的拷贝，而在 ES6 Module 中则是值的动态映射，这个映射是只读的。例如： 1234567891011121314151617181920// add.jsvar count = 0;module.exports = &#123; count: count, add: function(a, b) &#123; count += 1; return a + b; &#125;&#125;// index.jsvar count = require('./add.js').count;var add = require('./add/js').add;console.log(count); // 0 (这里的count是对add.js中couunt的拷贝)add(2, 3);console.log(count); // 0 (add.js中变量值的改变不会对这里的拷贝值造成影响)count += 1;console.log(count); // 1 (拷贝的值 0 + 1 = 1，表示拷贝的值可以更改) 可以看出，index.js 中的 count 是 add.js 中 count 的一份值拷贝，因此在调用 add 函数时，即便更改了 add 中的 count，但不会对 index.js 中的值拷贝造成影响。 但在 ES6 Module 中，却不一样： 123456789101112131415// add.jslet count = 0;const add = function(a, b) &#123; count += 1; return a + b;&#125;;export &#123; count, add &#125;;// index.jsimport &#123; count, add &#125; from './add.js';console.log(count); // 0 (对add.js中count值的映射)add(1, 1);console.log(count); // 1 (对add.js中count值的映射，会映射值的变化)count += 1; // 报错，该count值不可更改 4. 模块打包原理前面描述了一些基础的 CommonJS 与 ES6 Module 模块化的一些知识，那么回到 webpack 中来：webpack是如何将各种模块有序的组织在一起的呢？ 1234567891011// add.jsmodule.exports = &#123; add: function(a, b) &#123; return a + b; &#125;&#125;// index.jsconst add = require('./add.js');const sum = add(1, 2);console.log(`sum: $&#123;sum&#125;`); 还是之前的例子，但现在经过 webpack 打包之后，它会变成什么样子呢？ 如图所示，这便是一个简单地打包结果。我们可以观察自己的 bundle.js 文件，从中看打包逻辑关系： 首先一个立即执行匿名函数，包裹所有内容，构成资深作用域； installedModule对象（模块缓存），每个模块在第一次被加载的时候执行，到处结果存储到其中，以后再次调用模块直接取值即可，不会再次执行模块； webpack_require函数： 对模块加载的实现，在浏览器中可以通过调用此函数加模块id来进行模块导入； modules对象：工程中所有产生依赖关系的模块都会以 key-value 形式放在此对象中， key 作为模块 id，由数字或者 hash 字符串构成，value 则由一个匿名函数包裹的模块构成，匿名函数的参数则赋予了每个模块导出和导入能力。 小结本篇记录了关于 JavaScript 的模块化与 webpack 的模块打包原理简介。 首先，介绍了关于模块的概念，然后依次介绍了两种模块化：CommonJS 和 ES6 Module ，以及他们分别的模块概念、导出和导入，接着介绍了他们之间的两个差异：动态与静态、值拷贝和映射。最后，提及了一下模块化打包的简单原理，对webpack打包工作有一个大概认知。 下一篇将会介绍在webpack中资源的输入与输出。敬请期待。 学习推荐： 本系列学习资源多来自于 《webpack实战 入门、进阶与调优》 ，作者 居玉皓 ， 感兴趣的朋友可以购买实体书支持学习~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack实战——打包第一个应用]]></title>
    <url>%2F2020%2F07%2F03%2Fwebpack%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%89%93%E5%8C%85%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[写在前面最近学习了一些关于webpack的知识，在此做一些纪录。作为前端开发者，我们以前在浏览器中运行 JavaScript ，会引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈；亦或使用一个包含所有项目代码的大型 .js 文件，但是这会导致作用域、文件大小、可读性和可维护性方面的问题。 后来，模块化诞生……随之而来的是一个新的时代，基于 node.js 的一系列解决方案也是孕育而生，各种功能、方法都是用模块，对于开发、维护也是极大的瓶颈突破和效率提升，但是新的问题随之而来，各种模块不是浏览器支持不够友好，就是各依赖问题难以手动解决或者构建……而 webpack 此时也是破空而出，是用于现代 JavaScript 应用程序的静态模块打包工具。最核心的功能则是解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，最终合并为一个或多个 .js 文件。这个过程也被称为 模块打包 。那么webpack到底神秘在何处？为何前端大框架都用它来配置？为何近年面试频频被问？上手难度几何？实际效果又如何？本专题文章着手纪录webpack实战过程，从零开始着手webpack的配置过程及优化方案，例如模块打包、资源输入输出、预处理器、样式处理、代码切割、打包优化、开发环境调优 等等篇章。本篇纪录关于webpack的简介以及环境配置、打包第一个应用~ webpack简介 1. 什么是webpack webpack是一个开源的Javascript模块打包工具，最核心的功能是解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，最终合并为一个JS文件。 2. 为什么选择webpack对比同类模块打包工具，具备以下优势： 支持多种模块标准，如AMD，CommonJS及ES6模块等 具有完备的代码分割功能，可以有效减小资源体积，提升首页渲染速度 可以处理各类型资源，如css、png等 拥有庞大的社区支持 安装1. 环境 操作系统： 无要求 环境： Node.js 此处使用macOS或者windows为例。 2. Node.js安装打开node.js中文网（http://nodejs.cn/），点击下载项安装对应系统的安装包即可。 3. webpack安装 新建一个目录作为工程目录 然后终端进入或者通过命令行工具执行npm初始化：npm init 依次输入所提示的的基本信息，完成后得到一个package.json文件 执行安装webpack和webpack-clinpm i webpack webpack-cli --save-dev 执行完成好就完成了安装过程 打包第一个应用hello world接着刚才的步骤继续： 项目根目录建入口文件： index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;my first webpack app&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="./dist/bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 项目根目录新建文件夹src，存放两个js文件：index.js和hello.js index.js 12345// index.jsimport hello from './hello.js';document.write('my first webpack app &lt;br/&gt;');hello(); hello.js 1234// hello.jsexport default function() &#123; document.write('hello world!');&#125; 命令行工具执行打包命令： 1npx webpack --entry=./src/index.js --output-filename=bundle.js --mode=development 执行结果（和工程目录）如下： 验证结果：浏览器打开index.html，查看页面结果： 命令优化在上述打包命令中，我们使用npx webpack --entry=./src/index.js --output-filename=bundle.js --mode=development来执行打包，但这一段命令冗长而又耗时，搞不好还容易出错。那么有没有简洁一些的方法呢？当然有！ 1. 使用 npm scripts 配置配置打开根目录的配置文件，编辑一条 scripts 命令： 12345678910111213&#123; "name": "w1", "version": "1.0.0", "description": "打包第一个应用", "main": "index.js", "author": "zxm", "license": "ISC", // 添加命令 "scripts": &#123; "build": "webpack --entry=./src/index.js --output-filename=bundle.js --mode=development" &#125;&#125; scripts 是 npm 提供的脚本命令功能，在这里可以直接使用模块所添加的指令。 验证我们修改hello.js中的输出： 1234// hello.jsexport default function() &#123; document.write('hello scripts');&#125; 然后执行打包命令：npm run build，观察结果： 2. 使用配置文件配置从上面命令可以看出，我们使用 scripts 命令一样可以代替执行 webpack 的打包命令，并且在命令行工具中使用则会更加简洁。但是存在一个问题，如果项目需要越来越多的配置，那么就需要往命令中塞入更多的参数，越来越多，到后期，项目的维护成本则正比的增加许多。为了解决此问题，可以将这些参数用对象的配置形式来统一存放到一个配置文件中，然后webpack每次打包都读取该配置文件即可。 根目录新建文件：webpack.config.js，并配置如下代码： 1234567891011// webpack.config.jsmodule.exports = &#123; // 入口文件指定 entry: './src/index.js', // 输出资源配置 output: &#123; filename: 'bundle.js' &#125;, // 打包模式：develop-开发，production-生产 mode: 'development'&#125; 修改package.json文件的scripts &gt; build配置： 12345678&#123; ...... // 修改后如下： "scripts": &#123; "build": "webpack" &#125;&#125; 校验：修改hello.js的输出： 1234// hello.jsexport default function() &#123; document.write(`this is webpack.config\'s result`);&#125; 执行npm run build，刷新浏览器，看结果： 至此，webpack的初始化环境配置及基础配置已经完毕。但是我们现在遇到一个麻烦事：我们没更改一些代码，则需要重新打包才能去测试，才能看到结果，那么有没有什么简洁的方案处理呢？有！继续操作~ 3. 开发优化——热更新webpack社区为我们提供了一个便捷的本地开发工具：webpack-dev-server， 安装执行安装命令：npm i webpack-dev-server --save-dev 新增 npm scripts 命令前面刚写了一个scripts命令，那么此时再添加一个dev来配置。编辑根目录的package.json文件： 12345678&#123; ...... "scripts": &#123; "build": "webpack --entry=./src/index.js --output-filename=bundle.js --mode=development", "dev": "webpack-dev-server" &#125;&#125; 还没结束，仍需在webpack中配置一下： webpack.config.js添加dev-server配置12345678module.exports = &#123; ...... // 新增： dev-server配置 devServer: &#123; publicPath: '/dist' &#125;&#125; 启动本地服务执行命令npm run dev 可以看到，在左侧代码块中修改内容后，只需要保存即可，右边浏览器则自动刷新了~~ 这个功能可以脱离dist文件，也就是没有通过实际的打包，为什么会这样呢？因为webpack-dev-serve其实不会写入实际的bundle.js文件，而是将打包结果运行于内存之中，然后每次webpack-dev-serve接收到请求的时候都将此时内存中的打包结果返回给浏览器端即可。 备注：如果npm run dev启动失败，有可能是webpack webpack-cli webpack-dev-server 的班班之间存在不兼容现象，将这三个卸载后(用 npm uninstall 卸载)，同时将这三个安装一下即可：npm install webpack webpack-cli webpack-dev-serve 小结本篇文章中，对webpack有了一个基本的介绍： 处理模块之间的依赖并将其打包然后进行了webpack环境的安装和配置：环境、nodeJs、webpack及webpack-cli等。之后，开始了第一个案例： hello world，然后通过webpack命令进行打包，打包到./dist/bundle.js。最后进行了一波优化，由于直接输入命令过于繁琐，因此借助 npm 脚本或者 webpack.config 来维护 webpack 命令。此时由于频繁的打包也不符合开发条件，因此使用本地服务 webpack-dev-server 来启用一个可热加载的本地服务来处理打包资源和静态文件的请求。 下一篇将会纪录如何编写和使用模块，以及模块打包。敬请期待~ 本篇代码demo存于公众号【流眸】，欢迎扫码关注公众号，可在公众号下回复【2073】获取]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用验证码之滑动验证码|图形验证码]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%B8%B8%E7%94%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B9%8B%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81-%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[写在前面这里是常用验证码的第三篇——滑动/图形验证码。在前两篇已经实现了随机验证码和算术验证码，感兴趣的可以去看一下~ 常用验证码之字符串验证码 常用验证码之算数验证码 除了这两种常用的验证码之外，现在最经常用到的还有几种，比如滑动验证，图片验证等，这一类的验证码一般借助于第三方来处理即可。比如图形验证码： 本篇纪录两种常用验证码的第三方调用方式： 滑动验证码 图形验证码 滑动验证码1. 示例 2. 应用场景人机验证服务适用于登录、注册、活动、论坛、短信等高风险业务场景。 3. 实际意义通过对用户的行为数据、设备特征与网络数据构建多维度数据分析，使用业界先进的风控引擎结合“规则+AI”模型，对风险设备使用、模拟行为、暴力重放等攻击进行综合实时风控判决。 4. 使用流程 接入平台： 阿里云搜索引擎搜索打开阿里云官网，注册并登录。 搜索栏搜索关键词：验证码然后在结果中点击进入【人机验证(验证码)】 点立即开通，即可获取自己的专属token,记录下即可~在代码配置中会用得到~ 点击产品文档，各种配置在里面查看配置即可； 示例 1&lt;div id="checkId" class="nc-container"&gt;&lt;/div&gt; &lt;!--No-Captcha渲染的位置，其中 class 中必须包含 nc-container--&gt; 12345678910111213141516171819202122232425262728293031323334// 首先得先引入资源如下&lt;script type="text/javascript" charset="utf-8" src="https://g.alicdn.com/sd/ncpc/nc.js?t=2015052012"&gt;&lt;/script&gt;// 配置即可var nc_token = ["[自己的key值]", (new Date()).getTime(), Math.random()].join(':');var NC_Opt = &#123; renderTo: "#checkId", appkey: "[自己的key值]", scene: "nc_login", token: nc_token, customWidth: 300, trans:&#123;"key1":"code0"&#125;, elementID: ["usernameID"], is_Opt: 0, language: "cn", isEnabled: true, timeout: 3000, times:5, callback: function (data) &#123; // 验证后续操作 window.console &amp;&amp; console.log(nc_token) window.console &amp;&amp; console.log(data.csessionid) window.console &amp;&amp; console.log(data.sig) &#125;&#125;var nc = new noCaptcha(NC_Opt)// 在此处配置相关文案信息nc.upLang('cn', &#123; _startTEXT: "请按住滑块，拖动到最右边", _yesTEXT: "验证通过", _error300: "哎呀，出错了，点击&lt;a href=\"javascript:__nc.reset()\"&gt;刷新&lt;/a&gt;再来一次", _errorNetwork: "网络不给力，请&lt;a href=\"javascript:__nc.reset()\"&gt;点击刷新&lt;/a&gt;",&#125;) 打开后如案例所示，完成~ 图形验证码1. 示例 2. 应用场景 注册登录 活动秒杀 点赞发帖 数据保护 3. 实际意义为网页、App、小程序开发者打造立体、全面的人机验证，最大程度地保护注册登录、活动秒杀、点赞发帖、数据保护等各大场景下的业务安全。 4. 使用流程 接入平台： 腾讯云搜索引擎搜索打开腾讯云官网，注册并登录。 搜索栏搜索关键词：验证码然后在结果中点击进入【验证码】 点立即选购（体验即可，无需付费）或者在线体验 点击产品文档，各种配置在里面查看配置即可；相比之下，腾讯云的基本使用方法则比阿里云简单的多，示例如下： 示例 1&lt;button id="TencentCaptcha" data-appid="2041127177" data-cbfn="callback" type="button"&gt;验证&lt;/button&gt; 1234567891011// 首先得先引入资源如下&lt;script src="https://ssl.captcha.qq.com/TCaptcha.js"&gt;&lt;/script&gt;// 基础使用window.callback = function (res) &#123; // 添加自己相应配置即可 console.log(res) if (res.ret === 0) &#123; alert(res.ticket) // 票据 &#125;&#125; 完成~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用验证码之算数验证码]]></title>
    <url>%2F2020%2F06%2F25%2F%E5%B8%B8%E7%94%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B9%8B%E7%AE%97%E6%9C%AF%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[写在前面这里是常用验证码的第二篇——算术验证码。在上一篇已经实现了常用验证码之字符串验证码，感兴趣的可以去看一下~接下来要实现的就是字符串验证码了，先看下效果： 本篇记录纯前端写算术验证码。 实现：算术验证码一般来讲，字符串、算数、gif、短信语音等验证码放在后端实现，但本着技术无界限的原则，前端依然是能照葫芦画瓢给实现出来的。本次要实现的效果如下： 效果 分析验证码实现步骤： canvas画布 生成随机100以内的简单整数四则运算 随机颜色 背景色（可固定色） 噪音线设置 绘制验证码 其他一些基础内容也包含其中，如点击验证码刷新、点击下一步验证等操作。 步骤实现：注：本案例基于vue操作，UI使用element完成，原生js同样道理 1. canvas画布html123456&lt;!-- 输入框 --&gt;&lt;input v-model="inputCode" placeholder="请输入右侧图案的值" /&gt;&lt;!-- canvas画布：验证码 --&gt;&lt;canvas ref="checkCode" @click="getCode"&gt;&lt;/canvas&gt;&lt;!-- 按钮 --&gt;&lt;button @click="checkMe"&gt;下一步&lt;/button&gt; js12345678910111213141516// 需要的数据data() &#123; return &#123; inputCode: '', // 输入的值 checkCode: '', // 图片验证码的值 expressValue: '', // 表达式的值 // canvas各种设置 cvs: &#123; w: 100, // 给出默认宽度 宽度会在图片绘制时根据长度更改 h: 40, // 高 与input保持一致 fontSize: 24, // 字体大小 str: '+-*', // 符号生成范围 line: 3 // 噪音线个数 &#125; &#125;&#125; 2. 生成随机表达式 写一个随机整数生成器，在各个环节都会用到 生成随机字符串，长度是在data里面cvs中对应长度1234567891011121314151617// 随机整数生成器，范围[0, max)rInt(max) &#123; return Math.floor(Math.random() * 100000 % max);&#125;,// 生成随机表达式rCode() &#123; let a = this.rInt(100); let b = this.rInt(10); let op = this.cvs.str.charAt(this.rInt(this.cvs.str.length)); // 表达式 let code = `$&#123;a&#125;$&#123;op&#125;$&#123;b&#125;=`; this.checkCode = code; // 表达式的值 this.expressValue = eval(code.substr(0, code.length - 1)); return code;&#125;, 3. 生成随机颜色 rgba格式 a：透明度，取值为0.5-112345 // 生成随机颜色 rgba格式rColor() &#123; let a = ((Math.random()*5 + 5) / 10).toFixed(2); return `rgba($&#123;this.rInt(256)&#125;, $&#123;this.rInt(256)&#125;, $&#123;this.rInt(256)&#125;, $&#123;a&#125;)`&#125;, 4. 开始绘制 方法接收一个dom对象 判断浏览器对canvas支持程度 取随机字表达式 设置canvas宽高大小 绘制 具体过程如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 验证码图片绘制drawCode(domCvs) &#123; let _this = this; // 随机表达式 let checkCode = this.rCode(); // 宽设置 this.cvs.w = 10 + this.cvs.fontSize * this.checkCode.length; // 判断是否支持canvas if (domCvs !== null &amp;&amp; domCvs.getContext &amp;&amp; domCvs.getContext('2d')) &#123; // 设置显示区域大小 domCvs.style.width = _this.cvs.w; // 设置画板宽高 domCvs.setAttribute('width', _this.cvs.w); domCvs.setAttribute('height', _this.cvs.h); // 画笔 let pen = domCvs.getContext('2d'); // 背景: 颜色 区域 pen.fillStyle = '#eee'; pen.fillRect(0, 0, _this.cvs.w, _this.cvs.h); // 水平线位置 pen.textBaseline = 'middle'; // top middle bottom // 内容 for (let i = 0; i &lt; _this.checkCode.length; i++) &#123; pen.fillStyle = _this.rColor(); // 随机颜色 pen.font = `bold $&#123;_this.cvs.fontSize&#125;px 微软雅黑`; // 字体设置 // 字符绘制: (字符, X坐标, Y坐标) pen.fillText(checkCode.charAt(i), 10 + _this.cvs.fontSize * i, 17 + _this.rInt(10)); &#125; // 噪音线 for (let i = 0; i &lt; _this.cvs.line; i++) &#123; // 起点 pen.moveTo(_this.rInt(_this.cvs.w) / 2, _this.rInt(_this.cvs.h)); // 终点 pen.lineTo(_this.rInt(_this.cvs.w), _this.rInt(_this.cvs.h)); // 颜色 pen.strokeStyle = _this.rColor(); // 粗细 pen.lineWidth = '2'; // 绘制 pen.stroke(); &#125; &#125; else &#123; this.$message.error('不支持验证码格式，请升级或更换浏览器重试'); &#125;&#125;, 5. 绑定canvas的dom元素html1&lt;canvas class="codeCanvas" ref="checkCode" @click="getCode"&gt;&lt;/canvas&gt; js：getCode方法123// vue的话可直接用$refs取值，不用vue的话可绑定id然后通过document处理let domCvs = this.$refs.checkCode;this.drawCode(domCvs); 6. 完成~ 在页面初始化的时候，也来一个验证码 点击下一步， 验证data中inputCode和expressValue的值是否一样即可。注意，直接使用eval验证即可 页面初始化 12345// 初始化先搞一个验证码~点击canvas的时候重新执行getCode()mounted() &#123; // 获取验证码图 this.getCode();&#125; 验证 123456789101112131415checkMe() &#123; // 空、 错误、 正确 三个判断 if (this.inputCode) &#123; if (eval(this.inputCode) === eval(this.expressValue)) &#123; // 验证成功要做的事 this.$message.success('验证成功'); &#125; else &#123; // 验证码有误 this.$message.warning('错误，请重新输入'); &#125; &#125; else &#123; // 输入为空 this.$message.warning('请输入右侧结果'); &#125;&#125; 结语ok，常用的简单算术验证码大致就是这样子了~ 本篇案例源码可关注公众号【流眸】回复【20630】获取哟~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>canvas</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用验证码之字符串验证码]]></title>
    <url>%2F2020%2F06%2F19%2F%E5%B8%B8%E7%94%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[写在前面验证码 这个玩意，无论是开发者还是用户都十分熟悉： 注册？ 请输入验证码… 登录？ 请输入验证码… 修改密码？ 请输入验证码… 删除？ 请输入验证码… …… 总之，各类敏感操作，请输入验证码！ 这么多场景中用到验证码，它到底有什么用？作为前端开发者，如何去实现呢？接下来步入正题。 验证码 是一种区分用户是计算机还是人的公共全自动程序。区分用户是真人还是程序，防止程序频繁访问服务器占用过多的资源。 作用： 防止恶意破解密码、刷票、论坛灌水等； 有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 敏感操作前的提示 防止恶意注册 验证码表现方式： 随机字符串验证码 算数验证码 Gif动画验证码 滑动验证码 点选验证码 短信验证码 手机语音验证码 接下来会使用纯前端方式实现其中的一些表现，如随机字符串验证码、算数验证码、滑动验证码等。 本篇记录随机字符串验证码。 随机字符串验证码一般来讲，字符串、算数、gif、短信语音等验证码放在后端实现，但本着技术无界限的原则，前端依然是能照葫芦画瓢给实现出来的。本次要实现的效果如下： 效果 分析验证码实现步骤： canvas画布 生成随机字符串 随机颜色 背景色（可固定色） 噪音线设置 绘制验证码 其他一些基础内容也包含其中，如点击验证码刷新、点击下一步验证等操作。 步骤实现：注：本案例基于vue操作，UI使用element完成，原生js同样道理 1. canvas画布html123456&lt;!-- 输入框 --&gt;&lt;input v-model="inputCode" placeholder="请输入验证码，不区分大小写" /&gt;&lt;!-- canvas画布：验证码 --&gt;&lt;canvas ref="checkCode" @click="getCode"&gt;&lt;/canvas&gt;&lt;!-- 按钮 --&gt;&lt;button @click="checkMe"&gt;下一步&lt;/button&gt; js1234567891011121314151617// 需要的数据data() &#123; return &#123; inputCode: '', // 输入的值 checkCode: '', // 图片验证码的值 // canvas各种设置 cvs: &#123; w: 100, // 给出默认宽度 宽度会在图片绘制时根据长度更改 h: 40, // 高 与input保持一致 fontSize: 24, // 字体大小 // 字符串生成范围 str: '1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPLKJHGFDSAZXCVBNM', len: 4, // 字符串长度 line: 3 // 噪音线个数 &#125; &#125;&#125; 2. 生成随机字符串 写一个随机整数生成器，在各个环节都会用到 生成随机字符串，长度是在data里面cvs中对应长度12345678910111213141516// 随机整数生成器，范围[0, max)rInt(max) &#123; return Math.floor(Math.random() * 100000 % max);&#125;,// 生成随机字符串rCode() &#123; let code = ''; let len = this.cvs.len; let strLen = this.cvs.str.length; for(let i = 0; i &lt; len; i ++) &#123; code += this.cvs.str.charAt(this.rInt(strLen)); &#125; this.checkCode = code; return code;&#125;, 3. 生成随机颜色 rgba格式 a：透明度，取值为0.5-112345 // 生成随机颜色 rgba格式rColor() &#123; let a = ((Math.random()*5 + 5) / 10).toFixed(2); return `rgba($&#123;this.rInt(256)&#125;, $&#123;this.rInt(256)&#125;, $&#123;this.rInt(256)&#125;, $&#123;a&#125;)`&#125;, 4. 开始绘制 方法接收一个dom对象 判断浏览器对canvas支持程度 取随机字符串 设置canvas宽高大小 绘制 具体过程如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 验证码图片绘制drawCode(domCvs) &#123; let _this = this; // 随机字符串 let checkCode = this.rCode(); // 宽设置 this.cvs.w = 10 + this.cvs.fontSize * this.cvs.len; // 判断是否支持canvas if(domCvs !== null &amp;&amp; domCvs.getContext &amp;&amp; domCvs.getContext('2d'))&#123; // 设置显示区域大小 domCvs.style.width = _this.cvs.w; // 设置画板宽高 domCvs.setAttribute('width', _this.cvs.w); domCvs.setAttribute('height', _this.cvs.h); // 画笔 let pen = domCvs.getContext('2d'); // 背景: 颜色 区域 pen.fillStyle = '#eee'; pen.fillRect(0, 0, _this.cvs.w, _this.cvs.h); // 水平线位置 pen.textBaseline = 'middle'; // top middle bottom // 内容 for(let i = 0; i &lt; _this.cvs.len; i ++) &#123; pen.fillStyle = _this.rColor(); // 随机颜色 pen.font = `bold $&#123;_this.cvs.fontSize&#125;px 微软雅黑`; // 字体设置 // 字符绘制: (字符, X坐标, Y坐标) pen.fillText(checkCode.charAt(i), 10 + _this.cvs.fontSize * i, 17 + _this.rInt(10)); &#125; // 噪音线 for(let i = 0; i &lt; _this.cvs.line; i ++) &#123; // 起点 pen.moveTo(_this.rInt(_this.cvs.w) / 2, _this.rInt(_this.cvs.h)); // 终点 pen.lineTo(_this.rInt(_this.cvs.w), _this.rInt(_this.cvs.h)); // 颜色 pen.strokeStyle = _this.rColor(); // 粗细 pen.lineWidth = '2'; // 绘制 pen.stroke(); &#125; &#125; else &#123; this.$message.error('不支持验证码格式，请升级或更换浏览器重试'); &#125;&#125;, 5. 绑定canvas的dom元素html1&lt;canvas class="codeCanvas" ref="checkCode" @click="getCode"&gt;&lt;/canvas&gt; js：getCode方法123// vue的话可直接用$refs取值，不用vue的话可绑定id然后通过document处理let domCvs = this.$refs.checkCode;this.drawCode(domCvs); 6. 完成~ 在页面初始化的时候，也来一个验证码 点击下一步， 验证data中inputCode和checkCode的值是否一样即可。注意，要都换成小写toLowerCase()或者大写去处理~ 12345// 初始化先搞一个验证码~点击canvas的时候重新执行getCode()mounted() &#123; // 获取验证码图 this.getCode();&#125; 结语搞定，收工，最终效果如效果图所示~根据本篇，那算术验证码的效果已然是呼之欲出了……下一篇更新！]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>canvas</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-nginx部署web项目]]></title>
    <url>%2F2020%2F06%2F16%2Fdocker-nginx%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[写在前面作为web端开发er，几乎从未接触过后端及服务端相关知识。但有些场景下又需要将自己的一些东西从公网（域名）上展示出来，比如自己的可开源项目、博客、简历、demo等。有时候我们可以麻烦后台或者运维同事来帮我们搞一搞，但终究授之以鱼不如授之以渔，在同事的帮助下，我也成功的通过一条简单的途径实现了本地文件上传至服务器并从域名访问。本片博客记录下实现过程。本实现途径是在linux服务器中安装docker，然后启用docker-nginx代理实现的，希望对与我面对同样困境的小白有所帮助。第一次接触服务端知识，有错敬请指教，感谢！那么，开始吧~ 0. 准备 云服务器——CentOS 7.x，低配置即可，如[1核 1GB 1Mbps] 域名——已备案 终端远程工具——如：xshell、FinalShell等 提示：以下命令行内容均在服务器中完成~自行通过终端远程工具连接自己的服务器 1. 安装docker1.1 卸载旧版本如已安装想重新安装，或者是旧版本，则执行。如已是新版，跳过本步。12345678$ sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 1.2 使用官方脚本自动安装以下两种方式任选其一 命令：curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 国内 daocloud 命令curl -sSL https://get.daocloud.io/docker | sh 1.3 启动docker$ sudo systemctl start docker 2. Docker 安装 NginxNginx 是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP/POP3/SMTP 服务 。docker内安装nginx,作为web服务器来提供我们所需要的的web服务。 2.1 docker查看nginx可用版本 docker search nginx1234567891011[root@VM_0_10_centos zxm]# docker search nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 13333 [OK] jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1822 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 777 [OK]linuxserver/nginx An Nginx container, brought to you by LinuxS… 115 bitnami/nginx Bitnami nginx Docker Image 84 [OK]tiangolo/nginx-rtmp Docker image with Nginx using the nginx-rtmp… 75 [OK]alfg/nginx-rtmp NGINX, nginx-rtmp-module and FFmpeg from sou… 66 [OK]...... 2.2 安装最新的nginx镜像$ docker pull nginx:latest 2.3 查看本地镜像运行命令查看是否安装成功：$ docker images12REPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 2622e6cca7eb 5 days ago 132MB 如上，有nginx，成功。 3. 创建docker-nginx实例$ docker run --name [name] -p 8080:80 -d nginx [name]—— 容器名称 [-p 8080:80]—— 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口 [-d nginx]—— 设置容器在在后台一直运行 4. 运行容器创建容器后默认是运行状态。可以通过$ docker ps命令查看运行中的容器，通过$ docker ps -a查看docker的所有容器。如，我创建的容器名为zxm-nginx-test，可以在下面容器列表中查看到容器的运行状态及容器信息（id、name等）123[root@VM_0_10_centos zxm]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESdaad54bac361 nginx &quot;/docker-entrypoint.…&quot; 41 hours ago Up About an hour 0.0.0.0:8080-&gt;80/tcp zxm-nginx-test 如果容器未启动，则可以通过$ docker start [容器name或id]来启动容器。 5. 测试访问运行容器启动之后，可以通过服务器公网ip地址测试访问。如：http://[ip]:8080/。出现页面提示如下，表示成功运行。 6. 上传文件到服务器上传本地文件/文件夹（我们的web项目，静态资源）到自己的服务器任意位置。比如我在root下创建了文件夹zxm，通过工具直接将本地文件Loading.html拖入其中。 然后本地资源就上传到了服务器中~ 7. 拷贝文件到docker-nginx容器首先，我们已经将需要的项目（资源）从本地上传到了服务器上；然后我们需要做的则是从服务器上的项目资源从目前所在的地方拷贝到docker-nginx容器内，那么我们就需要知道三个东西： 目标路径 项目所在路径 docker 拷贝命令 接下来，我们一步一步来。 7.1 查找docker-nginx容器目标文件路径 进入容器： docker exec -it daad54bac361 bash 1$ docker exec -it daad54bac361 bash 目录： ls 12root@daad54bac361:/# ls bin boot dev docker-entrypoint.d docker-entrypoint.sh etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 查找配置文件： cd etc/nginx/conf.d/ 123root@daad54bac361:/# cd etc/nginx/conf.d/root@daad54bac361:/etc/nginx/conf.d# lsdefault.conf 查看配置文件： cat default.conf 123456789101112131415161718root@daad54bac361:/etc/nginx/conf.d# cat default.conf server &#123; listen 80; listen [::]:80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; #error_page 404 /404.html; ...&#125; 复制（记录）文件中server&gt;location&gt;root如：/usr/share/nginx/html这个目录则是容器的目标目录，接下来则需将其他位置的资源通过docker命令拷贝到该文件目录下。 退出容器： exit 12root@daad54bac361:/etc/nginx/conf.d# exite xit 7.2 拷贝 先回到刚才本地上传文件至服务器步骤的文件所在服务器位置中 cd到该目录下 docker命令拷贝到容器中docker cp [源文件目录] [容器id]:[目标目录]例如，在我的服务器中，想要将Loading.html传入到容器中，则是：docker cp Loading.html daad54bac361:/usr/share/nginx/html/ 7.3 完成，访问浏览器中输入ip:8080/Loading.html，正常访问到页面，收工~~ 8. nginx域名映射配置以上内容我们完成了基本的服务器项目部署，也就是从公网可以访问自己的项目啦~但是我们不能一直使用公网来访问，不够安全，且不够优雅！那么我们怎么使用域名来访问自己的项目呢？接下来我们操作一下域名映射。 8.1 docker内安装vim工具 进入docker容器docker exec -it [容器id或者name] bash docker内安装vim依次执行以下命令：apt-get updateapt-get install vim 8.2 配置default.conf文件 cd到配置文件目录 123root@daad54bac361:/# cd etc/nginx/conf.d/ root@daad54bac361:/etc/nginx/conf.d# lsdefault.conf 编辑default.conf文件:vim default.conf 修改如下：将server&gt;server_name的localhost改成自己的域名地址，如我的是www.zhuxingmin.com，但我可能会设置二级域名等，将www改成*。则配置如下：server_name *.zhuxingmin.com; 123456789101112131415server &#123; listen 80; listen [::]:80; server_name *.zhuxingmin.com; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; ...&#125; 退出容器exit 8.3 重启docker-nginx容器docker restart [容器name或id]如：12345[root@VM_0_10_centos zxm]# docker restart zxm-nginx-testzxm-nginx-test[root@VM_0_10_centos zxm]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESdaad54bac361 nginx &quot;/docker-entrypoint.…&quot; 40 hours ago Up 5 seconds 0.0.0.0:8080-&gt;80/tcp zxm-nginx-test 9. 域名解析 前提： 域名已备案 打开域名解析 添加记录（解析）12345记录类型: A主机记录: test.zhuxingmin.com解析线路: 默认记录值： 服务器公网ipTTL: 10分钟 然后，打开浏览器，输入自己配置的域名，即可访问到docker-nginx容器中的项目啦~~ 以上。]]></content>
      <tags>
        <tag>云服务器</tag>
        <tag>web</tag>
        <tag>nginx</tag>
        <tag>部署</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios进阶之路——封装篇]]></title>
    <url>%2F2020%2F05%2F26%2Faxios%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、 封装前准备在前两篇讲过了axios的安装、基本配置、拦截器使用，如下： axios进阶之路——基础篇 axios进阶之路——拦截器篇 那么本篇的封装也是基于前两篇的基础之上进行的。 二、 开拔1. 新建文件夹在src目录下新建文件夹，用于存放所有请求列表和请求封装的js。如12345678910├── src │ ├── service // ++ 新建文件夹│ │ ├── http.js // ++ 用于封装请求│ │ ├── apiList.js // ++ 存放请求路径│ ├── page │ │ ├── Home.vue // 主页组件│ ├── router │ │ ├── index.js │ ├── App.vue │ ├── main.js 2. 所有接口请求的统一管理一般情况下，一个项目的所有请求都会由一个统一的基础路径加上不同的接口路径和接口名组成，并且大部分接口都会有统一的请求或者响应处理，例如返回不同code值，要做响应处理，如果把所有接口都单独处理可谓是资源的极大浪费，因此想办法统一管理。在上一步中，已经新建了一个名为service的文件夹，包含两个js文件： apiList.js：存放请求路径 http.js：封装请求 先看第一个：apiList，就是用来将所有接口统一管理的。例如：123456789101112131415// 定义请求列表对象API_LIST，其下每个请求(对象)包含请求方法与请求路径两项const API_LIST = &#123; // get请求 getData1: &#123; method: 'get', url: '/xx/getData1' &#125;, // post请求 getData2: &#123; method: 'post', url: '/xx/getData2' &#125;,&#125;// 导出export default API_LIST 一个项目，特殊接口的话可以单独处理，其余的的所有请求都可以放在这个文件中进行统一管理，之后项目变动找接口修改也会更好维护。 3. 请求封装在请求接口列表处理得当之后，就该在请求实例上做文章了。一般需要处理两个问题：一是走请求，二是拦截器处理。尽可能加上注释的提供一份参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// http.js// 引入axiosimport axios from 'axios'// 引入刚才封装的请求接口列表import api_list from './api/api_list'// 吐司框组件，配合拦截器使用，可自行处理（不要也行）import Toast from 'xxx'// 路由设置，配合拦截器使用，可不要import Router from '../router/index'// baseUrl判断let baseURL;// 如果是开发环境，用本地baseURL，如果是生产环境用线上baseURLif(process.env.NODE_ENV === 'development') &#123; baseURL = 'http://&#123;本地地址&#125;/xxx';&#125; else if(process.env.NODE_ENV === 'production') &#123; baseURL = 'https://&#123;线上地址&#125;/xxx';&#125;// 实例let instance = axios.create(&#123; baseURL: baseURL, // url判断 timeout: 15000 // 超时时间设置&#125;)const Http = &#123;&#125;; // 用来包裹请求的容器// 遍历接口列表for(let key in api_list) &#123; let api = api_list[key]; // 每一项api都包含method, url Http[key] = async function( params, // 请求参数 isFormData = true, // 是否是form-data请求 config = &#123;&#125; // 配置参数 ) &#123; let newParams = &#123;&#125;; // 参数容器 // content-type 参数转换 // 如果需要form-data请求，则格式化为form-data，一般用于post请求 if(params &amp;&amp; isFormData) &#123; newParams = new FormData(); for(let key in params) &#123; newParams.append(key, params[key]) &#125; &#125; else &#123; // 一般用于get请求 newParams = params; &#125; // 返回值容器 let res = &#123;&#125;; // 不同请求判断 if(api.method === 'post') &#123; // post请求处理 try&#123; res = await instance[api.method](api.url, newParams, config); &#125; catch(err) &#123; res = err; &#125; &#125; else if(api.method === 'get') &#123; // get请求处理 config.params = newParams; try&#123; res = await instance[api.method](api.url, config); &#125; catch(err) &#123; res = err; &#125; &#125; // 返回返回值 return res; &#125;&#125;// 请求拦截器instance.interceptors.request.use(req =&gt; &#123; // 吐司：loading框加载，不要也行 Toast.loading(&#123; message: '加载中...', forbidClick: true, loadingType: 'spinner' &#125;); return req;&#125;, err =&gt; &#123; // 请求错误 Toast.clear(); // 清除吐司 Toast.fail('请求失败，请稍后重试');&#125;)// 响应拦截器instance.interceptors.response.use(res =&gt; &#123; Toast.clear(); // 清除吐司 // 不同的返回值跳相应路由即可，如201跳登陆，202跳加载失败等，根据需求自行处理 if(res.data.code === 201) &#123; Router.push('/login') &#125; else if(res.data.code === 202) &#123; Router.push('/loadfail') &#125; else &#123; // ... &#125; // 返回返回值，返回值为res.data return res.data&#125;, err =&gt; &#123; Toast.clear(); // 清除吐司 Toast.fail('无响应，请稍后重试');&#125;)// 导出请求export default Http 4. 使用封装完成，盘他！ 4.1 挂载到vue实例上123456789// main.jsimport Vue from 'vue'// 引入import Http from './service/http'// Vue 实例挂载Vue.prototype.$Http = Http// ... 4.2 测试使用在某个vue文件中：12345678910111213141516171819202122232425262728293031323334353637export default &#123; data() &#123; return &#123; data: &#123;&#125; &#125; &#125;, methods: &#123; // 获取get请求数据，注意async和await配对使用 async getData1() &#123; let res = await _this.$Http.getData1(&#123; id: 'xxx', token: 'xxx' &#125;, false); // false代表不是formdata格式 if(res.code === 200) &#123; alert('get数据返回成功'); &#125; &#125;, // 获取post请求数据，注意async和await配对使用 // 此处是formdata格式，第二个参数可写true,因为默认为true，因此可以不写 async getData2() &#123; let res = await this.$Http.getData2(&#123; id: 'xxx', token: 'xxx' &#125;); if(res.code === 200) &#123; alert('post数据返回成功'); &#125; &#125;, &#125;, mounted() &#123; this.getData1(); this.getData2(); &#125;,&#125; 经测试，普通格式（非文件等）请求有效，简单封装完成~ 三、 完结撒花~一般接口的请求封装完毕，用到了基于axios的一些知识，记录至此。在项目中灵活运用，相比于一个个接口单独处理，可谓是大幅度的提升哟~另外，基于此，也可配合proxy（在vue.config.js中配置）处理跨域问题，就不在此处赘述了。 以上。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>axios</tag>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode/webstorm自定义vue模板]]></title>
    <url>%2F2020%2F05%2F14%2Fvscode-webstorm%E8%87%AA%E5%AE%9A%E4%B9%89vue%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[webstorm1. 打开设置打开设置：File =&gt; Settings 2. 安装vue插件在搜索区输入plugins，或者找到plugins选项，右边的Marketplace搜索vue，安装。 3. 自定义模板有时候我们新建vue文件时默认的模板不是我们想要的，这时可以自定义模板：还是在设置中，搜索框输入file and code template或者在设置中找到该选项也行，在右侧选择vue模板，然后在编辑区修改模板即可。如图 4. 参考给出一份我自己的作为参考，可按自己常用规则优化修改。其中，${COMPONENT_NAME}直接获取组件名。123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;$&#123;COMPONENT_NAME&#125;&quot;, props: [], components: &#123; &#125;, data () &#123; return &#123; &#125; &#125;, methods: &#123; &#125;, mounted () &#123; &#125; &#125;&lt;/script&gt;&lt;style type=&quot;text/scss&quot; lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; vscode1. 安装Vetur在应用市场中安装Vetur 2. 使用此时，在vue项目中新建.vue文件，然后输入vue时，按tab键则会出来一份默认的模板。由于默认模板涵盖内容过少，因此我们仍需要对齐进行自定义模板配置。 3. 自定义模板 打开 文件 =&gt; 首选项 =&gt; 用户片段 搜索关键词vue 在候选列表中选择vue.json 在打开的文件中自定义配置即可 如果没有找到vue.json，可以重启一下vscode试一下。 4. 参考给出一份参考123456789101112131415161718192021222324252627282930313233&#123; "Print to console": &#123; "prefix": "vue", "body": [ "&lt;template&gt;", " &lt;div&gt;\n", " &lt;/div&gt;", "&lt;/template&gt;\n", "&lt;script&gt;", "export default &#123;", " props: &#123;\n", " &#125;,", " components: &#123;\n", " &#125;,", " data() &#123;", " return &#123;\n", " &#125;;", " &#125;,", " watch: &#123;\n", " &#125;,", " methods: &#123;\n", " &#125;,", " mounted() &#123;\n", " &#125;,", "&#125;;", "&lt;/script&gt;\n", "&lt;style scoped lang=\"$&#123;1:scss&#125;\" type=\"text/scss\"&gt;\n", "&lt;/style&gt;\n", ], "description": "Create vue template" &#125;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webstorm</tag>
        <tag>vscode</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios进阶之路——拦截器篇]]></title>
    <url>%2F2020%2F05%2F13%2Faxios%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E6%8B%A6%E6%88%AA%E5%99%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、 拦截器介绍一般在使用axios时，会用到拦截器的功能，一般分为两种：请求拦截器、响应拦截器。 请求拦截器在请求发送前进行必要操作处理，例如添加统一cookie、请求体加验证、设置请求头等，相当于是对每个接口里相同操作的一个封装； 响应拦截器同理，响应拦截器也是如此功能，只是在请求得到响应之后，对响应体的一些处理，通常是数据统一处理等，也常来判断登录失效等。 二、 Axios实例准备工作：axios安装： yarn add axios 实例创建：新建js文件12345678// 引入axiosimport axios from 'axios'// 实例let instance = axios.create(&#123; baseURL: 'xxxxxxxxxx', timeout: 15000 // 毫秒&#125;) baseURL设置：1234567891011121314...let baseURL;if(process.env.NODE_ENV === 'development') &#123; baseURL = 'xxx本地环境xxx';&#125; else if(process.env.NODE_ENV === 'production') &#123; baseURL = 'xxx生产环境xxx';&#125;// 实例let instance = axios.create(&#123; baseURL: baseURL, ...&#125;) 修改实例的3种配置 全局配置 123// 局限性比较大axios.defaults.timeout = 1000;axios.defaults.baseURL = 'xxxxx'; 实例配置 123456let instance = axios.create(&#123; baseURL: 'xxxxx', timeout: 1000, // 超时，401&#125;)// 创建完想要修改：instance.defaults.timeout = 3000 请求配置 123instance.get('/xxx',&#123; timeout: 5000&#125;) 优先级如下：请求配置 &gt; 实例配置 &gt; 全局配置 三、 拦截器配置首先了解两个方法：1234// 请求拦截器instance.interceptors.request.use(req=&gt;&#123;&#125;, err=&gt;&#123;&#125;);// 响应拦截器instance.interceptors.reponse.use(req=&gt;&#123;&#125;, err=&gt;&#123;&#125;); 从上可以看出，instance依然是第二步中创建的实例，然后对齐进行拦截，请求用request，响应用reponse，二者都有两个配置项，一个是成功配置，一个是error配置。接下来简单举例说明。 请求拦截器1234567891011// use(两个参数)axios.interceptors.request.use(req =&gt; &#123; // 在发送请求前要做的事儿 ... return req&#125;, err =&gt; &#123; // 在请求错误时要做的事儿 ... // 该返回的数据则是axios.catch(err)中接收的数据 return Promise.reject(err)&#125;) 响应拦截器123456789101112// use(两个参数)axios.interceptors.reponse.use(res =&gt; &#123; // 请求成功对响应数据做处理 ... // 该返回的数据则是axios.then(res)中接收的数据 return res&#125;, err =&gt; &#123; // 在请求错误时要做的事儿 ... // 该返回的数据则是axios.catch(err)中接收的数据 return Promise.reject(err)&#125;) 常见错误码处理(error)错误处理，请求错误时进行的处理。123axios.get().then().catch(err =&gt; &#123; // 错误处理&#125;) 但实际开发过程中，一般在请求/响应拦截器中统一做错误处理，有特殊接口的话做单独的catch错误处理。 1. 请求错误码处理 404： not found 401： 请求超时123axios.interceptors.request.use(req, err =&gt; &#123; // 此处做统一处理&#125;) 2. 响应错误码处理 500： 系统错误 502： 系统重启123axios.interceptors.reponse.use(res, err =&gt; &#123; // 此处做统一处理&#125;) ——以上。下一篇记录整个请求流程，以及请求的封装。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>axios</tag>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios进阶之路——基础篇]]></title>
    <url>%2F2020%2F05%2F12%2Faxios%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、 关于Axios1. Axios是什么 Axios是一个基于 promise 的 HTTP 库 可以用于浏览器和 node.js 类似于 Ajax，进行前后端交互使用 2. Axios 特性 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换JSON数据 客户端支持防御 XSRF 二、 安装使用1. 安装两种方式：（二选一） npm yarn 12// 使用npm：$ npm install axios 12// 或者使用yarn：$ yarn add axios 2. 使用基础使用示例12345678// 引入axiosimport axios from 'axios'axios.get('url').then(res =&gt; &#123; // 请求成功要做的事&#125;).catch(err =&gt; &#123; // 请求失败要做的事&#125;) 三、 基础介绍及使用1. axios常用请求方法 get post put patch delete 2. 区别 方法 用途 备注 get 获取数据 / post 提交数据 表单提交、文件上传等 put 更新数据 所有数据推送到后端 patch 更新数据 只将修改的数据推送到后端 delete 删除数据 / 其中get,post目前前后端交互中最为常用 注：请求方法一般由后端定义，实际项目使用参照后端文档规则 3. 常用示例（GET、POST）GET123456789// getaxios.get('/data.json',&#123; // 注 此处参数写入params中 params: &#123; id: 'zxm' &#125;&#125;).then(res =&gt; &#123; console.log(res);&#125;) POST12345678// post：参数直接跟在url后面即可axios.post('xxxxxxxxx', &#123; xxx: 'xxxx', xxxx: 'xxxx' &#125;&#125;).then(res =&gt; &#123; console.log(res);&#125;) 4. 并发请求并发请求： 同时进行多个请求，并统一处理返回值。两个步骤： axios.all([]).then() axios.spread() 举例：12345678axios.all([ axios.get('url1'), axios.get('url2')]).then( axios.spread((res1, res2) =&gt; &#123; console.log(res1, res2); &#125;)) ——基础篇到此结束，下篇记录axios简单实例，请求拦截器，响应拦截器。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>axios</tag>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css布局之道——内凹圆角设计]]></title>
    <url>%2F2020%2F04%2F29%2Fcss%E5%B8%83%E5%B1%80%E4%B9%8B%E9%81%93%E2%80%94%E2%80%94%E5%86%85%E5%87%B9%E5%9C%86%E8%A7%92%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[一、 效果图先来看一下效果图： 二、 实现1. 场景看上图，此类场景应该很是常用吧，比如账单、卡片、列表等。 2. 实现思路看到效果图，能想到的实现方法则是 planA：border-radius直接搞起来 planB：定位 但是细想之后发现两者皆不可用，border-radius处理的话是凸角，舍弃；定位需要独立出来两个模块，复杂度高了，舍弃。可是舍弃后，需要怎么做呢？切背景图吗？显然不合理，如果内容不固定，则模块的长度也不一样，背景图也会拉伸；思来想去，还是得从定位上做文章：既然元素多比较复杂，那就直接在伪类上动手。可能大家猜到了，就是直接在::before、::after上模拟出来。 三、 代码1. 基础布局123456&lt;!-- html：随便一些div --&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 1234567891011121314151617body&#123; margin: 0; background: #000; padding: 20px 0;&#125;div&#123; width: 80vw; min-height: 15vh; background: #666; border-radius: 6px; margin: 0 auto; position: relative; border-top: 1px dashed #333;&#125;div:first-child&#123; border: none;&#125; 2. 伪类基础布局出来后，怎么利用伪类处理呢？思路是这样的： 利用伪类画出来一个与主题背景色一样的圆； 定位，向左(右)偏移圆自身的一半，视觉效果就是半个圆在上面； 继续定位，向上继续偏移小球的一半，视觉效果则是每个模块有个四分之一内凹圆角一样。 知道思路后，就继续实现吧：12345678910111213141516171819202122div::before,div::after&#123; content: ''; width: 20px; height: 20px; border-radius: 50%; background: #000; position: absolute; z-index: 999;&#125;div::before&#123; left: -10px; top: -10px;&#125;div::after&#123; right: -10px; top: -10px;&#125;div:first-child::before,div:first-child::after&#123; content: ''; width: 0; height: 0;&#125; 这样就完成了~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《活好》记录]]></title>
    <url>%2F2020%2F04%2F01%2F%E3%80%8A%E6%B4%BB%E5%A5%BD%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[时时可死，努力求生 1. 死亡并不是生命的结束 1.1 死亡是怎么回事 人死后并不会消失，而是会以更深刻的方式留在生者的生命里。1.2 生命究竟是生命 生命是种能量体，看不到，却存在 生命存在于我们能够支配的时间里1.3 如何活出真实的自己 不在乎身外之物 不被他人的评价左右 顺其自然，不要勉强 首先要鼓起勇气行动起来 2. 关于爱 2.1 爱与被爱 人在传递爱时，自己也能获得幸福 爱是接受最真实的他 2.2 如何看待朋友 真正的朋友，纵使多年没有联络，也无论境遇发生怎样的变化，他都会把你的事儿当做自己的事儿 2.3 爱到底是什么 爱是人生存的终极目的 3. 宽恕很难做到 宽恕别人 终止霸凌 如何与年轻人共处 4. 不易化解的困难 4.1 面对突发的丧亲之痛 请相信花儿还会绽放，请耐心等待美好再次降临 4.2 当遭遇反对时 要相信真正有价值的东西，终有一天会被认可 4.3 培养孩子 家长要做的是耐心等待孩子长大成熟 5. 遇见未知的自己 5.1 如何保持心态年轻 一个人想活出崭新的自我 5.2 如何与人亲近 一起笑，能消除人们之间的隔阂，能将大家紧密的联结起来 5.3 “伟人”是什么样子的 所谓伟人，就是能为别人花时间的人 因为相信，所以看见]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MockJs使用分享]]></title>
    <url>%2F2020%2F03%2F24%2FMockJs%E4%BD%BF%E7%94%A8%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在前后端分离的时代，项目开发测试中我们常常因为前后端完成模块功能时间不一致而导致开发效率的降低，尤其是需要接口对接之时。鉴于此，MockJs应时而生，对此痛点予以重击。&emsp;本篇案例则属于一个简单的示范案例，在脱离后端（在没与后端联调前）怎么自己模拟数据来调试前端内容。 一、 效果图先看效果图： 二、 简介 1. 地址 官网http://mockjs.com/ 示例https://github.com/nuysoft/Mock/wiki 2. 资源 官网资源http://mockjs.com/dist/mock.js cdn&lt;script src=&quot;https://cdn.bootcss.com/Mock.js/1.0.1-beta3/mock-min.js&quot;&gt;&lt;/script&gt; 3. 亮点 六大优点 描述 前后端分离 让前端攻城师独立于后端进行开发 增加单元测试的真实性 通过随机数据，模拟各种场景 开发无侵入 不需要修改既有代码，就可以拦截 Ajax 请求，返回模拟的响应数据 用法简单 符合直觉的接口 数据类型丰富 支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等 方便扩展 支持支持扩展更多数据类型，支持自定义函数和正则 三、 使用1. 引入普通的.html文件直接标签引入即可，一些框架类可使用后者npm等安装使用 标签引入12345// html&lt;script src="http://mockjs.com/dist/mock.js"&gt;&lt;/script&gt;&lt;script&gt; // some codes...&lt;/script&gt; npm通过npm安装，引入12// 安装npm i mockjs 12345678// 使用import Mock from 'nockjs'// 示例Mock.mock('/data', &#123; name: '@cname' // 生成中文姓名 ... // 按API写各种配置就能得到自己想要的数据&#125;) 2. 常用接口Mock.mock( rurl, rtype, template | function(options) ) 参数对照： 参数 是否必选 描述 rurl 可选 要拦截的url。注意，如果使用get的拼参链接，可以使用正则匹配 rtype 可选 要拦截的请求类型，一般为get或post template 可选 要返回的数据模板，也就是在此处写生成规则，返回数据都会按照这个模板返回 function(options) 可选 同上template二选一。其中options打印出来是一些基础参数，包括url,请求方式等，可以从中获取到请求中传的值，根据这些数据模拟更加真实的返回数据 四、 实例上面分享了一个动图，是简单地通过一个数字传输，到生成返回数据，到数据渲染，简单地展示MockJs在实际使用时的操作。接下来实现一下： 1. 布局12345678910111213141516171819202122232425262728&lt;!-- 输入框和按钮 --&gt;&lt;div&gt; &lt;div&gt; &lt;label for="counts"&gt;Data Length&lt;/label&gt; &lt;input type="number" id="counts" placeholder="生成数据长度" &gt; &lt;/div&gt; &lt;button type="submit" id="build"&gt;Build&lt;/button&gt;&lt;/div&gt;&lt;!-- 表格 --&gt;&lt;div&gt; &lt;table&gt; &lt;thead&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;th&gt;文章数&lt;/th&gt; &lt;th&gt;回答数&lt;/th&gt; &lt;th&gt;点赞&lt;/th&gt; &lt;/thead&gt; &lt;tbody id="data"&gt; &lt;!-- 这里渲染返回数据 --&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 2. ajax请求1234567891011121314151617181920212223// 此处使用的jq，用axios等亦可$('#build').click(() =&gt; &#123; const counts = parseInt($('#counts').val()); if(! counts) &#123; alert('请输入您想要的长度哦'); &#125;else&#123; if($('#counts').val() &lt; 0 || $('#counts').val() &gt; 100) &#123; alert('请输入1-100的长度哦~'); &#125;else&#123; $.ajax(&#123; url: 'https://www.zhuxingmin.com/lists', type: 'get', dataType: 'json', data: &#123; counts: counts &#125;, success: res =&gt; &#123; // 返回数据结果处理 &#125; &#125;) &#125; &#125;&#125;) 3. Mock登场123456789101112131415161718192021222324252627282930// 拦截// url正则匹配// get方式// params即上边提到的options，可从中得到url,post,body等信息Mock.mock(RegExp('/lists*.'), 'get', params =&gt; &#123; // 拿到ajax传的数据 const len = params.url.split('?')[1].split('&amp;')[0].split('=')[1]; // 返回随机数据的模板 return Mock.mock(&#123; code: 200, // 默认固定code:200 data: &#123; // 重头戏 // userList|$&#123;len&#125;： mockJs语法，len表示个数 [`userList|$&#123;len&#125;`]: [ &#123; 'uid|+1': 1, // uid从1开始，依次+1 name: '@cname', // 随机中文名 'age|13-30': 13, // 13-30的随机整数 'gender|1-2': 0, // 1-2的随机整数 address: '@county(true)', // 生成随机地址 info: &#123; 'articles|3-150': 3, // 3-150随机整数 'answer|9-99': 1, // 9-99随机整数 'favorate|15-99999': 1, // 15-99999随机整数 &#125; &#125; ] &#125;, msg: '请求成功' // 返回默认提示 &#125;)&#125;) 4. 返回数据处理刚才在第二步的时候，我们只是发送了请求，在success中没有对返回数据进行处理。现作如下处理：12345678910111213141516success: res =&gt; &#123; let html = ''; for(let i = 0; i &lt; res.data.userList.length; i ++) &#123; html += `&lt;tr&gt; &lt;td&gt;$&#123;res.data.userList[i].uid&#125;&lt;/td&gt; &lt;td&gt;$&#123;res.data.userList[i].name&#125;&lt;/td&gt; &lt;td&gt;$&#123;res.data.userList[i].age&#125;&lt;/td&gt; &lt;td&gt;$&#123;res.data.userList[i].gender === 1 ? '男' : '女'&#125;&lt;/td&gt; &lt;td&gt;$&#123;res.data.userList[i].address&#125;&lt;/td&gt; &lt;td&gt;$&#123;res.data.userList[i].info.articles&#125;&lt;/td&gt; &lt;td&gt;$&#123;res.data.userList[i].info.answer&#125;&lt;/td&gt; &lt;td&gt;$&#123;res.data.userList[i].info.favorate&#125;&lt;/td&gt; &lt;/tr&gt;` &#125; $('#data').html(html);&#125; 可以适当的添加样式来美化一些，不再示例。完成. 结语&emsp;&emsp;不难看出，有了Mock，前后端人员只需要定义好接口文档就可以开始并行工作，互不影响，在前端工程化中，能够高效定位代码缺陷，提前管理/修复缺陷，且有利于整个产品质量以及进度的保证。本案例只是入门级的示例，但依然能够帮助前端开发人员有一个不错的提升。更加深层次的例如原理等，本文不再探究。PS：想要完整版demo的可以扫描二维码或者微信搜索公众号”流眸“回复mock获取~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>tools</tag>
        <tag>mockjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS交互微信之JSAPI支付]]></title>
    <url>%2F2020%2F03%2F03%2FJS%E4%BA%A4%E4%BA%92%E5%BE%AE%E4%BF%A1%E4%B9%8BJSAPI%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[前言本篇为JS交互微信系列篇的第四篇微信JSAPI支付，记录在微信内置浏览器内用调用微信支付过程。 一、 介绍JSAPI支付是用户在微信中打开商户的H5页面，商户在H5页面通过调用微信支付提供的JSAPI接口调起微信支付模块完成支付。 应用场景： 用户在微信公众账号内进入商家公众号，打开某个主页面，完成支付 用户的好友在朋友圈、聊天窗口等分享商家页面连接，用户点击链接打开商家页面，完成支付 将商户页面转换成二维码，用户扫描二维码后在微信浏览器中打开页面后完成支付 二、 准备1. 准备内容要拥有两个账号： 微信服务号，要通过认证（企业才拥有资格） 微信商户平台号(微信支付平台) 2. 平台配置2.1 微信支付(商户平台)中要开通产品中心的JSAPI支付。然后产品中心=&gt;开发配置=&gt;支付配置=&gt;公众号支付配置绑定支付授权目录，写已通过ICP备案的域名。另外，要在ip白名单中，配置测试地址ip和线上生产地址ip，不然各种回调都会失败！ 2.2 微信公众平台中由于在微信内支付需要获取用户的openid，要获取它则必须通过网页授权配置。在公微信公众平台中，公众号设置=&gt;功能设置=&gt;网页授权域名中按要求填写。 三、 开发在支付流程方面，重点依然都在后端处理，前端方面步骤比较简单。本文只叙述前端内容。 1. 用户授权，获取code在将要进入支付的前一页面，直接接入微信授权，然后跳转进要支付的那个页面。举个例子：有a、b两个页面，在b页面用到支付，b页面由a页面跳转而来。那么在a页面跳b页面的时候，别直接跳转b的url，而是跳转到：https://open.weixin.qq.com/connect/oauth2/authorize?appid={appId}&amp;redirect_uri={b.html}&amp;response_type=code&amp;scope=snsapi_base#wechat_redirect我们注意到，这里有这两个需要自己写的参数：appid和redirect_uri，意义是： appid——服务号id redirect_uri——获取授权后回调的页面地址，比如b页面 另外，还有一个注意的点是，b.html这个url我们要进行encode转码，不然地址解析可能会出现问题！ 123// url转码let url = 'a.html';url = escape(url); 2. 得到code，换取凭证获取openid上一步执行完后，在微信浏览器中，我们会得到一个链接，类似：b.html?&amp;code={code}&amp;state=#/在此处，我们得到了一个code值，这就是我们获取openid的凭证了。获取方法当然是把值传给后台，后台去处理啦~ 3. 接收后端返回的我们需要的参数值在上一步中，我们拿到code值后，就可以提交一些信息给后端了，比如商品相关属性、总价等，另外加上code值，传给后端。后端一顿操作后，返回给前端。我们需要的参数如下（后端返回下面这些参数）：123456789// 微信支付需要参数orderInfo: &#123; package: '', // 前端需要从后台获取该数据 paySign: '', // 微信签名，前端需要从后台获取该数据 appId: '', // 需要在微信绑定商户号，成功之后会生成有appid signType: '', // 微信签名方式,默认为"MD5",也可以从后台获取 nonceStr: '', // 随机串，前端需要从后台获取该数据 timeStamp: '', // 时间戳，自1970年以来的秒数，前端需要从后台获取该数据&#125; 4. 交互微信上个步骤拿到需要交互微信的参数后，就开始调用微信的支付接口了，如下：1234567891011121314151617181920212223242526// 微信支付WeixinJSBridge.invoke('getBrandWCPayRequest', &#123; appId: _this.orderInfo.appId, // 上一步得到的参数 nonceStr: _this.orderInfo.nonceStr, // 上一步得到的参数 package: _this.orderInfo.package, // 上一步得到的参数 signType: _this.orderInfo.signType, // 上一步得到的参数 timeStamp: _this.orderInfo.timeStamp, // 上一步得到的参数 paySign: _this.orderInfo.paySign // 上一步得到的参数&#125;, res =&gt; &#123; // 调用后要做的事儿 // codes... // 根据get_brand_wcpay_request的值判断支付状态 if (res.err_msg === "get_brand_wcpay_request:ok") &#123; // ok：支付成功 // 支付成功要做的事儿，比如跳转支付完成后的页面等 &#125; else if (res.err_msg === "get_brand_wcpay_request:cancel") &#123; // cancel：用户取消支付 // 取消支付要做的事儿，比如进入重新支付步骤等 &#125; else if (res.err_msg === "get_brand_wcpay_request:fail") &#123; // fail： 支付失败 // 支付失败要做的事儿，比如进入支付失败步骤等 &#125; // 注： 使用以上方式判断前端返回,微信团队郑重提示：res.err_msg将在用户支付成功后返回ok,但并不保证它绝对可靠。&#125;) 5. 常见错误码 名称 描述 原因 解决方案 INVALID_REQUEST 参数错误 参数格式有误或者未按规则上传 订单重入时，要求参数值与原请求一致，请确认参数问题 NOAUTH 商户无此接口权限 商户未开通此接口权限 请商户前往申请此接口权限 NOTENOUGH 余额不足 用户帐号余额不足 用户帐号余额不足，请用户充值或更换支付卡后再支付 ORDERPAID 商户订单已支付 商户订单已支付，无需重复操作 商户订单已支付，无需更多操作 ORDERCLOSED 订单已关闭 当前订单已关闭，无法支付 当前订单已关闭，请重新下单 SYSTEMERROR 系统错误 系统超时 系统异常，请用相同参数重新调用 APPID_NOT_EXIST APPID不存在 参数中缺少APPID 请检查APPID是否正确 MCHID_NOT_EXIST MCHID不存在 参数中缺少MCHID 请检查MCHID是否正确 APPID_MCHID_NOT_MATCH appid和mch_id不匹配 appid和mch_id不匹配 请确认appid和mch_id是否匹配 LACK_PARAMS 缺少参数 缺少必要的请求参数 请检查参数是否齐全 OUT_TRADE_NO_USED 商户订单号重复 同一笔交易不能多次提交 请核实商户订单号是否重复提交 SIGNERROR 签名错误 参数签名结果不正确 请检查签名参数和方法是否都符合签名算法要求 XML_FORMAT_ERROR XML格式错误 XML格式错误 请检查XML参数格式是否正确 REQUIRE_POST_METHOD 请使用post方法 未使用post传递参数 请检查请求参数是否通过post方法提交 POST_DATA_EMPTY post数据为空 post数据不能为空 请检查post数据是否为空 NOT_UTF8 编码格式错误 未使用指定编码格式 请使用UTF-8编码格式 三、 完成至此，调用微信JSAPI来完成在微信内的支付就完成了。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>微信</tag>
        <tag>js</tag>
        <tag>jssdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS交互微信之自定义分享]]></title>
    <url>%2F2020%2F02%2F28%2FJS%E4%BA%A4%E4%BA%92%E5%BE%AE%E4%BF%A1%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[前言本篇为JS交互微信系列篇的第三篇自定义微信分享，记录在微信内置浏览器打开页面再分享时对分享的处理。 一、 介绍在微信中打开的页面，如果我们不加操作直接分享出去，除了分享的不太美观（只有title\url，而不是自定义的标题、副标题、图片等），也有可能不太符合正常流程，如：用户在a页面通过登录进如了b页面，然后将b页面直接分享给别的用户，如果我们不加以处理，那么别的用户点击b页面则会是错误页（因为跨过了登录）。当面临此类情况时，搞一下自定义分享还是十分有必要的。 二、 注意事项请注意，不要有诱导分享等违规行为，对于诱导分享行为将永久回收公众号接口权限 请注意，原有的 wx.onMenuShareTimeline、wx.onMenuShareAppMessage、wx.onMenuShareQQ、wx.onMenuShareQZone 接口，即将废弃。请尽快迁移使用客户端6.7.2及JSSDK 1.4.0以上版本支持的 wx.updateAppMessageShareData、wx.updateTimelineShareData接口。引入低版本的script链接，这些接口暂时仍可用。 三、 示例代码1. 引入script12// 主文件 或 入口文件 引入&lt;script src="https://res.wx.qq.com/open/js/jweixin-1.1.0.js"&gt;&lt;/script&gt; 2. wx.config配置12345678910111213// 微信配置// appId、timestamp、nonceStr、signature从公众号和后台获取wx.config(&#123; debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: '', // 必填，公众号的唯一标识 timestamp: '', // 必填，生成签名的时间戳 nonceStr: '', // 必填，生成签名的随机串 signature: '',// 必填，签名 jsApiList: [ 'checkJsApi', 'openAddress' ] // 必填，需要使用的JS接口列表 这里填写需要用到的微信api openlocation为使用微信内置地图查看位置接口&#125;); 3. 自定义分享[老版本]3.1 分享到朋友圈12345678wx.onMenuShareTimeline(&#123; title: '', // 分享标题 link: '', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: '', // 分享图标 success: function () &#123; // 用户点击了分享后执行的回调函数 &#125;&#125; 3.2 分享给朋友1234567891011wx.onMenuShareAppMessage(&#123; title: '', // 分享标题 desc: '', // 分享描述 link: '', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: '', // 分享图标 type: '', // 分享类型,music、video或link，不填默认为link dataUrl: '', // 如果type是music或video，则要提供数据链接，默认为空 success: function () &#123; // 用户点击了分享后执行的回调函数 &#125;&#125;) 3.3 分享到QQ123456789101112wx.onMenuShareQQ(&#123; title: '', // 分享标题 desc: '', // 分享描述 link: '', // 分享链接 imgUrl: '', // 分享图标 success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125;&#125;) 3.4 分享到QQ空间123456789101112wx.onMenuShareQZone(&#123; title: '', // 分享标题 desc: '', // 分享描述 link: '', // 分享链接 imgUrl: '', // 分享图标 success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125;&#125;) 4. 自定义分享[新版本]4.1 分享给朋友&amp;&amp;分享到QQ1234567891011wx.ready(function () &#123; //需在用户可能点击分享按钮前就先调用 wx.updateAppMessageShareData(&#123; title: '', // 分享标题 desc: '', // 分享描述 link: '', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: '', // 分享图标 success: function () &#123; // 设置成功 &#125; &#125;)&#125;) 4.2 分享到朋友圈 &amp;&amp; 分享到QQ空间12345678910wx.ready(function () &#123; //需在用户可能点击分享按钮前就先调用 wx.updateTimelineShareData(&#123; title: '', // 分享标题 link: '', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: '', // 分享图标 success: function () &#123; // 设置成功 &#125; &#125;)&#125;) 以上。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>微信</tag>
        <tag>js</tag>
        <tag>jssdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS交互微信之获取收货地址]]></title>
    <url>%2F2020%2F02%2F27%2FJS%E4%BA%A4%E4%BA%92%E5%BE%AE%E4%BF%A1%E4%B9%8B%E8%8E%B7%E5%8F%96%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[前言本篇为JS交互微信系列篇的第二篇，上一篇《JS交互微信之基础配置》讲述了基础配置，本篇记录获取（共享）用户收货地址。 一、 场景在需要用户实际收货地址时，可以直接拉取用户微信中存在的收货地址，或者在微信中新增、编辑及删除收货地址，而后传给商户 二、 介绍1. 简介微信收货地址共享，是指用户在微信浏览器内打开网页，填写过地址后，后续可以免填写支持快速选择，也可增加和编辑。此地址为用户属性，可在各商户的网页中共享使用。支持原生控件填写地址，地址数据会传递到商户。 2. 功能支持地址共享是基于微信JavaScript API 实现，只能在微信内置浏览器中使用，其他浏览器调用无效。同时，需要微信5.0 版本才能支持，建议通过user agent 来确定用户当前的版本号后再调用地址接口。以iPhone 版本为例，可以通过useragent可获取如下微信版本示例信息：”Mozilla/5.0(iphone;CPU iphone OS 5_1_1 like Mac OS X)AppleWebKit/534.46(KHTML,like Geocko) Mobile/9B206MicroMessenger/5.0“其中5.0 为用户安装的微信版本号，商户可以判定版本号是否高于或者等于5.0。 3. 地址格式微信地址共享使用的数据字段包括： 收货人姓名 地区，省市区三级 详细地址 邮编 联系电话 国际编码 三、 接口说明openAddress12345678wx.openAddress(&#123; success: function () &#123; // 用户成功拉出地址 &#125;, cancel: function () &#123; // 用户取消拉出地址 &#125;&#125;); 返回值说明 返回值 说明 errMsg 获取编辑收货地址成功返回“openAddress:ok” userName 收货人姓名 postalCode 邮编 provinceName 国标收货地址第一级地址（省） cityName 国标收货地址第二级地址（市） countryName 国标收货地址第三级地址（国家） detailInfo 详细收货地址信息 nationalCode 收货地址国家码 telNumber 收货人手机号码 四、 示例代码1. 引入script12// 主文件 或 入口文件 引入&lt;script src="https://res.wx.qq.com/open/js/jweixin-1.1.0.js"&gt;&lt;/script&gt; 2. wx.config配置12345678910111213// 微信配置// appId、timestamp、nonceStr、signature从公众号和后台获取wx.config(&#123; debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: '', // 必填，公众号的唯一标识 timestamp: '', // 必填，生成签名的时间戳 nonceStr: '', // 必填，生成签名的随机串 signature: '',// 必填，签名 jsApiList: [ 'checkJsApi', 'openAddress' ] // 必填，需要使用的JS接口列表 这里填写需要用到的微信api openlocation为使用微信内置地图查看位置接口&#125;); 3. 获取地址12345678910111213141516171819202122232425262728293031wx.ready(function () &#123; // 检测接口是否可用，开发环境中测试用，生产环境没问题可不写 wx.checkJsApi(&#123; jsApiList: [ 'openAddress', ], success: function (res) &#123; alert(res); &#125; &#125;); // 请求接口 wx.openAddress(&#123; // 请求成功要做的事 success: (res) =&gt; &#123; // 这里我把获取到的用户信息存储到了vuex中的state中保存，以防后续路由跳转带来的组件销毁带来的数据没法保存 // 根据自己需求拿自己需要的参数即可，参数名可对照上面的返回值说明表 _this.$store.state.address.userName = res.userName; _this.$store.state.address.telNumber = res.telNumber; _this.$store.state.address.nationalCode = res.nationalCode; _this.$store.state.address.provinceName = res.provinceName; _this.$store.state.address.cityName = res.cityName; _this.$store.state.address.countryName = res.countryName; _this.$store.state.address.detailInfo = res.detailInfo; &#125;, cancel: function () &#123; // 用户取消要做的事儿 // 这里我把请求时打开的一个loading动画给关闭了 _this.$layer.close(); &#125;, &#125;);&#125;); 五、 常见问题在开发中，我遇到的问题如下： 必须发布到线上测试，没找到好的解决办法； 公众号（服务号）中要设置IP白名单，不然通不过验证！ 安卓可以调起而iOS无法调起：引入script链接时，应引入https而不是http，可能iOS对安全策略这块儿比较严格，在此处踩了个坑。 在PC端无法调起！ 以上。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>微信</tag>
        <tag>js</tag>
        <tag>jssdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS交互微信之基础配置]]></title>
    <url>%2F2020%2F02%2F25%2FJS%E4%BA%A4%E4%BA%92%E5%BE%AE%E4%BF%A1%E4%B9%8B%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言最近公司需求，需要在APP中分享出去的web页面中加入商品购买功能，目前需要使用微信支付。由于微信支付基础为0，因此不得不扒文档抄作业，加上度娘的支持，得以完成了一些功能，因此开一小模块记录下关于此项目中前端用到的东西。不过不得不说，复杂的东西都在后端执行，需要前端完成的真的是少之又少，都是一些基础配置以及调取微信文档中写的接口而已，不要想得过于复杂。 篇章介绍目前可能会更新以下几块内容，每个模块仅与基础配置篇相关，其他的相互独立（如，获取用户地址模块不参与自定义分享模块内容，但都基于基础配置篇），每篇内容尽量简洁明了。 基础配置（本篇） 获取用户收货地址 自定义分享 微信支付（微信浏览器，JSAPI支付） 微信支付（非微信浏览器,H5支付） 应用场景介绍 在微信内打开网页时候，如果需要获取用户在微信填写的收获地址，可通过api直接调取。 ———— 微信地址共享 商户已有H5商城网站，用户通过消息、分享、链接或扫描二维码等方式在微信内打开网页时，可以调用微信支付完成下单购买的流程。 ———— JSAPI支付 用户在微信内某个页面想要分享给朋友或朋友圈时，需要对分享内容、标题及图片重新配置时使用。 ———— 自定义分享 H5支付是指商户在微信客户端外的移动端网页展示商品或服务，用户在前述页面确认使用微信支付时，商户发起本服务呼起微信客户端进行支付。 ———— H5支付 一、 基础配置(JSSDK)本块儿内容基本上是微信开放文档中配置，可忽略 概述微信JS-SDK是微信公众平台面向网页开发者提供的基于微信内的网页开发工具包。通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验。 使用步骤1. 绑定域名先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。备注：登录后可在“开发者中心”查看对应的接口权限 2. 引入JS在需要调用JS接口的页面引入如下JS文件，（支持https）：1&lt;script src="https://res.wx.qq.com/open/js/jweixin-1.6.0.js"&gt;&lt;/script&gt; 备注：支持使用 AMD/CMD 标准模块加载方法加载 3. 通过config接口注入权限验证配置所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用（同一个url仅需调用一次，对于变化url的SPA的web app可在每次url变化时进行调用,目前Android微信客户端不支持pushState的H5新特性，所以使用pushState来实现web app的页面会导致签名失败，此问题会在Android6.2中修复）。12345678wx.config(&#123; debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: '', // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: '', // 必填，生成签名的随机串 signature: '',// 必填，签名 jsApiList: [] // 必填，需要使用的JS接口列表&#125;); 4. 接口验证12345678// 成功wx.ready(function()&#123; // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。&#125;);// 失败wx.error(function(res)&#123; // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。&#125;); 二、 补充在上面几个步骤中，有几个注意点： 步骤3中的参数，后端提供； 步骤4中，通过ready验证成功的接口，有以下通用参数： success：接口调用成功时执行的回调函数。 fail：接口调用失败时执行的回调函数。 complete：接口调用完成时执行的回调函数，无论成功或失败都会执行。 cancel：用户点击取消时的回调函数，仅部分有用户取消操作的api才会用到。 trigger: 监听Menu中的按钮点击时触发的方法，该方法仅支持Menu中的相关接口。 备注：不要尝试在trigger中使用ajax异步请求修改本次分享的内容，因为客户端分享操作是一个同步操作，这时候使用ajax的回包会还没有返回。 在使用每个JS接口前，可以使用checkJsApi的方法判断是否支持该接口： 1234567wx.checkJsApi(&#123; jsApiList: ['onMenuShareTimeline'], // 需要检测的JS接口列表，此处为分享到朋友圈接口示例 success: function(res) &#123; // 以键值对的形式返回，可用的api值true，不可用为false // 如：&#123;"checkResult":&#123;"onMenuShareTimeline":true&#125;,"errMsg":"checkJsApi:ok"&#125; &#125;&#125;); 所有接口列表 接口名 用途 updateAppMessageShareData 分享给朋友 updateTimelineShareData 分享到朋友圈 onMenuShareTimeline（即将废弃） 分享到朋友圈 onMenuShareAppMessage（即将废弃） 分享给朋友 onMenuShareQQ（即将废弃） 分享到QQ onMenuShareWeibo 分享到微博 onMenuShareQZone 分享到空间 startRecord 开始录音 stopRecord 停止录音 onVoiceRecordEnd 录音超时 playVoice 播放 pauseVoice 暂停 stopVoice 停止 onVoicePlayEnd 播放结束时执行 uploadVoice 上传录音 downloadVoice 下载录音 chooseImage 选择本地照片 previewImage 预览 uploadImage 上传 downloadImage 下载 translateVoice 翻译 getNetworkType 网络状况 openLocation 打开内置地图 getLocation 获取用户位置 hideOptionMenu 隐藏菜单 showOptionMenu 显示菜单 hideMenuItems 隐藏菜单按钮 hideAllNonBaseMenuItem 屏蔽所有按钮 showAllNonBaseMenuItem 显示所有按钮 closeWindow 关闭页面 scanQRCode 扫描二维码 chooseWXPay 微信支付 openProductSpecificView 微信卡券 addCard 添加卡券到卡包 chooseCard 拉取卡券 openCard 添加卡券]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>微信</tag>
        <tag>js</tag>
        <tag>jssdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue使用canvas签名之清空和保存]]></title>
    <url>%2F2020%2F02%2F03%2Fvue%E4%BD%BF%E7%94%A8canvas%E7%AD%BE%E5%90%8D%E4%B9%8B%E6%B8%85%E7%A9%BA%E5%92%8C%E4%BF%9D%E5%AD%98%2F</url>
    <content type="text"><![CDATA[效果 需求&emsp;&emsp;在一些项目业务中，经常会使用到画板，让用户自己去写/画一些东西做标示，比如说在线签电子合约、签名等，在上两篇博客中，已经解决了PC端和移动端的Canvas签名，那么在签名完成之后，我们如何将画布上东西保存，或者清空呢？ 【本篇包含PC和移动端的签名，以及清空和保存】 分析&emsp;&emsp;在前两篇中，分辨实现了PC端canvas签名以及移动端canvas签名，要是形成一个简单且完整的功能点，我们起码还缺少清空和保存两个环节。接下来分析一下。 1. 清空&emsp;&emsp;就是将此前所画的所有笔画清除掉，方法则是清空存放点集合的数组重新设置画布宽高即可。另外一个方法，也可以使用clearRect()，这个方法是清空画布中一个矩形区域内的内容。由于我们并为保存所有点集合，所以采用此方法清空。 1.1 关于clearRect12// clearRect() 方法清空给定矩形内的指定像素。context.clearRect(x,y,width,height); 参数 描述 举例(全部清空) x 要清除的矩形左上角的 x 坐标 0 y 要清除的矩形左上角的 y 坐标 0 width 要清除的矩形的宽度，以像素计 context.width height 要清除的矩形的高度，以像素计 context.height 1.2 代码示例123&lt;el-button type="danger" @click="cleanCanvas"&gt; 清空&lt;/el-button&gt; 1234567891011121314151617mounted () &#123; let board = this.$refs.board; // 获取DOM this.width = board.width = this.$refs.boardBox.offsetWidth; // 设置画布宽 this.height = board.height = this.$refs.boardBox.offsetHeight; // 设置画布高 ... // something codes&#125;// 清空画布cleanCanvas () &#123; // clearRect() 方法清空给定矩形内的指定像素。 this.ctx.clearRect( 0, 0, this.width, this.height )&#125;, 2. 保存保存，需求简单明了，就是将canvas输出为一张图片。处理也简单粗暴，直接将此区域输出为一张base64的图片即可。方法是使用原生方法toDataURL() 2.1 关于toDataURLHTMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。 如果画布的高度或宽度是0，那么会返回字符串“data:,”。 如果传入的类型非“image/png”，但是返回的值以“data:image/png”开头，那么该传入的类型是不支持的。 Chrome支持“image/webp”类型。 方法canvas.toDataURL(type, encoderOptions);参数 type 可选图片格式，默认为 image/png encoderOptions 可选图片质量。取值范围为 0 到 1 。如果指定图片格式为 image/jpeg 或 image/webp。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。 返回值包含 data URI 的DOMString。 2.2 代码示例1234567&lt;el-button type="success" @click="saveCanvas"&gt; 保存&lt;/el-button&gt;&lt;div&gt; &lt;img :src="base64" alt=""&gt;&lt;/div&gt; 12345678910data() &#123; return &#123; base64: '', &#125;&#125;// 保存签名saveCanvas () &#123; this.base64 = this.$refs.board.toDataURL(); // 转为base64&#125; 结语关于canvas签名的基本到这里就结束了，项目如果有遇到更复杂的再继续更新。目前更新的有 PC端签名方法 移动端签名方法 PC和移动端签名方法以及清空和保存 想了解本期源码的可以关注下公众号流眸回复canvas或者签名获取哦～]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue使用canvas签名之移动端]]></title>
    <url>%2F2020%2F01%2F14%2Fvue%E4%BD%BF%E7%94%A8canvas%E7%AD%BE%E5%90%8D%E4%B9%8B%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[效果 需求&emsp;&emsp;在一些项目业务中，经常会使用到画板，让用户自己去写/画一些东西做标示，比如说在线签电子合约、签名等，如果不用插件，那么如何使用h5的canvas画布来实现这一需求呢？ 【本篇只讨论移动端，PC端请看上篇】 分析&emsp;&emsp;很明显，我们需要一个canvas，关于canvas的一些基本操作可以在w3school或者别的一些平台上熟悉一下，其实本例也是基础操作。本案例在vue中完成。（脱离vue也一样。） 首先，需要一个canvas画布 其次，考虑逻辑 把逻辑实现 1. canvas画布随意布局的一个画布，此处值得注意的是如果canvas的宽高确定，则在html&gt;canvas中直接写宽高，如果不确定，根据别的元素变化，那么可以在js中初始化画布时写。 html12345&lt;div class="boardBox" ref="boardBox"&gt; &lt;canvas ref="board" &lt;/canvas&gt;&lt;/div&gt; 布局123456789.boardBox&#123; margin: 30px auto; width: 90vw; height: 25vh; background: #f9f9f9; canvas&#123; border: 1px solid #b3b3b3; &#125;&#125; 画布初始化123456let board = this.$refs.board; // 获取DOMboard.width = this.$refs.boardBox.offsetWidth; // 设置画布宽board.height = this.$refs.boardBox.offsetHeight; // 设置画布高this.ctx = board.getContext('2d'); // 二维绘图this.ctx.strokeStyle = '#000'; // 颜色this.ctx.lineWidth = 3; // 线条宽度 2. 逻辑分析由于本篇只讨论移动端端，因此无非是在画布上监听三个触摸事件：touchstart、touchmove、touchend。那么，在这三个事件中，分别需要做什么呢？ touchstart开始滑动按下，需要做： 获取触摸点做画布上的位置 存为一个点坐标（起始点） 以起始点建立一个路径 开启画布操作 touchmove触摸滑动时，又要做那些准备呢？ 判断是否开启画布操作，如果没开启就禁止绘制，因此先判断是否当前状态可绘制 获取触摸点做画布上的位置 上一个点到这一个点作连线 绘制出来 当前点存储，下一次用 touchend滑动结束，事件结束： closePath（） // 停止绘制 关闭画布操作的开关 好了，其实就是这三个事件，理清楚之后去代码实现就简单得多了。附上代码一份。 3. 代码CSS略，如初始化即可，不是重点。1234567&lt;div class="boardBox" ref="boardBox"&gt; &lt;canvas ref="board" @touchstart="mStart" @touchmove="mMove" @touchend="mEnd"&gt; &lt;/canvas&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748data() &#123; return &#123; ctx: null, point: &#123; x: 0, y: 0 &#125;, moving: false // 是否正在绘制中且移动 &#125;;&#125;,mounted() &#123; let board = this.$refs.board; // 获取DOM board.width = this.$refs.boardBox.offsetWidth; // 设置画布宽 board.height = this.$refs.boardBox.offsetHeight; // 设置画布高 this.ctx = board.getContext('2d'); // 二维绘图 this.ctx.strokeStyle = '#000'; // 颜色 this.ctx.lineWidth = 3; // 线条宽度&#125;,methods: &#123; // 触摸(开始) mStart (e) &#123; console.log(e); let x = e.touches[0].clientX - e.target.offsetLeft, y = e.touches[0].clientY - e.target.offsetTop; // 获取触摸点在画板（canvas）的坐标 this.point.x = x; this.point.y = y; this.ctx.beginPath(); this.moving = true; &#125;, // 滑动中... mMove (e) &#123; if(this.moving) &#123; let x = e.touches[0].clientX - e.target.offsetLeft, y = e.touches[0].clientY - e.target.offsetTop; // 获取触摸点在画板（canvas）的坐标 this.ctx.moveTo(this.point.x, this.point.y); // 把路径移动到画布中的指定点，不创建线条(起始点) this.ctx.lineTo(x, y); // 添加一个新点，然后创建从该点到画布中最后指定点的线条，不创建线条 this.ctx.stroke(); // 绘制 this.point.x = x, this.point.y = y; // 重置点坐标为上一个坐标 &#125; &#125;, // 滑动结束 mEnd () &#123; if(this.moving) &#123; this.ctx.closePath(); // 停止绘制 this.moving = false; // 关闭绘制开关 &#125; &#125;,&#125;, 思考 上一篇，在PC端完成绘制，本篇如法炮制，在移动端也顺利完成，相比pc端只是稍微的修改了一下获取坐标点的算法而已。那么PC端和移动端如何并存呢？ 出错了，怎么重新绘制呢？ 绘制完成后，怎么保存呢？]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue使用canvas签名之PC端]]></title>
    <url>%2F2020%2F01%2F10%2Fvue%E4%BD%BF%E7%94%A8canvas%E7%AD%BE%E5%90%8D%E4%B9%8BPC%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[效果 需求&emsp;&emsp;在一些项目业务中，经常会使用到画板，让用户自己去写/画一些东西做标示，比如说在线签电子合约、签名等，如果不用插件，那么如何使用h5的canvas画布来实现这一需求呢？ 【本篇只讨论PC端，移动端期待下篇】 分析&emsp;&emsp;很明显，我们需要一个canvas，关于canvas的一些基本操作可以在w3school或者别的一些平台上熟悉一下，其实本例也是基础操作。本案例在vue中完成。（脱离vue也一样。） 首先，需要一个canvas画布 其次，考虑逻辑 把逻辑实现 1. canvas画布随意布局的一个画布，此处值得注意的是如果canvas的宽高确定，则在html&gt;canvas中直接写宽高，如果不确定，根据别的元素变化，那么可以在js中初始化画布时写。 html12345&lt;div class="boardBox" ref="boardBox"&gt; &lt;canvas ref="board" &lt;/canvas&gt;&lt;/div&gt; 布局123456789.boardBox&#123; margin: 100px auto 20px; width: 80vw; height: 35vh; background: #eee; canvas&#123; border: 1px solid #298cff; &#125;&#125; 画布初始化123456let board = this.$refs.board; // 获取DOMboard.width = this.$refs.boardBox.offsetWidth; // 设置画布宽board.height = this.$refs.boardBox.offsetHeight; // 设置画布高this.ctx = board.getContext('2d'); // 二维绘图this.ctx.strokeStyle = '#ff0000'; // 颜色this.ctx.lineWidth = 5; // 线条宽度 2. 逻辑分析由于本篇只讨论PC端，因此无非是在画布上监听三个鼠标事件：mousedown、mousemove、mouseup。那么，在这三个事件中，分别需要做什么呢？ mousedown鼠标按下，需要做： 获取鼠标做画布上的位置 存为一个点坐标（起始点） 以起始点建立一个路径 开启画布操作 mousemove鼠标移动时，又要做那些准备呢？ 判断是否开启画布操作，如果没开启我们当然不能鼠标在画布上移动就给绘制吧，因此先判断是否当前状态可绘制 获取鼠标做画布上的位置 上一个点到这一个点作连线 绘制出来 当前点存储，下一次用 可能此处有些迷，大概意思就是，鼠标不停的运动，在某一时刻鼠标的位置A（x,y），在下一时刻A则会变成上一个位置，我们的思路无非是不断的绘制出鼠标上一个时刻到当前时刻的路径而已。一会儿上代码可能就好理解一点。 mouseup鼠标抬起，事件结束： closePath（） // 停止绘制 关闭画布操作的开关 好了，其实就是这三个事件，理清楚之后去代码实现就简单得多了。附上代码一份。 3. 代码CSS略，如初始化即可，不是重点。1234567&lt;div class="boardBox" ref="boardBox"&gt; &lt;canvas ref="board" @mousedown="pcStart" @mousemove="pcMove" @mouseup="pcEnd"&gt; &lt;/canvas&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445data() &#123; return &#123; ctx: null, point: &#123; x: 0, y: 0 &#125;, moving: false // 是否正在绘制中且移动 &#125;;&#125;,mounted() &#123; let board = this.$refs.board; // 获取DOM board.width = this.$refs.boardBox.offsetWidth; // 设置画布宽 board.height = this.$refs.boardBox.offsetHeight; // 设置画布高 this.ctx = board.getContext('2d'); // 二维绘图 this.ctx.strokeStyle = '#ff0000'; // 颜色 this.ctx.lineWidth = 5; // 线条宽度&#125;,methods: &#123; // 鼠标按下(开始) pcStart (e) &#123; let x = e.offsetX, y = e.offsetY; // 获取鼠标在画板（canvas）的坐标 this.point.x = x; this.point.y = y; this.ctx.beginPath(); this.moving = true; &#125;, // 鼠标移动（移动中...） pcMove (e) &#123; if(this.moving) &#123; let x = e.offsetX, y = e.offsetY; // 获取鼠标在画板（canvas）的坐标 this.ctx.moveTo(this.point.x, this.point.y); // 把路径移动到画布中的指定点，不创建线条(起始点) this.ctx.lineTo(x, y); // 添加一个新点，然后创建从该点到画布中最后指定点的线条，不创建线条 this.ctx.stroke(); // 绘制 this.point.x = x, this.point.y = y; // 重置点坐标为上一个坐标 &#125; &#125;, // 鼠标松开（结束） pcEnd () &#123; if(this.moving) &#123; this.ctx.closePath(); // 停止绘制 this.moving = false; // 关闭绘制开关 &#125; &#125;,&#125;, 思考&emsp;&emsp;PC端出来了，而现在其实还是移动端偏多，并且这只是一个问题，是否还有延伸呢？ 移动端是否可以如法炮制呢？ 出错了，怎么重新绘制呢？ 绘制完成后，怎么保存呢？]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决vue打包报错UglifyJs]]></title>
    <url>%2F2019%2F12%2F06%2F%E8%A7%A3%E5%86%B3vue%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99UglifyJs%2F</url>
    <content type="text"><![CDATA[报错12ERROR in js/xxxxxx.js from UglifyJsUnexpected token: name «Dom7», expected: punc «;» [js/chunk-3068 产生在vue配置中，由于各插件版本兼容性差异可能会引发此问题的产生。UglifyJs是一款可以解析、混淆、压缩JS的工具，此处的UglifyJs是配置在脚手架/webpack中，运行在node环境中的小插件。关于UglifyJs： uglify-js@3具有简化的API和CLI，该API和CLI与不能向后兼容uglify-js@2。 UglifyJS 2.x版本的文档可以在这里找到。 glify-js 仅支持JavaScript（ECMAScript 5）。 要缩小ECMAScript 2015或更高版本，请使用Babel之类的工具进行翻译。 解决低版本： 原因： UglifyJs不支持ES6语法，因此报错。 解决方案： 项目根目录下创建文件.babelrc，配置如下123&#123; "pressets": ["es2015"]&#125; 高版本： 原因1：UglifyJs版本过低 解决方案： 升级UglifyJs版本 1npm install uglify-js -g 原因2: babel 转译问题 解决方案： 找到babel的配置项transpileDependencies，如下操作：123456789101112// 旧transpileDependencies: [/* string or regex */],// 改为如下⬇️ // 新 transpileDependencies: [ 'vue-particles', 'animejs'], 重新打包npm run build，完毕。 附vue-cli@3.x vue.config.js配置混淆压缩代js及去除console(缺少的插件先安装上)123456789101112131415161718192021222324252627282930313233343536373839404142// 去除consoleconst UglifyJsPlugin = require('uglifyjs-webpack-plugin');// 压缩css、jsconst CompressionWebpackPlugin = require('compression-webpack-plugin');// 要压缩的文件const productionGzipExtensions = ['js', 'css'];module.exports = &#123; // something else codes configureWebpack: (config) =&gt; &#123; // 如果不是开发环境 if (env !== 'development') &#123; // 代码压缩 config.plugins.push(new CompressionWebpackPlugin(&#123; algorithm: 'gzip', test: new RegExp(`\\.($&#123;productionGzipExtensions.join('|')&#125;)$`), threshold: 10240, minRatio: 0.8, &#125;)); // 打包后清除断点和控制台打印 config.plugins.push( new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; drop_debugger: true, // 注释debugger drop_console: true, // 注释console pure_funcs:['console.log'] // 移除console &#125;, &#125;, sourceMap: false, // 去除打包后生成的.map文件 parallel: true, &#125;), ); &#125; &#125;,&#125; 希望能够解决您的问题。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>uglify报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中高德搭配echarts做迁徙流线图]]></title>
    <url>%2F2019%2F12%2F03%2Fvue%E4%B8%AD%E9%AB%98%E5%BE%B7%E6%90%AD%E9%85%8Decharts%E5%81%9A%E8%BF%81%E5%BE%99%E6%B5%81%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言此系列共分为以下几篇 《vue中高德地图的使用》 《vue中基于高德的多行政区域覆盖》 《vue中高德搭配echarts做数据迁徙流线图》 （本篇） 本篇效果 实现步骤1. 思路分析第一篇的基础讲解，加上上一片的行政区域行政区域展示（描边及背景），其实可以完成很多炫酷效果了。本篇讲述系列篇的最后一篇：vue中高德搭配echarts做数据迁徙流线图。由于流线图使用的曲线是贝塞尔曲线，而在高德中无法直接简单粗暴的使用，想要完成此效果的话可能要进行一些算法操作才能完成该效果。在节约时间成本的条件下，找到了在echarts中完成该操作。简单的说，就是用echarts的功能，搭配高德的经纬度当背景板，来完成此操作。 步骤分析 echarts安装 引入 高德背景板设置（经纬度、中心点等） 挂载数据 2. 代码分析echarts安装 引入 安装：npm install echarts --save-dev 引入： main.js =&gt; 1234// 全局挂载echartsimport echarts from 'echarts'Vue.prototype.$echarts = echarts; 高德背景板设置在此中，可以自定义的调整一些关于地图背景板的配置，如样式、3D效果、旋转、动画等，在demo中有所注释，自己根据需要配置即可。123456789101112131415// 加载 amap 组件amap: &#123; // 高德地图中心经纬度 center: [105.397428, 38.90923], //中心点 // 高德地图缩放 zoom: 4, // 启用resize resizeEnable: true, // 自定义地图样式主题 mapStyle: "amap://xxxxxx", // 地图主题 自己申请即可 我的是极夜蓝主题 // viewMode:'3D',//开启3D视图,默认为关闭 // expandZoomRange:true, // zooms:[3,20], // pitch: 40&#125;, 数据此处写了两组数据，一组为flyLine代表流线数组，另一组为goals代表目标点。其中流线数据中坐标点有两个，是起始和终点的经纬度坐标。如下所示：1234567891011121314151617181920212223242526272829data() &#123; return &#123; flyLine: [ &#123;coords: [[116.496437,39.913523], [123.499706,41.857793]]&#125;, &#123;coords: [[116.496437,39.913523], [86.113232,43.684254]]&#125;, &#123;coords: [[116.496437,39.913523], [87.343701,35.720308]]&#125;, &#123;coords: [[116.496437,39.913523], [101.406201,24.177443]]&#125;, &#123;coords: [[116.496437,39.913523], [111.249951,24.976714]]&#125;, &#123;coords: [[116.496437,39.913523], [107.206982,33.843608]]&#125;, &#123;coords: [[116.496437,39.913523], [115.468701,43.557002]]&#125;, &#123;coords: [[116.496437,39.913523], [107.031201,37.134586]]&#125;, &#123;coords: [[116.496437,39.913523], [99.648388,38.522914]]&#125;, &#123;coords: [[116.496437,39.913523], [124.081982,49.361353]]&#125;, ], goals: [ [123.499706,41.857793], [86.113232,43.684254], [87.343701,35.720308], [101.406201,24.177443], [111.249951,24.976714], [107.206982,33.843608], [115.468701,43.557002], [107.031201,37.134586], [107.031201,37.134586], [99.648388,38.522914], [124.081982,49.361353] ] &#125;&#125;, 数据渲染最后一步，其实是echarts的常规操作，可以配置流线、提示、流线背景、特效、效果、等等等等，依然是配置自己需要的即可，毕竟是搭配来的地图，特效多了会影响性能～如下：123&lt;div class="map" ref="map"&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980mapInit () &#123; let _this = this; let option = &#123; // 加载 amap 组件 amap: &#123; // 高德地图中心经纬度 center: [105.397428, 38.90923], //中心点 // 高德地图缩放 zoom: 4, // 启用resize resizeEnable: true, // 自定义地图样式主题 mapStyle: "amap://styles/bfb1bb3feb0db7082367abca96b8d214", //地图主题 // viewMode:'3D',//开启3D视图,默认为关闭 // expandZoomRange:true, // zooms:[3,20], // pitch: 40 &#125;, tooltip: &#123; trigger: 'item', show: false &#125;, animation: false, series: [ // 流线 &#123; coordinateSystem: "amap", // 该系列使用的坐标系是高德地图的坐标系 type: "lines", // 该类型用于地图上路线的绘制 zlevel: 1, // 相当于z-index effect: &#123; // 线特效的配置 show: true, // 是否显示特效 period: 5, // 特效动画的时间 trailLength: 0.05, // 特效尾迹的长度 0-1 color: "#3437ff", // 特效的颜色 symbolSize: 5 // 特效的大小 &#125;, lineStyle: &#123; // 线的颜色 normal: &#123; color: "rgba(47,68,200,0.1)", width: 2, curveness: 0.2 &#125; &#125;, data: _this.flyLine, &#125;, // 目标点 &#123; name: '目标点', type: "scatter", // 使用高德地图坐标系 coordinateSystem: "amap", // 数据格式跟在 geo 坐标系上一样，每一项都是 [经度，纬度，数值大小，其它维度...] data: _this.goals, symbolSize: 3, encode: &#123; value: 2 &#125;, label: &#123; normal: &#123; formatter: '&#123;b&#125;', position: 'right', show: false &#125;, emphasis: &#123; show: true &#125; &#125;, itemStyle: &#123; normal: &#123; color: 'rgba(98,122,200,0.78)' &#125; &#125; &#125;, ], &#125;; let chart = this.$echarts.init(_this.$refs.map); chart.setOption(option);&#125;, 至此，目的完成：]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>高德</tag>
        <tag>echarts</tag>
        <tag>流线</tag>
        <tag>地图</tag>
        <tag>迁徙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中基于高德的多行政区域覆盖]]></title>
    <url>%2F2019%2F11%2F12%2Fvue%E4%B8%AD%E5%9F%BA%E4%BA%8E%E9%AB%98%E5%BE%B7%E7%9A%84%E5%A4%9A%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%9F%9F%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[前言此系列共分为以下几篇 《vue中高德地图的使用》 《vue中基于高德的多行政区域覆盖》 （本篇） 《vue中高德搭配echarts做数据迁徙流线图》 本篇效果 实现步骤1. 思路分析基于上一篇的基础讲解，再来看本篇目的，行政区域展示（秒变及背景），其实就是基于在经纬度坐标系上将某个/些行政区域规划出来。如果仔细看官方文档的前端er，则更是发现在文档中提供灵了一个行政区域上色的工具方法。因此基础思路如下： 加载基础坐标系； 给定具体行政区域上色； 多行政区域循环； 2. 代码分析==详细代码在文章底部== 初始化地图1// 略 见文章底部详细代码 行政区域蒙层加载12345678910111213141516171819202122232425262728293031323334353637areaBG (cityName) &#123; // 加载行政区划插件 AMap.service('AMap.DistrictSearch', function() &#123; let opts = &#123; subdistrict: 1, // 返回下一级行政区 extensions: 'all', // 返回行政区边界坐标组等具体信息 level: 'city' // 查询行政级别为市 &#125;; // 实例化DistrictSearch let district = new AMap.DistrictSearch(opts); district.setLevel('district'); // 行政区查询 district.search(`$&#123;cityName&#125;`, function(status, result)&#123; // 获取边界信息 let bounds = result.districtList[0].boundaries; // 存放行政区划 let polygons = []; if (bounds) &#123; for (let i = 0, l = bounds.length; i &lt; l; i++) &#123; //生成行政区划polygon let polygon = new AMap.Polygon(&#123; map: new AMap.Map("map", &#123; center: [105.397428, 35.90923], zoom: 5 &#125;);, // 坐标系及主题 strokeWeight: 1, path: bounds[i], fillOpacity: 0.2, fillColor: 'rgba(71,228,194,0.44)', strokeColor: 'rgba(83,204,79,0.65)' &#125;); polygons.push(polygon); &#125; &#125; &#125;); &#125;);&#125; 方法调用1this.areaBG('辽宁省'); 得到如下地图示例：(此处添加了个人的’mapStyle’) 那么，如果是多个行政区域，如何循环遍历呢？ 多区域加载机智的各位已经发现了,我们前面其实已经把城市名字提出来了，那么直接遍历即可。12345// 行政区域加载let cities = ['北京市','郑州市','西安市','呼和浩特','辽宁省'];for(let i = 0; i &lt; _cities.length; i ++)&#123; this.areaBG(map, cities[i]);&#125; 至此，目的完成： 附：代码1&lt;div class="map" id="map"&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849methods: &#123; // 加载行政区域 areaBG (map, cityName) &#123; AMap.service('AMap.DistrictSearch', function () &#123; let opts = &#123; subdistrict: 1, // 返回下一级行政区 extensions: 'all', // 返回行政区边界坐标组等具体信息 level: 'city' // 查询行政级别为市 &#125;; // 实例化DistrictSearch let district = new AMap.DistrictSearch(opts); district.setLevel('district'); // 行政区查询 district.search(`$&#123;cityName&#125;`, function (status, result) &#123; // 获取边界信息 let bounds = result.districtList[0].boundaries; let polygons = []; if (bounds) &#123; for (let i = 0, l = bounds.length; i &lt; l; i++) &#123; // 生成行政区划polygon let polygon = new AMap.Polygon(&#123; map: map, strokeWeight: 1, path: bounds[i], fillOpacity: 0.2, fillColor: 'rgba(71,228,194,0.44)', strokeColor: 'rgba(83,204,79,0.65)' &#125;); polygons.push(polygon); &#125; &#125; &#125;); &#125;); &#125;, // 初始化地图，并加载行政区域 mapInit () &#123; let map = new AMap.Map("partnerMap", &#123; center: [105.397428, 35.90923], mapStyle: "amap://styles/bfb1bb3feb0db7082367abca96b8d214", // 设置地图的显示样式 zoom: 5 &#125;); // 行政区域加载 let cities = ['北京市','郑州市','西安市','呼和浩特','辽宁省']; for(let i = 0; i &lt; _cities.length; i ++)&#123; this.areaBG(map, cities[i]); &#125; &#125;&#125; 123mounted () &#123; this.mapInit();&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>高德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用高德地图开发]]></title>
    <url>%2F2019%2F11%2F02%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[概述&emsp;&emsp;最近两年比较热门的一个名次叫“数据可视化”，在前端方向大致体现为地图数据展示以及图表类数据展示。那么，如何在vue中使用基于高德地图来做地图数据可视化以及加上e Charts的图表类型数据可视化呢？接下来会分三篇文章来进行概述，最终实现下图内容： 共分为以下几篇 《vue中高德地图的使用》 （本篇） 《vue中基于高德的多行政区域覆盖》 《vue中高德搭配echarts做数据迁徙流线图》 接下来，开始第一篇，实现效果如下： vue中高德地图的使用1. 准备工作 vue搭建 高德开发key值申请（链接：高德开放平台），key值请放入以下需要对号入座的地方 地图样式挑选，需要申请到key值后，在高德开放平台自动移地图模板处挑选配置。此处用极夜蓝模板来示例，也可选择其他模板。然后发布=&gt;复制与分享=&gt;辅助出来样式ID。如：bb7f5165253f57515d7ba226b2******，然后放入以下需要对号入座的地方 注：第二步和第三步申请的两个值需要对应使用 2. 地图引入项目入口文件index.html引入标签:12&lt;script src="https://webapi.amap.com/maps?v=1.4.15&amp;key=这里放入key值"&gt;&lt;/script&gt;&lt;script src="//webapi.amap.com/ui/1.0/main.js?v=1.0.11"&gt;&lt;/script&gt; vue.config.js中配置:1234567891011module.exports = &#123; // ... configureWebpack(config) &#123; // ... config.externals = &#123; 'AMap': 'AMap' // 高德地图配置 &#125; &#125;&#125; 使用该功能的组件中引入：1import AMap from "AMap" 3. 使用地图初始化即可：1&lt;div class="map" id="map"&gt; 123456789101112// 引入地图组件import AMap from "AMap"// 初始化MapInit () &#123; let _this = this; let map = new AMap.Map("map", &#123; center: [105.397428, 35.90923], mapStyle: "amap://styles/这里放入样式ID", //设置地图的显示样式 resizeEnable: true, zoom: 5 &#125;);&#125; 得到初始化的地图： 4. 展示点其实展示点在地图中叫做地理编码，意思是将某个点的经纬度在地图中展现出来。与之类似的，高德也提供逆地理编码服务，此处不在我们示例范围内，有兴趣的可以自行在官方API中查看。接下来展示数据点：123456789// data中,location是地理编码，color 1绿2黄3红dataList: [ &#123; location: "113.772,22.785", color: 1 &#125;, &#123; location: "114.772,22.785", color: 3 &#125;, &#123; location: "116.410778,39.897614", color: 2 &#125;, &#123; location: "123.499706,41.857793", color: 2 &#125;, &#123; location: "111.722363,40.868346", color: 1 &#125;, &#123; location: "103.987988,30.662124", color: 3 &#125;] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 初始化let _this = this;let map = new AMap.Map("adMap", &#123; center: [105.397428, 35.90923], mapStyle: "amap://styles/bb7f5165253f57515d7ba226b25ad7ec", //设置地图的显示样式 resizeEnable: true, zoom: 5&#125;);// 根据color状态展示不同的图片const style = [ &#123; // 1 url: "此处放一张图的url", anchor: new AMap.Pixel(5, 5), // 位移 size: new AMap.Size(10, 10) // 图片大小 &#125;, &#123; // 2 url: "此处放另外一张图的url", anchor: new AMap.Pixel(5, 5), size: new AMap.Size(10, 10) &#125;, &#123; // 3 url: "此处再放一张图的url", anchor: new AMap.Pixel(5, 5), size: new AMap.Size(10, 10) &#125;];let locationData = []; //存放经纬度的数组let status = null;for (let i = 0; i &lt; _this.dataList.length; i++) &#123;let locationArr = _this.dataList[i].location.split(",");// 判断需要展示的颜色类型if (_this.dataList[i].dataList === 1) &#123; status = 0; //根据下标来相对应样式 例如：绿色对应style数组中的第0个样式&#125; else if (_this.dataList[i].color === 2) &#123; status = 1;&#125; else if (_this.dataList[i].color === 3) &#123; status = 2;&#125;locationData.push(&#123; lnglat: locationArr, style: status // 对应的status相对应的样式 style&#125;);&#125;// 点放置let mass = new AMap.MassMarks(locationData, &#123; opacity: 0.8, zIndex: 111, cursor: "pointer", style: style&#125;);let marker = new AMap.Marker(&#123; content: " ", map: map &#125;); mass.on("mouseover", function(e) &#123; marker.setPosition(e.data.lnglat); //用户相对应的经纬度 marker.setLabel(&#123; content: e.data.name &#125;); //用户相对应的名字&#125;);mass.setMap(map); 5. 完成，启动npm run serve启动，查看该示例，得到应有效果：]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>高德地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lib-flexible适配大屏方案（附移动端适配）]]></title>
    <url>%2F2019%2F10%2F24%2Flib-flexible%E9%80%82%E9%85%8D%E5%A4%A7%E5%B1%8F%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;相信大多数移动端前端开发者都是用过lib-flexible来作为移动端适配的解决方案。lib-flexible是淘宝项目组开发出来的一个小插件，属于开源项目，可以在各类项目中引入并使用，为移动端的开发者带来了无穷的便利。&emsp;&emsp;但是，有人提出为什么在屏幕尺寸超出一定分辨率后便不再适配？ 今天针对该问题来尝试给出解决方案。 关于lib-flexible1. 解读&emsp;&emsp;lib-flexible会自动在html的head中添加一个meta name=&quot;viewport&quot;的标签，同时会自动设置html的font-size为屏幕宽度除以10，也就是1rem等于html根节点的font-size。假如设计稿的宽度是750px，此时1rem应该等于75px。假如量的某个元素的宽度是150px，那么在css里面定义这个元素的宽度就是 width: 2rem。但是当分辨率大于某个特定值时，它便不再生效。 2. 移动端适配步骤&emsp;&emsp;一般而言，lib-flexible并不独立出现，而是搭配px2rem-loader一起做适配方案，目的是自动将css中的px转换成rem。以下为它在vue中的使用。 2.1 安装 lib-flexible1npm install lib-flexible --save-dev 2.2 引入 lib-flexible在main.js中引入lib-flexible12// px2rem 自适应import 'lib-flexible' 2.3 安装 px2rem-loader1npm install px2rem-loader --save-dev 2.4 配置 px2rem-loader分两种情况： vue-cli 2.x vue-cli 3.x 2.4.1 第1种如果是2.x版本。 在build/utils.js中，找到exports.cssLoaders，作出如下修改： 123456const px2remLoader = &#123; loader: 'px2rem-loader', options: &#123; remUint: 75 // 以设计稿750为例， 750 / 10 = 75 &#125;&#125; 继续找到generateLoaders中的loaders配置，作出如下配置： 12345678// 注释掉这一行// const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]// 修改为const loaders = [cssLoader, px2remLoader] if (options.usePostCSS) &#123; loaders.push(postcssLoader)&#125; 重新npm run dev，完成。 2.4.2 第2种如果是3.x版本。由于3.x版本需要自己配置，在项目根目录新建文件vue.config.js，然后如下配置： 123456789101112131415module.exports = &#123; css: &#123; loaderOptions: &#123; css: &#123;&#125;, postcss: &#123; plugins: [ require('postcss-px2rem')(&#123; // 以设计稿750为例， 750 / 10 = 75 remUnit: 75 &#125;), ] &#125; &#125; &#125;,&#125;; 然后，重新npm run dev，完成。 3. 大屏怎么办？&emsp;&emsp;正常情况下，如果是教程，那么到此就结束了。可本文中心是如何在大屏中正常使用lib-flexible。&emsp;&emsp;例如我们屏幕尺寸要做以3840 x 2160为设计稿的适配，那么我们的remUnit的值则改为384。然后呢？重启项目，发现……咦？布局全部乱掉！经过排查，自己的代码基本上不会导致该问题的出现，那么只能是源码在作怪了。重点来了。 3.1 找到源码打开./node_modules/lib-flexible/flexible.js，找到如下片段源码：123456789function refreshRem()&#123; var width = docEl.getBoundingClientRect().width; if (width / dpr &gt; 540) &#123; width = 540 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem;&#125; &emsp;&emsp;从此段源码中我们不难看出，当屏幕宽度除以dpr（dpr是一个倍数，此处一般为1）大于540这个特定值的时候，那么就不再进行适配了。那么我们如何解决这个问题呢？ 3.2 修改源码&emsp;&emsp;在上述源码中，进行修改。例如我要适配的大屏幕尺寸是基于3840的设计稿，而要求最小范围是1980，最大为5760，那么我们要修改的则变为：1234567891011function refreshRem()&#123; var width = docEl.getBoundingClientRect().width; if (width / dpr &lt; 1980) &#123; width = 1980 * dpr; &#125; else if (width / dpr &gt; 5760) &#123; width = 5760 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem;&#125; 3.3 重启，完成&emsp;&emsp;修改完成后，重启项目，则会适配到相应的尺寸。此外还有一个提示，当脱离掉node_modules重新npm install项目依赖时还是需要重新修改一遍的，千万别忘了！ 以上。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《中国机长》随笔]]></title>
    <url>%2F2019%2F10%2F23%2F%E3%80%8A%E4%B8%AD%E5%9B%BD%E6%9C%BA%E9%95%BF%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[电影概述 &emsp;&emsp;《中国机长》（The Captain）是由刘伟强执导，于勇敢编剧，李锦文监制，张涵予、欧豪、杜江、袁泉、张天爱、李沁领衔主演，张雅玫、杨祺如、高戈主演的剧情传记灾难片。&emsp;&emsp;该片根据2018年5月14日四川航空3U8633航班机组成功处置特情真实事件改编，讲述了“中国民航英雄机组”成员与119名乘客遭遇极端险情，在万米高空直面强风、低温、座舱释压的多重考验。 剧情简介 &emsp;&emsp;四川航空3U8633航班机组执行航班任务时，在万米高空突遇驾驶舱风挡玻璃爆裂脱落、座舱释压的极端罕见险情。机组成员凭借着极少仍在工作状态的仪器，艰难地进行手动驾驶。座舱释压发生时，乘务组立即执行释压处置程序，指导旅客使用氧气面罩，并训练有素地喊出：“请大家相信我们，相信我们有信心、有能力带领大家安全落地。”生死关头，英雄机组的正确处置，确保了机上全体人员的生命安全，创造了世界民航史上的奇迹。 随笔&emsp;&emsp;这部电影是国庆之后公里决定一起去刷的。先吹一波，公司福利是真的好，由于《我和我的祖国》热映，大部分员工自己去看过了，因此选择了大部分还没来得及看的《中国机长》。由于是包场看，机智的综管部门还顺便做了广告：在影院各大屏以及广告位“免费”播放了一天的公司广告，哈哈，完美～～&emsp;&emsp;扯回正题，谈一下看完电影的直观感受。&emsp;&emsp;首先，却是低估了空姐们”端茶倒水“日常背后的工作，如培训、训练、检查、准备等各种非一日之功的工作。&emsp;&emsp;然后，谈谈电影本身。很早就看过关于真实事件的访谈。真实中从起飞到结束总用时42分钟，其中的惊险程度比起电影甚至更加惊现，当然了，没有那些电闪雷鸣的虚构点。但是有点小失望的是，在飞机遇事之时，原型中机长一大波神操作，硬是在极其复杂的条件下完美的完成了三十多项功能操作（错一个可能就……），而电影中期待了许久的神操作，迟迟没有出现，反而全片一再强调民航全体员工的职业素养。当然，对于现实场景，一定是要大加鼓励的，但是全剧中尴尬之处也在于此。还有就是，剧中并没有交代飞机遇事原因。内中外三层玻璃，内层先裂开，原因几何等并没有交代清楚。于是，本来应该是该公司设备有问题的，经过机长系列操作后，完美的掩饰 这个问题的存在。&emsp;&emsp;抛开电影，我们学到了什么？&emsp;&emsp;过硬的技能。这点毋庸置疑，真实事件中，过硬的技能特长，较多的经验，系列史诗级的操作，没有一个不慎，没有机毁人亡。因为实力，所以幸运。对比我们自己，是否在自己专业中拥有日复一日的训练，是否有追求更高的能力特长呢？&emsp;&emsp;更高的素养。从职业素养来讲，影片中所有的人清楚自己岗位职责，清楚自己要做什么，并且明白要做好什么，这两点是有本质区别的，就像我的工作中， 做出一个页面和 做好一个页面是存在本质差的。&emsp;&emsp;更好的团队协作。影片中所突出展示的，团队协作也是一大亮点。无论是团内成员相互鼓励，还是团队之间的互相支持，都是井井有序。不因为我是员工中的一个，众多员工我不起眼，就去给团队抹黑，也不因为我是领导就特立独行一党专政，脱离规章无视制度。无论什么岗位，想要有高效产出，就要信任制度，信任队友。如果航班服务人员和乘客们不信任机长，那飞机内必然暴乱；如果机长之间不相互协作，个人凭借自身能力去驾驶飞行，相互之间就会出现信任差而出现操作上的失误；如果团队之间没有良好的协同，那是否能随意升降飞机高度？飞机即使能开回地面，降落点在哪儿？当这一些列的问题被井井有序的执行之时，就会感慨在一个完整的制度下相互配合是多么的重要。 敬畏生命 敬畏职责 敬畏规章]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发姿势篇——动效设计1]]></title>
    <url>%2F2019%2F10%2F12%2F%E5%BC%80%E5%8F%91%E5%A7%BF%E5%8A%BF%E7%AF%87%E2%80%94%E2%80%94%E5%8A%A8%E6%95%88%E8%AE%BE%E8%AE%A11%2F</url>
    <content type="text"><![CDATA[动效示例 关于动画 &emsp;&emsp;动画的英文有很多表述，如animation、cartoon、animated cartoon、cameracature。其中较正式的 “Animation” 一词源自于拉丁文字根anima，意思为“灵魂”，动词animate是“赋予生命”的意思，引申为使某物活起来的意思。所以动画可以定义为使用绘画的手法，创造生命运动的艺术。 动效设计&emsp;&emsp;继上篇基础开发篇，了解页面基础搭建和布局之后，接着便是对用户更加友好的动效体验。上面关于动画中提起，动画可以定义为使用绘画的手法，创造生命运动的艺术，因此在基础篇后，如何让页面/元素动起来，就是我们开发中的乐趣与艺术所在。&emsp;&emsp;本片总结参考凹凸实验室小册——大厂h5开发实战手册。 0. 分析&emsp;&emsp;完成上述动画，我们需要做以下几步 图片素材准备 基础布局 立体尝试 帧动画准备 动起来 接下来一步步来。 1. 素材&emsp;&emsp;任意图片即可，满足正方体六面使用。 2. 基础布局html12345678910 &lt;div class="move"&gt; &lt;div class="cube showDefault"&gt; &lt;div class="cube-face c-front"&gt;&lt;img src="xxx" alt="photo1"&gt;&lt;/div&gt; &lt;div class="cube-face c-back"&gt;&lt;img src=".xxx" alt="photo2"&gt;&lt;/div&gt; &lt;div class="cube-face c-top"&gt;&lt;img src="xxx" alt="photo3"&gt;&lt;/div&gt; &lt;div class="cube-face c-bottom"&gt;&lt;img src="xxx" alt="photo4"&gt;&lt;/div&gt; &lt;div class="cube-face c-left"&gt;&lt;img src="xxx" alt="photo5"&gt;&lt;/div&gt; &lt;div class="cube-face c-right"&gt;&lt;img src="xxx" alt="photo6"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css(此处用的scss)12345678910111213141516171819202122232425262728293031323334$cube-size: 500px;$cube-radius: $cube-size / 2;.move&#123; width: $cube-size; height: $cube-size; perspective: 1000px; /* 设置元素被查看位置的视图 */ /*-webkit-perspective: 1000px;*/ position: relative; margin: 50px auto 0; .cube&#123; width: 100%; height: 100%; position: absolute; transform-style: preserve-3d; /* 3d */ &amp;-face&#123; border: 2px solid #000; width: 100%; height: 100%; overflow: hidden; position: absolute; opacity: .95; backface-visibility: visible; /* 隐藏被旋转元素的背面 */ img&#123; width: 100%; display: block; &#125; &#125; &#125;&#125; &emsp;&emsp;到此处为止，基础布局已经可以了，只是由于没有给六个面单独设置3d效果，因此看到的是六张图叠加在一起，效果不够明显。接下来尝试让它变得更加立体。 3. 立体尝试&emsp;&emsp;当然，想要立体，还是需要给六个面依次设置。本小结需要了解css3的两个特性：transform和translate，然后继续布局：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$cube-size: 300px;$cube-radius: $cube-size / 2;.move&#123; width: $cube-size; height: $cube-size; perspective: 1000px; /* 设置元素被查看位置的视图 */ -webkit-perspective: 1000px; position: relative; margin: 50px auto 0; .cube&#123; width: 100%; height: 100%; position: absolute; transform-style: preserve-3d; /* 3d */ &amp;-face&#123; border: 2px solid #000; width: 100%; height: 100%; overflow: hidden; position: absolute; opacity: .95; backface-visibility: visible; /* 隐藏被旋转元素的背面 */ &amp;.c-front&#123; transform: translateZ( $cube-radius ); &#125; &amp;.c-back&#123; transform: rotateX( -180deg ) translateZ( $cube-radius ); &#125; &amp;.c-top&#123; transform: rotateX( 90deg ) translateZ( $cube-radius ); &#125; &amp;.c-bottom&#123; transform: rotateX( -90deg ) translateZ( $cube-radius ); &#125; &amp;.c-left&#123; transform: rotateY( -90deg ) translateZ( $cube-radius ); &#125; &amp;.c-right&#123; transform: rotateY( 90deg ) translateZ( $cube-radius ); &#125; img&#123; width: 100%; display: block; &#125; &#125; &#125;&#125; &emsp;&emsp;此时，我们将得到一个正面的结构体如上所示。那么我们如何让它展示的更加立体呢？给.cube添加代码，使其根据自身有一定的角度偏移量，然后得到更加立体的效果如下：123.showDefault&#123; transform: translateZ( - $cube-radius ) rotateY( -20deg ) rotateX(-20deg);&#125; &emsp;&emsp;ok，至此我们已经将基本效果完成。接下来，如何给它赋予灵魂，使其动起来呢？ 4. 帧动画准备&emsp;&emsp;首先需要了解以下帧动画（关键帧动画） &emsp;&emsp;任何动画要表现运动或变化，至少前后要给出两个不同的关键状态，而中间状态的变化和衔接电脑可以自动完成，在Flash中，表示关键状态的帧动画叫做关键帧动画。&emsp;&emsp;所谓关键帧动画，就是给需要动画效果的属性，准备一组与时间相关的值，这些值都是在动画序列中比较关键的帧中提取出来的，而其他时间帧中的值，可以用这些关键值，采用特定的插值方法计算得到，从而达到比较流畅的动画效果。 &emsp;&emsp;那么，在css中，关键帧动画两个内容需要掌握，可以从MDN或者别的网站上学习关于这两个内容： 关键帧(@keyframes) animation属性 &emsp;&emsp;了解之后，我们可以来定制我们的关键帧动画了。通过分析可得，我们要展示比较安全的动画效果，此处需要这设置6个关键动画，分别展示正方体的六个面。那么我们便从0%-100%分别设置六个面即可。如下： 12345678910111213141516171819202122232425262728/* 帧动画 */@keyframes autoRun &#123; /* front */ 0%, 100%&#123; transform: translateZ( -$cube-radius ); &#125; /* back */ 16.5%&#123; transform: translateZ( -$cube-radius ) rotateX( -180deg ); &#125; /* left */ 33%&#123; transform: translateZ( -$cube-radius ) rotateY( 90deg ); &#125; /* right */ 49.5%&#123; transform: translateZ( -$cube-radius ) rotateY( -90deg ); &#125; /* top */ 66%&#123; transform: translateZ( -$cube-radius ) rotateX( -90deg ); &#125; /* bottom */ 82.5%&#123; transform: translateZ( -$cube-radius ) rotateX( 90deg ); &#125;&#125; 5. 动起来&emsp;&emsp;设置完了帧动画，我们关键在于运用。那如何将动画引入到我们的css中去呢？首先，确定位置：我们要使正方体动起来，因此添加到.cube内；其次，我们要添加帧动画，因此要写明帧动画名称，也就是刚才定义的autoRun；最后，设置动画相关属性，如几秒加载完成、循环播放、渐进式等等。示例如下：123.cube&#123; animation: autoRun ease 10s alternate infinite;&#125; &emsp;&emsp;最终，得到效果图展示的立方体动效： end]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>动效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发姿势篇——基础开发]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%BC%80%E5%8F%91%E5%A7%BF%E5%8A%BF%E7%AF%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[概述&emsp;&emsp;近期学习了一下大厂h5开发实战内容，并且参考实战手册做一些记录。大概包括以下几个方面内容： 基础页面开发； 响应式页面开发； 滑屏应用开发； 动效开发；（若干篇章） &emsp;&emsp;接下来会根据以上几个方向来进行总结和概述。（可参考掘金小册——大厂h5开发实战手册） 基础页面开发&emsp;&emsp;很多开发者可能问，不就是画ui吗，有什么好说的呢？自然，基础页面开发是作为h5开发者，最为基础的能力。但是完成一个页面和做好一个页面是有本质区别的。因此，基础篇必不可少。&emsp;&emsp;那，上菜吧。 一、 能力要求&emsp;&emsp;你以为是简单的html/css/js吗？emm,对，但还不够。 html/css JavaScript（简单脚本） 切图 &emsp;&emsp;你没看错，【切图】也在能力要求范围内。不会「切图」意味着我们无法将设计稿中的图层元素转换成为网页中所需要的图片，那么产品所要求的高保真还原设计稿便是更不能企及了。 二、 案例如果我们得到设计稿如下图： &emsp;&emsp;通常，我们在ui设计师得到类似的.psd文件，然后开始着手开发。那么我们在开发中一般步骤如下： 设计稿审查; 编写页面骨骼框架; 填充网页血肉内容; 润色; 兼容性测试; &emsp;&emsp;我们一个一个来。 1. 设计稿审查审查意义： 了解设计稿的开发友好性 了解设计稿的排版布局及内容构成 &emsp;&emsp;此处也是常人的正向思维，拿到设计稿，先熟悉了解内容，然后思考以下是否有漏洞，或者是否有更好的建议与意见，其中某些模块细节如何处理，考虑复用性、易拓展性等，然后规划某些模块是否编写为可复用组件，复用范围等。&emsp;&emsp;还以上图为例，明显多处可复用。那么可复用的又大致可分为两种类别：跨页面复用以及当前页面复用。那么该案例设计稿则可以划分如下： 跨页面复用组件： 头部导航、脚部信息； 当前页面复用组件： 如下图中1、2 &emsp;&emsp;这些展示的只是该过程中最为基础的审查，当然，如果条件允许的话，团队内可以学习凹凸实验室，尝试总结出一个类似的审查清单： 确定设计稿的开发友好性（是否有还原成本高或无法还原的地方） 确定一些特殊的元素是否有合理的边界处理（如文案超出外层容器的边界怎么办） 确定页面的框架结构（Layout） 确定跨页面可复用的组件（Site Component） 确定当前页面可复用的组件（Page Component） …… &emsp;&emsp;此处不再一一赘述。 2. 编写页面骨骼框架&emsp;&emsp;审查结束后，心里基本上有了比较成型的代码模型了，那么接下来就是编写页面骨骼框架了。通俗的来讲，就是搭架子。那么架子怎么搭？仁者见仁，但是最为基础的却都是统一的，比如必须掌握的知识点——盒模型。当然，此处不会讲解关于盒模型以及兼容性和差异性，还不太了解的可以自行搜索或者查询w3school。我们需要掌握盒模型在不同浏览器下的差异，盒模型宽高计算方法、内外边距以及一些兼容性问题的解决方案。然后，在摸清楚兼容性差异并解决之，达到统一后，便开始着手开发。&emsp;&emsp;开发第一步：布局。&emsp;&emsp;开发过程中，我们会写无数个块级元素，那么其实每个块级元素都相当于是一个盒模型，而一张完整的页面，正是由多个盒模型组合在一起组成的。如此来讲，我们的页面布局便是重中之重：我们应该如何合理的布局呢？想回答这个问题，不得不啰嗦一下目前常见的几种布局方式： 文档流布局; 浮动布局(float); 绝对布局(absolute); 弹性布局(flex); 网格布局(grid)； &emsp;&emsp;在这几种常见的布局方式中，我们在经过第一步的审查设计稿之后，已经对开发内容有了一个大致的了解，起码架子方面是可以肯定的，因此根据设计稿内容选择合适的布局即可。目前一般页面布局都会属于混合布局，为了展示更加酷炫和对用户更加友好的内容，布局难度也在不断增加。但所谓复杂的布局，也要回归到基础布局上来回嵌套，因此这几种布局是必须全部熟悉并且掌握，合理运用。 3. 填充网页血肉内容&emsp;&emsp;在页面布局完成之后，下一步就是要开始填充页面内容了，图片、音视频、文字混排等等，都让我们的页面更加鲜活和立体。如果把网页开发比喻成房屋建设，那么我们前面完成的就是打好了地基。就此结束吗？醒醒，工头让我喊你搬砖。根据设计，砌墙、装修、水管电线等等都要一步步的来啊，任重而道远。&emsp;&emsp;在小册中，凹凸实验室此处概述重点讲解了前端另一大能力——切图。我不再作出相关介绍，关于切图姿势、如何高效切图等，都可以查找相关介绍。而在此处，我额外补充一点：优化。我所说的优化不是代码优化，而是引入的资源优化，比如图片、音视频等。因此一些小技巧，如雪碧图、占位图、预加载、懒加载等功能的特性便需要掌握。 4. 润色&emsp;&emsp;何谓润色？且不要多想，当作普通的css编写即可。&emsp;&emsp;其实在我们基础页面开发过程中，最容易获取成就感的地方，就在于润色过程，就好似给图画上色，哦不，是拍照化妆开美颜加滤镜，效果感十足。但是写的时候容易，维护却是一大难题。&emsp;&emsp;往往在写完某个页面一段时间后，需要对其中某个样式就行维护时，找到该css位置需要理一下思路，那么……我们怎么通过某种规范来规避此问题或者是使该问题简单化呢？ BEM &emsp;&emsp;BEM(boundary element method，边界元法)是一种继有限元法之后发展起来的一种新数值方法，与有限元法在连续体域内划分单元的基本思想不同，边界元法是在定义域的边界上划分单元，用满足控制议程的函数去逼近边界条件。所以边界元法与有限元相比具有单元的未知数少，数据准备简单等优点。但用边界元法解非线性问题时，遇到同非线性项相对应的区域积分，这种积分在奇异点附近有强烈的奇异性，使求解变得困难。 那么在我们的css代码中，如何使用BEM呢？ BEM 的意思就模块（Block）、元素（Element）、修饰符（Modifier），使用这种命名方式可以让 CSS 的类名变得有实际意义且能自我解释，具有更高的开发友好性。 123Block - 模块，名字的单词之间用 `-` 符号连接Element - 元素，模块中的子元素，用 `__` 符号连接Modifier - 修饰符，表示父元素或子元素的其他形态，用 `--` 符号连接 举个例子普通写法：1234&lt;footer class="footer-box"&gt; &lt;div class=“left”&gt;&lt;/div&gt; &lt;div class=“right”&gt;&lt;/div&gt;&lt;/footer&gt; BEM写法：1234&lt;footer class="footer-box"&gt; &lt;div class=“footer-box__left”&gt;&lt;/div&gt; &lt;div class=“footer-box__right”&gt;&lt;/div&gt;&lt;/footer&gt; &emsp;&emsp;对比后可发现，模块的命名已经语义化，后期维护减少了些许的复杂程度，页面的渲染效率提升了，但是……会不会命名太复杂了呢？不得不说，sacc/less是个好东西。我们搭配其来使用，则可编写为：1234.footer-box&#123; &amp;__left&#123; ... &#125; &amp;__right&#123; ... &#125;&#125; 5. 兼容性测试&emsp;&emsp;在页面开发完成之后，别急，换个浏览器试试？换台设备试试？emm，内心是拒绝的。&emsp;&emsp;兼容性测试是开发完成后必不可少的一步。由于各浏览器内核差异，版本差异甚至不同设备之间的分辨率差距，会导致同一个页面在不同设备不同浏览器中展现出千奇百怪的姿态来。为了完成页面的统一性，我们不得不一个个的做兼容，这也是印证了IE 虐我千百遍，我待 IE 如初恋这句话。 基本原则 渐进增强与平稳退化。 根据小册提议，兼容下问题解决流程步骤如下： 确认触发的场景：什么浏览器，什么版本，什么情况下触发的问题，做到稳定复现。 找出问题原因：是什么问题导致的，具体表现如何？ 确定解决办法：参考现成的解决方案，如哪些属性不能使用以及相应的 Hack 处理。 收集兼容性处理方法，积累成文档。 小结&emsp;&emsp;我们根据案例，分析了基础开发的五个步骤：设计稿审查;编写页面骨骼框架;填充网页血肉内容;润色;兼容性测试。每个步骤有了一个简单的介绍，但是不够深入，总体来讲还是对基础开发有了一个大致的了解。至于更加深入的内容，下篇接着写。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>基础开发</tag>
        <tag>大厂手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中@change兼容问题]]></title>
    <url>%2F2019%2F09%2F20%2Fvue%E4%B8%AD-change%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[@change问题1. 需求描述 需求：选择日期，当日期改变，则页面相应该日期的某些事件渲染 条件： 移动端 vue框架 2. 问题产生及描述问题： 兼容性差距，由于@change触发方式不同，导致时间加载不够统一，时间触发出现问题。 描述如下： 使用vue做移动端时，由于需求需要，需要在页面某处添加一个日期选择的控件。由于不是面向用户，内部使用，因此本着不浪费资源的原则，直接使用h5自带的input： 1&lt;input type="date"&gt; emm…CSS样式不再赘述。然后绑定数据,绑定change事件监听值变化： 1&lt;input type="date" v-model="date" @change="selectDate"&gt; 123selecrDate () &#123; // do something...&#125; 当基本流程敲定后，在pc端没问题。但注意，我们此时讨论的是移动端效果，那么用pc端打开调试工具来模拟移动端机型显然是不足以代表移动端真实场景的，因此需要在真机测试。ok，接下来，差异化出现。由于@change的特性是当监听到数据发生变化时则执行，因此差异便是暴露出来： 安卓：选择完年月日，点击确定后，数据变化，监听事件起作用； iOS： 点击选择日期，选择年，监听到数据变化一次，执行一次selectDate，选择月，监听到数据变化，再次执行，选择日，监听到数据变化，再执行……选择不停，执行不停。 由于此不同端所存在的差异化，导致了我们必须“兼容”这个问题。那么重点问题出现，如何兼容？ 3. 解决方案讨论到此，我们必须想办法先解决一个问题：如何在iOS端，阻止掉每一次选择都自动执行selectDate的问题。此时，经过一番探寻查找，发现@blur方法可以替代iOS中的@change，说干就干，盘他：1&lt;input type="date" v-model="date" @blur="selectDate"&gt; ok,找个苹果机试一下，完美，选择年月日莫的问题，只有点击确定之后才触发该事件。但，所谓小人得志不可取，兴高采烈的时候发现在安卓机上挂掉了。原因是在安卓机上选完以后，@blur事件并不会触发，除非选择完成之后，点击别的区域来触发此事件。因此，我们又面临一个兼容问题，怎么同时保证在安卓和iOS系统上都能流畅运行呢？有办法——js辨别系统是安卓还是iOS：123456789101112131415const u = navigator.userAgent, app = navigator.appVersion;// Android 判断const isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1;// iOS 判断const isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); if (isAndroid) &#123; // 这个是安卓操作系统 // do something&#125;if (isIOS) &#123; // 这个是iOS操作系统 // do something&#125; 有了此步骤，那接下来的事儿就简单多了： 如果是安卓系统，则用@change; 如果是iOS系统，则用@blur; 由于是移动端，所以不考虑pc～； 完成～.～！ 总结总结以上，步骤如下： 进入页面，执行js脚本，判断当前设备型号； 如果是安卓设备，执行@change； 如果是iOS设备，执行@blur。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《浮生六记》随笔]]></title>
    <url>%2F2019%2F09%2F17%2F%E3%80%8A%E6%B5%AE%E7%94%9F%E5%85%AD%E8%AE%B0%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[浮生若梦，为欢几何 一、 简介浮生六记 （清朝沈复著自传体散文） &emsp;&emsp;《浮生六记》是清朝长洲人沈复（字三白，号梅逸）著于嘉庆十三年（1808年）的自传体散文。清朝王韬的妻兄杨引传在苏州的冷摊上发现《浮生六记》的残稿，只有四卷，交给当时在上海主持申报闻尊阁的王韬，以活字板刊行于1877年。“浮生”二字典出李白诗《春夜宴从弟桃李园序》中“夫天地者，万物之逆旅也；光阴者，百代之过客也。而浮生若梦，为欢几何？”。 关于作者 &emsp;&emsp;沈复（1763—1825），字三白，号梅逸，长洲（现在江苏苏州）人，清代文学家。工诗画、散文。至今未发现有关他生平的文字记载。据其所著的《浮生六记》来看，他出身于幕僚家庭，没有参加过科举考试，曾以卖画维持生计。与妻子陈芸志趣投合，情感深厚，愿意过一种布衣素食而从事艺术的生活，但因封建礼教的压迫和贫苦生活的磨难，理想终未实现，经历了生离死别的惨痛。妻死后，他去四川充幕僚。此后情况不明。 二、 概要作品概述 &emsp;&emsp;这是一部自传体文学的作品，原书六卷，已逸其二，现仅存四卷（有所谓“足本”者，后二记系伪作。书中记叙了作者夫妇间平凡的家居生活，坎坷际遇，和各地浪游闻见。文辞朴素，情感真挚，前人曾有“幽芳凄三角，读之心醉”的评语。本书文字不长，但向为文学爱好者和研究者所重视，影响广泛。 主线 &emsp;&emsp;《浮生六记》以作者夫妇生活为主线，赢余了平凡而又充满情趣的居家生活的浪游各地的所见所闻。作品描述了作者和妻子陈芸情投意合，想要过一种布衣蔬食而从事艺术的生活，由于封建礼教的压迫与贫困生活的煎熬，终至理想破灭。本书文字清新真率，无雕琢藻饰痕迹，情节则伉俪情深，至死不复；始于欢乐，终于忧患，漂零他乡，悲切动人。此外，本书还收录了清代名士冒襄悼念秦淮名妓董小宛的佳作《影梅庵忆语》。 《浮生六记》中《闲情记趣》的《童趣》已选入人教版的语文书中。 目录 卷一 《闺房记乐》 卷二 《闲情记趣》 卷三 《坎坷记愁》 卷四 《浪游记快》 卷五 《中山记历》(缺) 卷六 《养生记道》(缺) 三、 随笔&emsp;&emsp;纵览全书，作者沈三白（沈复）能娶妻芸娘乃是三生之幸。其中，闲情记趣与浪游记快两篇，体现出三白与一众朋友的不凡的“玩耍”的水平。然而他与芸娘之间的真实感情，却更是让人琢磨不透。为何这么说呢，看完书上四篇之后，回忆俩人感情，字里行间能体会到的，不过时三白娶了芸娘之后的沾沾自喜。基本上没有品出三白对芸娘有做过特别让芸娘过得好的事，反而为了自己的“乐趣”，无论家境如何，玩才是第一要任。为了玩，没钱可以穷游，借钱。基本上一辈子处于不思进取的状态，今朝有酒今朝醉，养家糊口是不存在的。因此也早就了他不凡的“玩乐”水平。文笔来讲……emm，文言文，读的不多，因此不瞎做点评。芸娘呢，作为“娇妻”，对夫君三白宠爱有加，不仅对他不知上进无所表示，甚至总是为相公着想，如何玩的好，如何更好的玩。当然，为夫君物色“小妾”也同样作为自己的一大要任。 &emsp;&emsp;芸娘在与憨圆的交涉中，由于自己付出的是无比的真心，而憨圆却态度一直在不断转变。与此同时，由于那个时代的限制，被公婆冤枉但还是得想办法讨好。自己明明如此努力，努力帮夫君找小妾，努力帮助夫君建设他的爱好，努力做一个公婆眼中的“好媳妇”，努力。。。然后换来的却仍然十分不理想。无限制的包容，改进自己，但是自己仍然气啊，又不能向夫君发脾气，即使他一无所有。处处不得好，又不得不继续前进，矛盾便产生了。有了矛盾，久而不治，必病。身心不够舒畅，因此病不可解。一辈子，基本上没什么享受，但是却付出了全部。反观三白，我穷归我穷，但我“穷且益坚，不坠玩乐之志”。为了生活的情趣，牺牲什么倒都无所谓。这种态度，不得不让人感慨。但人各有志，或许这条追求生活情绪便是三白的一生志向所在吧，旁人无可道也。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进入移动web世界]]></title>
    <url>%2F2019%2F09%2F16%2F%E8%BF%9B%E5%85%A5%E7%A7%BB%E5%8A%A8web%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[一、 移动端web基础1. Pixel px: CSS pixels 逻辑像素，浏览器使用的抽象单位； dt,pt: 设备无关像素； dpr: 设备像素缩放比； 公式： 1px = (dpr)2 * dp 默认缩放比例： ldpi mdpi hdpi xhdpi ppi 120 160 240 320 默认缩放比例 0.75 1.0 1.5 2.0 2. Viewport手机浏览器默认做了两件事 页面渲染在了一个默认的viewport; 缩放; 那么问题来了，为什么会有一个默认的viewport呢？我们知道，pc端页面，在移动端查看的时候，由于像素不匹配，但是为了能够给用户展现一个比较完整的页面，因此会虚拟出一个viewport出来，在此viewprot上渲染页面。也就是说，最终目的，是为了排版正确。但是由于一般默认情况下，给出的viewport像素宽对页面来说是不友好、不规范的，因此我们还需要解决一个规范问题。解决方案：在head中加一个meta标签格式如下：&lt;meta name=&quot;viewport&quot; content=&quot;name=value, name=value&quot;&gt; 3. meta标签1234567&lt;meta name="viewport" content="name=value, name=value"&gt;// name = value 对应关系width: device-width;initial: xx; // 设置初始缩放minimum-scale: xx; // 最小缩放maxim-scale: xx; // 最大缩放user-scalable: no; // 用户不可缩放 二、 高效的移动web布局1. flexbox弹性布局 flex布局混合排版 12345678910111213/* 混合使用flex占比 */.nav&#123; display: -webkit-flex;&#125;.son1&#123; flex: 1; &#125;.son2&#123; flex: 3;&#125;.son3&#123; width: 100px;&#125; flex水平垂直居中 12345.parent&#123; justify-content: center; align-items: center; display: -webkit-flex;&#125; 2. flex兼容性 iOS可以使用最新的flex布局； Android4.4以下，只能兼容旧版flexbox布局； Android4.4及以上，可以使用最新的flex布局； 表现如下： 新felx布局 旧flexbox布局 display: -webkit-flex; display: -webkit-flex-box; -weblit-flex: 1; -weblit-flex-box: 1; justify-content: center; box-pack: center; align-items: center; box-align: cneter 3. 响应式设计顾名思义，一套页面，在所有端（pc、超大屏、ipad、手机等）完美运行。随页面宽高变化而改变页面样式，从而适配不同设备。 媒体查询 @media123456789101112131415161718192021222324252627282930@media screen and (max-width: 1024px) &#123; body&#123; background: #eee; &#125;&#125;@media screen and (max-width: 980px) &#123; body&#123; background: green; &#125;&#125;@media screen and (max-width: 720px) &#123; body&#123; background: yellow; &#125;&#125;@media screen and (max-width: 640px) &#123; body&#123; background: skyblue; &#125;&#125;@media screen and (max-width: 320px) &#123; body&#123; background: pink; &#125;&#125;@media screen and (min-width: 1025px) &#123; body&#123; background: darkseagreen; &#125;&#125; 媒体类型 screen： 屏幕 print： 打印机 handhead： 手持设备 all： 通用 常用参数说明 width: 视口宽 height: 视口高 device-width: 设备宽 device-height: 设备高 orientation: 检查设备横屏竖屏处向（landscape横，portrait竖） 设计点 百分比布局：使切换css不同媒体样式时更加平滑 弹性图片：图片根据盒子百分比，改变盒子宽高即可 重新布局，显示和隐藏： 同比例缩减元素尺寸 调整页面结构布局 隐藏冗余的元素 优劣比较 优点：减少重复开发，一套代码多端兼容 劣势：在极端情况下影响页面性能，含有较多的冗余代码 4. 移动web特别样式处理a. 高清图片处理 width: (w_value / dpr)pxheight: (h_value / dpr)px b. 1像素边框问题问题： Retina屏幕下，1像素问题原因： 1px使用2dp渲染解决：123456789101112131415/* 错误案例 */div&#123; border-top: 0.5px;&#125;/* 正确案例 */div:before&#123; border-top: 1px; -webkit-transform: scaleY(0.5); position: absolute; top: -1px; left: 0; content: ''; height: 1px;&#125; c. 相对单位 em: 根据父节点的font-size为相对单位 rem: 根据html的font-size为相对单位 （建议使用） 那么，rem的基值设置为多少比较合适呢？回归到开发中来，我们有一个公式：rem = screen.width / x例： 320的屏幕，可以设置为font-size=32px，而375的屏幕，设置为37.5px。我们的目的是为了方便计算。 d. 文本溢出12345678910111213141516/* 单行文本溢出*/.line&#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125;/* 多行文本溢出 */.lines&#123; display: -webkit-box !important; overflow: hidden; text-overflow: ellipsis; word-break: break-all; -webkit-box-orient: vertical; -webkit-line-clamp: 2; // 行数&#125; 三、 终端交互优化1. 300ms延迟问题在移动端，由于有多重手势操作替代了鼠标操作，因此，为了判断出是点击、双击、触摸移动或者别的手势，iOS系统判断中加了一个300毫秒的延迟：在第一次出发事件300毫秒内再次出发，例如点击，就会被判断为双击。那么为了统一规范，后来在Android系统中也加入了此判定。这就是著名的移动端300ms延迟问题。那么如何解决这个问题呢？tap事件处理。什么是tap事件？简而言之，就是通过touch，监听touchstart和tarchend，如果两者间隔较短，例如100ms甚至更短，且起始位置的偏移量极小，控制在几个像素之内，那么就判定为点击事件。如此操作，可以绕过系统300ms的规范，从而在用户体验上做的更优。但我们只有，一般有利就有弊。我们解决掉300ms延迟问题，从而又产生了一个新的问题，就是穿透问题。例如在按钮上有一个蒙层，我们点击蒙层，关闭其蒙层。但是如果在蒙层下面同样有点击事件，那么我们在点击蒙层关闭后，也会触发到下面的事件。那么这种问题的一般解决方案便是关闭蒙层的时候，添加一个300ms的延时，经过300ms延时关闭后，点击不再具有穿透性，巧妙的解决的该穿透问题。但是问题又来了，300ms延时其实对用户体验来讲并不那么友好。因此还是推荐第一种解决方案，不会出现拆东墙补西墙或者说捉襟见肘的问题。当然，如果使用框架库的话，大部分强大的库默认都解决了这个问题，不用开发者再为此操心。 2. touch相关触摸是移动设备交互的核心事件 a. 触摸事件 事件 触发情况 备注 touchstart 手指触摸屏幕触发 已有手指放在屏幕上则不触发 touchmove 手指在屏幕上滑动 连续触发 touchend 手指离开屏幕时触发 / touchcancel 系统取消touch时触发 不常用 b. 事件属性 touches： 跟踪触摸操作的touch对象数组 targetTouches： 特定事件目标的touch对象数组 changeTouches： 上次触摸改变的touch对象数组 c. 每个touch对象包含属性 clientX： 触摸目标在视口中的横坐标 clientY： 触摸目标在视口中的纵坐标 identifier： 标识触摸的唯一id pageX： 触摸目标在页面中的横坐标（含滚动） pageY： 触摸目标在页面中的纵坐标（含滚动） screenX： 触摸目标在屏幕中的横坐标 screenY： 触摸目标在屏幕中的纵坐标 target： 触摸的DOM节点的目标 d. 相关bug在Android中，某些版本只会触发一次touchstart和一次touchmove，不会触发touchend。解决方案则是在事件中（touchmove）添加阻止默认事件：event.preventDefault()。但与此同时，要注意随之产生的一个问题，就是组织默认事件后，页面也会随之禁止滚动，因此看情况使用。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>移动web</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue构建项目入口文件index.html缓存引发的白屏问题]]></title>
    <url>%2F2019%2F09%2F03%2Fvue%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6index-html%E7%BC%93%E5%AD%98%E5%BC%95%E5%8F%91%E7%9A%84%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题&emsp;&emsp;vue项目打包后，在非首次线上替换dist文件时，某些手机/浏览器在之后首次打开页面，可能出现白屏情况。那么该问题产生原因是什么呢？我们又该如何应对呢？ 背景及原因分析&emsp;&emsp;在使用vue-cli脚手架构建完项目，项目完成后，需打包上线。默认打包方式则是npm build，然后项目根目录会生成 dist 文件夹。服务端将该文件夹替换线上即可。但是当第n（n&gt;1）次上线后，由于在用户端会默认缓存index.html入口文件，而由于vue打包生成的css/js都是哈希值，跟上次的文件名都不同，因此会出现找不到css/js的情况，导致白屏的产生。&emsp;&emsp;经常使用vue作为开发框架的开发者都知道，build打包后，所生成的css/js的文件名中间会夹杂哈希值，以此来避免缓存问题。但是由于入口文件index.html的名字每次打包后不改变，并且也不能乱变，就导致了index.html在用户端仍然会被缓存下来。那么在服务端更新包之后，由于旧的文件被删除，而index.html所链接的路径依然是旧文件路径，因此会找不到文件，从而白屏。解决方案一般是强制刷新页面或者清除缓存重新加载。当然，网上也给出不少的“缓解方案”。为什么称之为缓解方案而不是解决方案呢？因为前端缓存问题是一个具有行业性的难题，在没有根治之前，一般是优化为主。当然，引领前端行业的大佬们自然是要挑战极限的，不在该问题之内讨论。&emsp;&emsp;下面给出部分优化方案。 优化方案方案1. meta标签12345&lt;!-- 在入口文件index.html中，头部添加meta标签 --&gt;&lt;meta http-equiv="Expires" content="0"&gt;&lt;meta http-equiv="Pragma" content="no-cache"&gt;&lt;meta http-equiv="Cache-control" content="no-cache"&gt;&lt;meta http-equiv="Cache" content="no-cache"&gt; 方案2. 时间戳区分12345678// webpack.prod.conf.jsconst Version = new Date().getTime();output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].[chunkhash].'+_Version+'js'), chunkFilename: utils.assetsPath('js/[id].[chunkhash].'+_Version+'js')&#125; 方案3. 服务端配置123456// nginx端配置location = /index.html &#123; add_header Cache-Control "no-cache, no-store"; # add_header Cache-Control no-store; # add_header Pragma no-cache;&#125; 方案对比 方案 操作难度 优缺点 1 html文件简单修改 基本上没用 2 webpack配置简单修改 跟hash值文件名一个性质，不解决痛点 3 服务端加配置，简单 解决部分缓存问题，不解决全部；白屏问题依旧存在 新思路&emsp;&emsp;在一些论坛中，在某些特定情况下（如混合开发App，原生嵌入webview还在h5)，可在原生端尝试解决： 加载webview前清除缓存再加载； 销毁webview前清除缓存； &emsp;&emsp;效果如何，有待验证。 以上。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>白屏</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css篇:loading动画]]></title>
    <url>%2F2019%2F08%2F26%2Fcss%E7%AF%87-loading%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[示例 一、解析loading动画1&emsp;&emsp;由图可见，动画1中有三根竖线，在进行变长变短的高度变化以及线条的颜色变化，因此分为以下几个步骤： 建立块级区域； 三根线条排版； 动画——颜色、线条长度渐变； 动画引入及执行方法； loading动画2&emsp;&emsp;动画2中则与动画1排版略有不同：在动画区域内，有四个圆点，然后重复的放大缩小以及匀速旋转。因此步骤如下： 建立块级区域； 四个原点排版（定位/flex等方法） 动画——缩放、旋转； 动画引入及执行方法； 二、 代码1. loading1html1234567&lt;div class="loading"&gt; &lt;div class="loading1"&gt; &lt;div class="line line1"&gt;&lt;/div&gt; &lt;div class="line line2"&gt;&lt;/div&gt; &lt;div class="line line3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.loading&#123; width: 100px; height: 100px; overflow: hidden; background: rgba(0,0,0,0.2); border-radius: 10px; margin: 10px;&#125;/* loading1 */.loading1&#123; height: 34px; margin-top: 33px; text-align: center; display: flex; justify-content: center;&#125;.line&#123; margin: 0 5px; width: 10px; height: 16px; background: #8e6ddb; border-radius: 15px;&#125;.line1&#123; animation: loading1 .6s ease 0s infinite;&#125;.line2&#123; animation: loading1 .6s ease .2s infinite;&#125;.line3&#123; animation: loading1 .6s ease .4s infinite;&#125;@keyframes loading1 &#123; 0% &#123; height: 16px; background: #608cff; &#125; 50% &#123; height: 34px; background: #8e6ddb; &#125; 100% &#123; height: 16px; background: #608cff; &#125;&#125; 2. loading2html12345678&lt;div class="loading"&gt; &lt;div class="loading2"&gt; &lt;div class="point point1"&gt;&lt;/div&gt; &lt;div class="point point2"&gt;&lt;/div&gt; &lt;div class="point point3"&gt;&lt;/div&gt; &lt;div class="point point4"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384.loading&#123; width: 100px; height: 100px; overflow: hidden; background: rgba(0,0,0,0.2); border-radius: 10px; margin: 10px;&#125;/* loading2 */.loading2&#123; position: relative; width: 46px; height: 46px; margin: 27px auto 0; flex-wrap: wrap; animation: loading2 2s linear 0s infinite;&#125;.point&#123; width: 16px; height: 16px; background: red; border-radius: 50%; position: absolute;&#125;.point1&#123; top: -8px; left: 50%; margin-left: -8px; background: #dbdcbf;&#125;.point2&#123; right: -8px; top: 50%; margin-top: -8px; background: #32b53f;&#125;.point3&#123; bottom: -8px; left: 50%; margin-left: -8px; background: #a77ef4;&#125;.point4&#123; left: -8px; top: 50%; margin-top: -8px; background: #c4356d;&#125;@keyframes loading2 &#123; 0% &#123; transform: rotate(0deg) scale(1); &#125; 10% &#123; transform: rotate(36deg) scale(1.1); &#125; 20% &#123; transform: rotate(72deg) scale(1.2); &#125; 30% &#123; transform: rotate(108deg) scale(1.3); &#125; 40% &#123; transform: rotate(144deg) scale(1.4); &#125; 50% &#123; transform: rotate(180deg) scale(1.5); &#125; 60% &#123; transform: rotate(216deg) scale(1.4); &#125; 70% &#123; transform: rotate(252deg) scale(1.3); &#125; 80% &#123; transform: rotate(288deg) scale(1.2); &#125; 90% &#123; transform: rotate(324deg) scale(1.1); &#125; 100% &#123; transform: rotate(360deg) scale(1); &#125;&#125; ###以上。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>动画</tag>
        <tag>loading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue/cli3项目运行报错sockjs-node/info解决方案]]></title>
    <url>%2F2019%2F08%2F13%2Fvue-cli3%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99sockjs-node-info%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[bug复现&emsp;&emsp;继上次将vue项目脚手架工具从vue-cli2.x升级到vue-cli3.x后，除了环境、配置问题外，在运行时出现了一些个新的问题。&emsp;&emsp;启动项目后，在内网非本机运行项目时，控制台报错如下：1234567get http://localhost:8080/sockjs-node/info?t=1462183700002 net::ERR_CONNECTION_REFUSED[WDS] Disconnected!get http://localhost:8080/sockjs-node/info?t=1462183700002 net::ERR_CONNECTION_REFUSED[WDS] Disconnected!get http://localhost:8080/sockjs-node/info?t=1462183700002 net::ERR_CONNECTION_REFUSED[WDS] Disconnected!... webpack.config.js的目前配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const path = require(&apos;path&apos;);const resolve = dir =&gt; path.resolve(__dirname, dir);const env = process.env.NODE_ENV;module.exports = &#123; // 基本路径配置，解决打包路径问题 publicPath: &apos;./&apos;, // 配置less css: &#123; loaderOptions: &#123; css: &#123;&#125;, postcss: &#123; plugins: [ require(&apos;postcss-px2rem&apos;)(&#123; remUnit: 37.5 &#125;) ] &#125; &#125; &#125;, configureWebpack: (config) =&gt; &#123; // 如果不是开发环境 if (env !== &apos;development&apos;) &#123; &#125; // 路径 config.resolve = &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &#125; &#125; &#125;, chainWebpack: config =&gt; &#123; // 添加别名 config.resolve.alias .set(&apos;@&apos;, resolve(&apos;src&apos;)) .set(&apos;assets&apos;, resolve(&apos;src/assets&apos;)) .set(&apos;static&apos;, resolve(&apos;src/static&apos;)); &#125;,&#125; 报错分析&emsp;&emsp;首先，sockjs-node是何方神圣？不难查出，sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟、全双工的浏览器和web服务器之间通信通道。那么在各端表现为： 服务端：sockjs-node（https://github.com/sockjs/sockjs-node） 客户端：sockjs-clien（https://github.com/sockjs/sockjs-client） &emsp;&emsp;vue-cli3.x的启动方式是npm run serve，我们没有用到该sockjs-node功能，但启动时会默认连续发请求调用本地接口。因此我们要做的就是移除掉它。那么如何移除？ 解决方案&emsp;&emsp;分享两种方案 1. 注释法&emsp;&emsp;顾名思义，找到依赖包中的源码，将其注释： 进入路径/node_modules/sockjs-client/dist/sockjs.js 代码1605行注释掉： 123456try &#123; // self.xhr.send(payload); //本行注释&#125; catch (e) &#123; self.emit('finish', 0, ''); self._cleanup(false);&#125; 重启项目 2. 配置vue.config&emsp;&emsp;vue.config.js中的module.xports中添加如下，然后重启：1234devServer: &#123; proxy: 'http://localhost:8080', public: '192.168.xxx.xxx:8080' // 本地ip&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli3</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello React]]></title>
    <url>%2F2019%2F08%2F06%2FHello-React%2F</url>
    <content type="text"><![CDATA[一、 开发环境配置(Mac)1. node.js 安装 （node + npm) 1//官网安装包下载即可 2. 官方脚手架工具 create-react-app 1npm install create-react-app -g 3. 创建项目1create-react-app hello //创建一个叫hello的项目 4. 运行项目12//创建完后，cd到该项目npm start #小结&emsp;&emsp;至此，Mac环境下react基于脚手架的开发环境已搭建完成。运行项目（npm start)后，浏览器会自动打开本地页面http://localhost:3000/。如果到此步弹出带有react的Logo的欢迎页面，则表示环境已经成功配置。 二、 Hello World&emsp;&emsp;作为程序员最喜闻乐见的入门代码，还属 hello world 。那么第一个组件则输出一段 hello world。 1. 项目目录结构基础目录结构及注释如下：12345678910111213141516|——hello |—— node_modules # 项目依赖 |—— public # 公共文件 |—— favicon.ico // 网站图标 |—— mainfest.json // 应用基本配置信息 └── index.html // 主入口文件 |—— src # 主程序模块 |—— App.css // App css样式 |—— App.js // 主组件 |—— App.test.js // 测试组件 |—— index.css // 主文件样式 |—— index.js // 主文件脚本 |—— logo.svg // svg logo └── serviceWorker.js // 缓存配置文件 |—— package.json # 包配置文件 └── README.md # React说明文档 2. 第一个组件&emsp;&emsp;了解了项目结构，接下来开始写hello world组件。 首先，在src文件夹下新建一个文件，如HelloWorld.js。然后，在该文件下，三步走： 引入react 新建类继承react 导出 示例一下：12345678910111213141516// 1. 引入import React from 'react'// 2. 类class HelloWorld extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;// 3. 导出export default HelloWorld &emsp;&emsp;我们第一个组件就写完了，但是缺少一步：将组件挂载到根节点上：打开src/index.js：1234567// ...// 引入组件import HelloWorld from './HelloWorld'// 挂载ReactDOM.render(&lt;HelloWorld /&gt;, document.getElementById('root')); # 小结&emsp;&emsp;写完第一个组件运行起来，仿佛打开了新世界的大门……诶，等等，刚才我写了什么？为什么在js中render函数中返回的是一段奇怪的html代码？这是什么格式？这样的代码是什么鬼？听我道来。 三、 JSX1. 关于JSX&emsp;&emsp;上章说到，render函数中返回的是一段奇怪的html代码，那这段代码是什么吗？在此引入JSX概念及语法。Facebook称其为jsx，属于JavaScript的语法扩展。虽然看似html的模板语言，实则是在JavaScript内部实现。 2. 语法&emsp;&emsp;引入JSX概念，是为了编程更加简答。当然，JSX的语法也不会复杂，甚至可以说是非常简单：主要语法是一个花括号，然后在花括号内写expressions表达式即可。对expression有疑惑的可以先挪步到官方查阅文档，传送门：expression a. 基本语法&emsp;&emsp;那么，使用expressions表达式我们可以做什么呢？大家可以简单敲几行运行一下。简单示例下：1234567891011121314151617import React from 'react'class Test extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello React&lt;/h1&gt; &lt;div&gt;字符串： &#123;'string'&#125;&lt;/div&gt; &lt;div&gt;数字运算： &#123;12+4&#125;&lt;/div&gt; &lt;div&gt;数组： &#123;[1,2,3,4]&#125;&lt;/div&gt; &lt;div&gt;JSX：&#123;&lt;mark&gt;标识&lt;/mark&gt;&#125;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;export default Test &emsp;&emsp;如果我们需要进行一些数据操作，例如判断，遍历等等之类的，又要怎么做呢？ b. map12345678910111213141516171819202122import React from 'react'class Welcome extends React.Component &#123; render() &#123; const learnList = ['React', 'Vue', 'Angular']; return ( &lt;div&gt; &lt;ul&gt; &#123; learnList.map((item, index) =&gt; &lt;li&gt;&#123;index + 1&#125;: &#123;item&#125;&lt;/li&gt; ) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default Welcome c. if三元表达式1234567891011121314151617import React from 'react'class Welcome extends React.Component &#123; render() &#123; const showMe = true; return ( &lt;div&gt; &#123; showMe ? &lt;mark&gt;这是true显式的文字&lt;/mark&gt; : &lt;b&gt;这是false显式的文字&lt;/b&gt; &#125; &lt;/div&gt; ) &#125;&#125;export default Welcome d. 属性&emsp;&emsp;大部分情况，html语法在JSX中正常使用，但是也有个别例外： class =&gt; className for =&gt; htmlFor 例:12345return ( &lt;div className="..." htmlFor="..."&gt; 一段文字…… &lt;/div&gt;) # 小结&emsp;&emsp;本章了解了上章提到的，写在js中的html是JSX语法，并且介绍了JSX语法及基本功能使用，已经可以开始上手解决一部分的业务了。那么除此之外，关于组件之间如何交流，有何属性和状态？且看下回。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JSX</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6——Class基本语法]]></title>
    <url>%2F2019%2F07%2F29%2FES6%E2%80%94%E2%80%94Class%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、 简介&emsp;&emsp;JavaScript语言传统方法是通过构造函数定义并生成新对象。例：12345678910function Add (a, b) &#123; this.a = a; this.b = b;&#125;Add.prototype.toString = function () &#123; return this.a + this.b;&#125;var add = new Add(5, 8) &emsp;&emsp;而在ES6中，引入了Class这个概念来作为对象的模板。而class只是一个语法糖写法，还是基于ES5封装而来的。上面的例子用class来改写如下：1234567891011// 定义类class Add &#123; constructor (a, b) &#123; this.a = a; this.b = b; &#125; toString () &#123; return this.a + this.b; &#125;&#125; 注：方法之间不需要加逗号，否则会报错。 &emsp;&emsp;从中可见一个constructor方法，这便是构造方法。另外，关键字this则代表实例对象。 二、基本准则 ES6的类完全可以看作是构造函数的另一种写法 类的数据类型就是函数，类本身就只想构造函数 构造函数的prototype属性在ES6的类上继续存在 类的所有方法都定义在类的prototype上 在类的实例上调用方法，其实就是调用原型上的方法 Object.assign可以一次向类添加多个方法 类的内部定义的所有方法都是不可枚举的 类的属性名可以采用表达式 1. 一次向类添加多个方法12345// Object.assign(类原型,&#123;方法列表&#125;)Object.assign(Add.prototype, &#123; toString () &#123;&#125;, toValue () &#123;&#125;&#125;) 2. 不可枚举123456789101112class Add &#123; constructor (a, b) &#123; // ... &#125; toString () &#123; // ... &#125;&#125;Object.keys(Add.prototype); // []Object.getOwnPropertyNames(Add.prototype); // ["constructor", "toString"] 3. 属性名表达式1234567891011const methodName = 'getValue';class Add &#123; constructor (a, b) &#123; // ... &#125; [methodName] () &#123; // ... &#125;&#125; 三、 拓展1. 严格模式&emsp;&emsp;类和模版的内部默认使用严格模式，所以无需使用use strict指定运行模式。只要将代码卸载类或者模块之中，就只有严格模式可用。ES6已经把整个语言都升级到了严格模式下。 2. constructor方法&emsp;&emsp;constructor方法是类的默认方法，通过new命令生成对象实例时自动调用该方法。如果类中没有显式定义，则会默认添加一个空的constructor方法。例：12345678class Add &#123;&#125;// 等同于class Add &#123; constructor () &#123;&#125;&#125; &emsp;&emsp;上面代码中定义了一个空的类Add，JavaScript引擎会自动给它添加一个空的constructor方法。除此之外，还需注意的是： constructor方法默认返回this，不过也可以指定返回另一个对象 类必须使用new来调用，否则会报错 3. 类的实例对象&emsp;&emsp;实例的属性除非是显式定义在this对象上，否则都是定义在了Class上。123456789101112131415161718class Add &#123; constructor (a, b) &#123; this.a = a; this.b = b; &#125; toString () &#123; return this.a + this.b; &#125;&#125;var add = new Add(5, 8);add.toString(); // 13add.hasOwnProperty('a'); // trueadd.hasOwnProperty('b'); // trueadd.hasOwnProperty('toString'); // falseadd.__proto__.hasOwnProperty('toString'); // true &emsp;&emsp;从上面代码中，a和b都是实例对象Add自身的属性，因为定义在this变量上，所以执行hasOwnProperty方法返回true；而toString是原型对象的属性，因为定义在Add上，所以hasOwnProperty方法返回的事false。另外，类的所有实例共享一个原型对象；可以通过实例的proto属性为类来添加方法。 4. 其他&emsp;&emsp;除上述所说之外，类同样有很多有意思的属性或者方法，此处放上一些，以供参考。 Class表达式 不存在变量提升 私有方法 私有属性 this的指向 name属性 Class的存取值函数（setter/getter） Class的Generator方法 Class的静态方法 静态属性和实例属性 new.target属性 参考：ECMAScript 6 入门 - 阮一峰]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能对业务数据的影响]]></title>
    <url>%2F2019%2F07%2F27%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E5%AF%B9%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BD%B1%E5%93%8D%2F</url>
    <content type="text"><![CDATA[序&emsp;&emsp;开题之前，思考以下三个性能比较： for循环 和 for循环 哪个更快？Math.floor 是否比 |0 更好?多个 if-else 是否要用 switch-case 替代? &emsp;&emsp;前端发展至此，前端性能随之变成了一个很有意思的话题。从入门级别的初级工程师，到高级别的专家，都离不开性能问题。那么前端性能该如何理解呢？ 总论&emsp;&emsp;前端时间学习前淘宝前端总负责人winter的课程，受益颇深。前面三个性能比较的例子，在社区或者论坛中大家对此的讨论从未断过，也乐此不疲。但是，它们出了让你写代码的时候纠结之外，毫无意义。&emsp;&emsp;比如，在写业务的时候，某一个功能模块有数据操作，千方百计的将某个循环操作优化了，可能执行效率提高了一倍。可是在整体来看，页面打开速度一样，用户也没有任何良好反馈，甚至测试都毫无察觉。因此，性能优化不能局限于局部代码。用大佬winter的话来讲，就是一切没有profiling的性能都是耍流氓。凡是真正有价值的性能优化，必定是从端到端的业务场景建立体系来考虑的。 流程分析&emsp;&emsp;那么我们从何入手，又该怎样考虑和执行呢？总结如下： 现状评估和建立指标 技术方案 执行 结果评估和监控 1. 现状评估&emsp;&emsp;此处，要解决的问题有两个： 从用户体验来讲，什么样的性能指标能更好的评估产品的体验？ 对公司来说，什么样的指标会影响到公司业务价值？ &emsp;&emsp;性能问题大致分为三个层次： 页面加载； 动画与操作； 内存，电耗； 2. 建立指标&emsp;&emsp;从这三个方面来看，如果一个页面在经历了几秒的白屏才打开，那注定用户流失率会极其高。而用户流失率是公司所注重的，因此页面加载则是重中之重。因此，需要大量评测页面加载时常对用户的影响。大量数据表示，加载时间在1s以内，差别都不大。因此首要就是正常网络状况下，加载时长要优化至1s以内。但是会碰到一个新的问题，就是少数极端网络用户（如2g网络）加载时间会极长，在统计后，会极大的拉低平均加载时长，从而影响整体的指标。因此，指标不能反应大多数的用户体验。因此，他们团队提出——秒开率：一秒之内能打开的用户占总用户的比重。 3. 技术方案&emsp;&emsp;有了目标，便需要以技术手段去解决问题了。在课程中，winter将技术方案有了一个比较系统的划分： 缓存： 客户端的强缓存策略 降低请求成本： HTTP DNS: 由客户端控制，隔一段时间主动请求DNS获取域名IP，不走系统的DNS TCP/TLS连接复用：由服务端升级到HTTP2，并尽量合并域名 减少请求数： JS，CSS打包到HTML JS控制图片异步加载、懒加载 小图用data-url 减少传输体积： 尽量使用svg/gradient等代替图片 根据机型和网络状况控制图片清晰度 对低清晰图片使用锐化来提升用户体验 设计上避免大型背景图 &emsp;&emsp;以上列出的仅仅是部分技术方案事例，但是可见，需要产品、设计、服务端等多方面的协作去完成。因此，性能优化一定是团队事件，而不是有着局限性的个人模块。 4. 执行&emsp;&emsp;有了方案就要贯彻执行。一个良好的团队，一定有高强度执行力。当然，执行一样不简单。方案靠技术，那执行则靠工程了。&emsp;&emsp;三个阶段工程水平从低到高如下，而结合多数公司现状，由于自动化成本过高，因此建议制度化+自动化搭配执行，以求高效率高质量。 纯管理 制度化 自动化 5. 结果评估和监控&emsp;&emsp;一个阶段的工程实施，必定要有阶段性的工程结果和总结。而结果总结并不意味着是最终答卷。此过程是一个长期过程，而分割为多个短期节点或者里程碑。这就要求不光要有结果，还要不断优化，不断更新。那就意味着，我们还需要做好线上监控。线上监控要做好，两个数据不可少： 数据采集 数据展现 总而言之&emsp;&emsp;总而言之，性能的优化，应该基于公司实际业务和实际的用户需求体验而做的一种工程实施，而不是单纯的技术游戏。 参考：《极客时间》之《重学前端》]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>前端性能</tag>
        <tag>前端笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端技巧——js篇]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94js%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前端技巧——js篇[01] 复制操作1234567891011copy () &#123; let url = this.code; let oInput = document.createElement('input'); oInput.value = url; document.body.appendChild(oInput); oInput.select(); // 选择对象 console.log(oINput.value); document.execCommand('Cooy'); // 执行浏览器复制命令 alert('复制成功'); oInput.remove();&#125; 出生日期转年龄【正则】12345678910function getAge(str) &#123; var r = str.match(/^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;)$/); r === null ? return false : '' ; var d = new Date(r[1], r[3]-1, r[4]); if (d.getFullYear() == r[1] &amp;&amp; (d.getMonth() + 1) == r[3] &amp;&amp; d.getDate == r[4]) &#123; var Y = new Date().getFullYear(); return (Y - r[1]); &#125; return '输入有误,请检查格式';&#125; 随即打乱顺序1234var arr = [1,2,3,4,5,6,7,8,9,0];arr.sort(() =&gt; &#123; return (0.5 - Math.random());&#125;) 截取url参数123456789function getParams () &#123; var obj = &#123;&#125;; var url = window.location.search; // 截取'?'及之后的字符串 var str = url.string(1, url.length); // 删除'?' var arr = str.split('&amp;'); // 分割数组 for (var i = 0; i &lt; arr.length; i ++) &#123; obj[arr[i].split('=')[0]] = unescape(arr[i].split('=')[1]); &#125;&#125; 字体自适应12345678910111213// 根元素var win = window,doc = document;function setFontSize() &#123; var winWidth = $(window).width(); // 设计稿比如为750 可自定义 var size = (winWidth / 750) * 100; doc.documentElement.style.fontSize = (size &lt; 100 ? size : 100) + 'px';&#125;;// 页面初始化setTimeout(function() &#123; setFontSize();&#125;, 100); 随机数12var n = parseInt(10 * Math.random()); // 0~10之间随机整数console.log(n); form中上传图片 选择图片，点击确定后将图片传至后台，获取到url； url存于本地或者隐藏域； form框完成后，将url传到后台即可。 input输入框控制【行内】 输入大于0的正整数 1&lt;input onkeyup="if(this.value.length==1)&#123;this.value=this.value.replace(/[^1-9]/g,'')&#125;else&#123;this.value=this.value.replace(/\D/g,'')&#125;" onafterpaste="if(this.value.length==1)&#123;this.value=this.value.replace(/[^1-9]/g,'')&#125;else&#123;this.value=this.value.replace(/\D/g,'')&#125;"&gt; 纯数字 1&lt;input onkeyup="this.value=this.value.replace(/\D/g,'')" onafterpaste="this.value=this.value.replace(/\D/g,'')"&gt; 数字和小数点(1) 12&lt;input onkeyup="if(isNaN(value))execCommand('undo')" onafterpaste="if(isNaN(value))execCommand('undo')"&gt;&lt;input name=txt1 onchange="if(/\D/.test(this.value))&#123;alert('只能输入数字');this.value='';&#125;"&gt; 数字和小数点(2) 1&lt;input type=text t_value="" o_value="" onkeypress="if(!this.value.match(/^[\+\-]?\d*?\.?\d*?$/))this.value=this.t_value;else this.t_value=this.value;if(this.value.match(/^(?:[\+\-]?\d+(?:\.\d+)?)?$/))this.o_value=this.value" onkeyup="if(!this.value.match(/^[\+\-]?\d*?\.?\d*?$/))this.value=this.t_value;else this.t_value=this.value;if(this.value.match(/^(?:[\+\-]?\d+(?:\.\d+)?)?$/))this.o_value=this.value" onblur="if(!this.value.match(/^(?:[\+\-]?\d+(?:\.\d+)?|\.\d*?)?$/))this.value=this.o_value;else&#123;if(this.value.match(/^\.\d+$/))this.value=0+this.value;if(this.value.match(/^\.$/))this.value=0;this.o_value=this.value&#125;"&gt; 只能输入字母和汉字 1&lt;input onkeyup="value=value.replace(/[\d]/g,'') "onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[\d]/g,''))" maxlength=10 name="Numbers"&gt; 只能输入英文字母和数字,不能输入中文 12345 &lt;input onkeyup="value=value.replace(/[^\w\.\/]/ig,'')"&gt; ``` - 只能输入数字和英文 ```html &lt;input onKeyUp="value=value.replace(/[^\d|chun]/g,'')"&gt; 小数点后只能有最多两位(数字,中文都可输入),不能输入字母和运算符号: 1&lt;input onKeyPress="if((event.keyCode&lt;48 || event.keyCode&gt;57) &amp;&amp; event.keyCode!=46 || /\.\d\d$/.test(value))event.returnValue=false"&gt; 小数点后只能有最多两位(数字,字母,中文都可输入),可以输入运算符号: 1&lt;input onkeyup="this.value=this.value.replace(/^(\-)*(\d+)\.(\d\d).*$/,'$1$2.$3')"&gt; n个元素圆形布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;style&gt;.container&#123; position: relative; width: 600px; height: 600px; margin: 0 auto; border: 1px solid #f00;&#125;.box&#123; position: absolute; width: 50px; height: 50px; background: #eee; transform: translate(-50%, -50%);&#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; // 注，此方法的box可为n个 $(function () &#123; // 中心点横坐标 var ow = $('.container').width() / 2; // 中心点纵坐标 var ot = $('.container').height() / 2; // 起始角度 var start = 0; // 半径 var radius = 300; // 每一个box对应的角度 var avd = 360 / $('.box').length; // 每一个box对应的弧度 var ahd = avd * Math.PI / 180; // 设置每一个元素的位置 $(.box).each(function (index, element) &#123; $(this).css(&#123; 'left': Math.sin(ahd * index) * radius + ow, 'top': Math.cos(ahd * index) * radius + oh &#125;) &#125;) &#125;)&lt;/script&gt; 桌面弹窗【原生】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 判断浏览器是否支持“WebNotifications API”function justify_notifyAPI () &#123; if (window.Notification) &#123; // 支持 console.log('支持： WebNotifications API'); &#125; else &#123; console.log('不支持： WebNotifications API'); &#125;&#125;// 浏览器是否支持弹出实例function justify_showMsg () &#123; if (window.Notification &amp;&amp; Notification.permission !== 'undefined') &#123; Notification.requestPermission(function (status) &#123; if (status === 'granted') &#123; var n = New Notification('收到消息:-O', &#123; body: '这是通知内容', icon: 'imgUrl' &#125;) &#125; else &#123; var n = new Notification('baby, i'll leave u'); &#125; &#125;) &#125;&#125;// 实例展示弹出内容function otification_construct () &#123; var notification = new Notification('收到新邮件', &#123; body: '您有一封来自马来西亚🇲🇾的新邮件', dir: 'auto', lang: 'zh-CN', tag: 'a1', icon: 'imgUrl' &#125;); console.log(notification.title); // 收到新邮件 console.log(notification.body); // 您有一封...&#125;// Notifications API的相关事件function otification_event () &#123; var MM = new Notification('新消息', &#123; body: '一条来自越南🇻🇳的留言', icon: 'imgUrl' &#125;); // 查看信息 MM.onshow = function () &#123; window.open('index.html'); // 打开首页 MM.close(); // 关闭桌面弹窗 &#125;; // 报错处理 MM.onerror = function () &#123; console.log('Notification have be click'); MM.close(); &#125;&#125; jQuery阻止重复加载123$('#btn').off('click').on('click', function () &#123; // ...&#125;) jQuery平缓滑动至顶部123456789101112131415161718// 点击返回顶部按钮平缓滑到顶部$('#top').on('click',function () &#123; $('html, body').animate( &#123;scrollTop: 0,&#125;, &#123;duration: 500,easing: 'swing'&#125; ); return false&#125;)// 绑定页面滚动事件$(window).bind('scroll', function () &#123; var t = $(this).scrollTop(); if(t &gt; 100) &#123; $('#top').fadeIn(1000); &#125; else &#123; $('#top').fadeOut(1000); &#125;&#125;) jQuery平缓滑倒自定义位置12345678$('.box').on('click', '.link', function () &#123; var linkAdd = $(this).attr('data'); $('html, body').animate( &#123;scrollTop: $(`#$&#123;linkAdd&#125;`).offset().top - 71 + 'px'&#125;, &#123;duration: 500, easing: 'swing'&#125;; ) return false&#125;) 全屏/取消全屏【原生】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div style="margin:0;height: 100vh;width:100vw; background:#900;overflow: hidden;"&gt; &lt;button id="btn"&gt;js控制页面的全屏展示和退出全屏显示&lt;/button&gt; &lt;div id="content" style="width: 100%;height: 100%;background-color: #00ee00;"&gt; &lt;div&gt;这个div的父级下是可以全屏显示的内容&lt;/div&gt; &lt;button onclick="exitFull()"&gt;js控制页面的退出全屏显示&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;document.getElementById("btn").onclick=function()&#123; var elem = document.getElementById("content"); requestFullScreen(elem);// 某个页面元素 //requestFullScreen(document.documentElement);// 整个网页&#125;;function requestFullScreen(element) &#123; // 判断各种浏览器，找到正确的方法 var requestMethod = element.requestFullScreen || //W3C element.webkitRequestFullScreen || //Chrome等 element.mozRequestFullScreen || //FireFox element.msRequestFullScreen; //IE11 if (requestMethod) &#123; requestMethod.call(element); &#125; else if (typeof window.ActiveXObject !== "undefined") &#123;//for Internet Explorer var wscript = new ActiveXObject("WScript.Shell"); if (wscript !== null) &#123; wscript.SendKeys("&#123;F11&#125;"); &#125; &#125;&#125;//退出全屏 判断浏览器种类function exitFull() &#123; // 判断各种浏览器，找到正确的方法 var exitMethod = document.exitFullscreen || //W3C document.mozCancelFullScreen || //Chrome等 document.webkitExitFullscreen || //FireFox document.webkitExitFullscreen; //IE11 if (exitMethod) &#123; exitMethod.call(document); &#125; else if (typeof window.ActiveXObject !== "undefined") &#123;//for Internet Explorer var wscript = new ActiveXObject("WScript.Shell"); if (wscript !== null) &#123; wscript.SendKeys("&#123;F11&#125;"); &#125; &#125;&#125;&lt;/script&gt; select多选传值12345678910// 选中selected的所有项var all = $('#qwsType:selected');// 建立数组var arr = [];// 遍历all.each(function () &#123; arr.push($(this).val());&#125;)// 数组转字符串var str = arr.join('/') jQuery阻止事件冒泡和默认行为1234btn.click(function(e)&#123; e.stopPropagation(); e.preventDefault();&#125;) form提交格式问题1234567// $('#form').serialize(); // form表单所有的值// 转换对象格式var data = &#123;&#125;;$('#form').serializeArray().map(function (x) &#123; data[x.name] = x.value;&#125;) find找子元素1234let name = $('#div').find("option[value='ZTO']");if (name) &#123; name.attr('select','selected');&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端技巧——css篇]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94css%E7%AF%87%2F</url>
    <content type="text"><![CDATA[CSS篇 去掉type=number的箭头12345678910input::-webkit-outer-spin-button,input::-webkit-inner-spin-button&#123; -webkit-appearance: none;&#125;input[type="number"]&#123; -moz-appearance: textfield;&#125;input&#123; -webkit-user-select: text !important; -webkit-tap-hightlight-color: rgba(0,0,0,0);&#125; 绝对居中1234567891011121314151617/* 1 */.father&#123; position: absolute; top: 50%; left: 50%;&#125;.son&#123; transform: translate(-50%, -50%);&#125;/* 2 */.father&#123; position: absolute; display: flex; justify-content; align-items: center;&#125; css媒体查询123456789101112131415161718192021222324252627282930313233343536373839404142/*自适应尺寸*/@media screen and (max-width: 360px) &#123; html &#123; font-size: 10px; &#125;&#125;@media (min-width: 361px) and (max-width: 420px) &#123; html &#123; font-size: 11px; &#125;&#125;@media (min-width: 421px) and (max-width: 480px) &#123; html &#123; font-size: 12px; &#125;&#125;@media (min-width: 481px) and (max-width: 540px) &#123; html &#123; font-size: 13px; &#125;&#125;@media (min-width: 541px) and (max-width: 640px) &#123; html &#123; font-size: 14px; &#125;&#125;@media (min-width: 641px) and (max-width: 750px) &#123; html &#123; font-size: 15px; &#125;&#125;@media screen and (min-width: 751px) &#123; html &#123; font-size: 20px; &#125;&#125; iOS去除点击阴影1-webkit-tap-highlight-color: rgba(0,0,0,0) css滚动条样式123456789101112131415161718192021222324252627282930/*1*/.progress1 ul&#123;height:50px;overflow:auto;&#125;.progress1 ul::-webkit-scrollbar &#123;/*滚动条整体样式*/ width: 4px; /*高宽分别对应横竖滚动条的尺寸*/ height:4px;&#125;.progress1 ul::-webkit-scrollbar-thumb &#123;/*滚动条里面小方块*/ border-radius: 5px; -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2); background:lightblue;&#125;.progress1 ul::-webkit-scrollbar-track &#123;/*滚动条里面轨道*/ -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2); border-radius: 0; background: rgba(0,0,0,0.1);&#125;/*2*/.modalBox .modalBody::-webkit-scrollbar &#123;/*滚动条整体样式*/ width: 6px; /*高宽分别对应横竖滚动条的尺寸*/ height:15px;&#125;.modalBox .modalBody::-webkit-scrollbar-thumb &#123;/*滚动条里面小方块*/ background:rgba(89,126,247,0.2); border-radius: 2px;&#125;.modalBox .modalBody::-webkit-scrollbar-track &#123;/*滚动条里面轨道*/ border-radius: 0; background:#fff;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《小王子》随笔]]></title>
    <url>%2F2019%2F07%2F16%2F%E3%80%8A%E5%B0%8F%E7%8E%8B%E5%AD%90%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[也许世界上也有五千朵和你一模一样的花，但只有你是我独一无二的玫瑰。 简介 &emsp;&emsp;小王子 （法国儿童文学短篇童话）是法国作家安托万·德·圣·埃克苏佩里于1942年写成的著名儿童文学短篇小说。本书的主人公是来自外星球的小王子。书中以一位飞行员作为故事叙述者，讲述了小王子从自己星球出发前往地球的过程中，所经历的各种历险。作者以小王子的孩子式的眼光，透视出成人的空虚、盲目，愚妄和死板教条，用浅显天真的语言写出了人类的孤独寂寞、没有根基随风流浪的命运。同时，也表达出作者对金钱关系的批判，对真善美的讴歌。 内容 &emsp;&emsp;小说叙述者是个飞行员，他在故事一开始告诉读者，他在大人世界找不到一个说话投机的人，因为大人都太讲实际了。&emsp;&emsp;接着，飞行员讲了六年前他因飞机故障迫降在撒哈拉沙漠遇见小王子故事。神秘的小王子来自另一个星球。飞行员讲了小王子和他的玫瑰的故事。小王子为什么离开自己的星球；在抵达地球之前，他又访问过哪些星球。他转述了小王子对六个星球的历险，他遇见了国王、爱虚荣的人、酒鬼、商人、点灯人、地理学家、蛇、三枚花瓣的沙漠花、玫瑰园、扳道工、商贩、狐狸以及我们的叙述者飞行员本人。&emsp;&emsp;飞行员和小王子在沙漠中共同拥有过一段极为珍贵的友谊。当小王子离开地球时，飞行员非常悲伤。他一直非常怀念他们共度的时光。他为纪念小王子写了这部小说。 随笔 语录 也许世界上也有五千朵和你一模一样的花，但只有你是我独一无二的玫瑰。 现代生活最病态的特征：理性化——试图用客观的标准体系来界定和衡量主观的价值意义。 仪式是什么？它使得某个日子区别于其他日子，某个时刻不同于其他的时刻。 那些人，他们坐在特快车里，却不知道他们要追寻什么。所以他们很烦躁，不停的绕圈子。 人总是对自己所处的地方不满意。 只有用心灵才能看得清事物本质，真正重要的东西是肉眼无法看见的。 语言是误解的根源。 生活才不是生命荒唐的编号，生活的意义在于生活本身。 审判自己比审判别人难多了。如果你成功地正确审判了自己，那么你就是一个真正的智者了。 如果你爱上了某个星球的一朵花。那么，只要在夜晚仰望星空，就会觉得漫天的繁星就像一朵朵盛开的花。 人们早已忘记了这个道理。可是你不应将它遗忘。你必须永远对自己所驯服的东西负责。你要对你的玫瑰花负责。 正因为你在你的玫瑰上花费了很多时间，你的玫瑰才变得如此重要。 大人自己什么都不懂，总是要小孩来给他们解释，这让我觉得很累。 随笔&emsp;&emsp;读这本书很快。大概总共用了不到一下午时间，因为故事很短。但是读完后也是久久难以释怀。&emsp;&emsp;这本书作为一本“童话”书，作为一个成年人，读起来却引人深思。小王子路过种种星球，来到地球。在地球驯化了狐狸，遇到了毒蛇……在与狐狸的“交往”中，狐狸说，语言是误解的根源，所以你不要跟我说话，只要坐在我旁边，然后每天离我更近一点，这样我就会一天天被你驯化。那么为什么要驯化呢？原文↓： &emsp;&emsp;狐狸对小王子说：“你看到那边的麦田了吗？我不吃面包，麦子对我来说，一点用也没有。我对麦田无动于衷。这真让人扫兴。可你有着金黄色的头发。那么，一旦你驯服了我，就美妙极了。金黄色的麦子会使我想起你。而且，我还会喜欢上风吹过麦浪的声音……” &emsp;&emsp;在小王子继续前行，将要离别之时： “啊！”狐狸说：”我会哭的。”“是你的错，”小王子說：”我从没过要伤害你，但你想让我驯服你⋯⋯”“是的。”狐狸說。“但你要哭了！”小王子說。“是的。”狐狸說。“那你什么好处也没得到！”“我得到了，”狐狸說：”因为那麦田的颜色。” &emsp;&emsp;而作为成年人，我们却难以做到如此心态。面对机会，我们总是思前虑后，然后让其在指缝间流逝。因为害怕结束，所以拒绝开始。而经历过的人才懂得，曾经拥有过才是幸福的。人生中难免有诸多遗憾，但最遗憾的，绝非是遗憾做了什么，而是遗憾没有做什么。&emsp;&emsp;“你这儿的人，在一个花园里种满五千朵玫瑰，却没能从中找到自己要的东西。”小王子只有一朵玫瑰，而我们可能有许多玫瑰。但是因为他有一朵，并且在其身上投放了时间、精力与陪伴，因此它的玫瑰显得与众不同。而我们，拥有就是拥有，不知道珍惜，那无论对于谁拥有，都是一样的。珍惜现在，珍惜眼前。&emsp;&emsp;最后谈一下毒蛇。这个角色的设计也绝不随手出来的。在小王子将要离开地球，返回自己星球的时候，说道，路途遥远，只能放弃自己的躯壳，因为带着躯壳是无法回去的。前文像王子与毒蛇接触的时候，发现毒蛇也是“好心肠”的，并非突兀的直接咬死小王子。并且最后小王子让毒蛇咬死自己，也是在讲述一个道理：想要追寻，必要付出。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>小王子</tag>
        <tag>读书笔记</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Vue-cli3.x踩坑记录]]></title>
    <url>%2F2019%2F07%2F10%2FMac-Vue-cli3-x%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前沿&emsp;&emsp;随vue技术逐渐成熟，开发者们热爱的脚手架vue-cli也一步步升级优化。在体验度不断上升的过程中，也必不可少的要踩一些坑。&emsp;&emsp;本篇主要记录下在vue-cli2.x升级到3.x以及用Mac系统的踩坑记录。 一、安装问题1. 升级node此过程只需要升级新版本node即可。 2. 安装vue-cli 3执行npm install -g @vue/cli 3. 创建新项目sudo vue create andin 备注：在Mac系统执行过程中，会产生系列报错问题，一般情况下时权限不足不可创建。 4. 新建文件失败在项目内，无论新建什么文件，都会报错提示无法新建。【无此问题的可忽略此步。】解决方案是打开可读写的权限。打开终端，cd到该项目目录下，执行如下：sudo chown -R username /Users/****** username 代表Mac的用户名 /Users/** 代表项目路径 二、配置问题1. 安装系列依赖 axios：交互 qs：数据格式 echarts：图表，数据可视化 px2rem：自适应解决方案 … 2. vue.config.js 配置配置vue.config.js，解决系列问题。如基本路径、打生产包去除.map文件、代码压缩等。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const path = require(&apos;path&apos;);const resolve = dir =&gt; path.resolve(__dirname, dir);// 去除consoleconst UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);// 压缩css、jsconst CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;);// 要压缩的文件const productionGzipExtensions = [&apos;js&apos;, &apos;css&apos;];const env = process.env.NODE_ENV;module.exports = &#123; // 基本路径配置，解决打包路径问题 publicPath: &apos;./&apos;, configureWebpack: (config) =&gt; &#123; // 如果不是开发环境 if (env !== &apos;development&apos;) &#123; // 代码压缩 config.plugins.push(new CompressionWebpackPlugin(&#123; algorithm: &apos;gzip&apos;, test: new RegExp(`\\.($&#123;productionGzipExtensions.join(&apos;|&apos;)&#125;)$`), threshold: 10240, minRatio: 0.8, &#125;)); // 打包后清除断点和控制台打印 config.plugins.push( new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; drop_debugger: true, // 注释debugger drop_console: true, // 注释console pure_funcs:[&apos;console.log&apos;] // 移除console &#125;, &#125;, sourceMap: false, // 去除打包后生成的.map文件 parallel: true, &#125;), ); &#125; // 路径 config.resolve = &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &#125; &#125; &#125;, chainWebpack: config =&gt; &#123; // 字体自适应 config.module .rule(&apos;css&apos;) .test(/\.css$/) .oneOf(&apos;vue&apos;) .resourceQuery(/\?vue/) .use(&apos;px2rem&apos;) .loader(&apos;px2rem-loader&apos;) .options(&#123; remUnit: 37.5 &#125;); // 指定入口 es6转es5 // config.entry.app = [&apos;babel-polyfill&apos;, &apos;./src/main.js&apos;]; // 添加别名 config.resolve.alias .set(&apos;@&apos;, resolve(&apos;src&apos;)) .set(&apos;assets&apos;, resolve(&apos;src/assets&apos;)) .set(&apos;static&apos;, resolve(&apos;src/static&apos;)); &#125;,&#125; 3. runtime进行时如果是项目脚手架升级，那么其中需要格外注意的一点是runtime进行时会报错。报错信息如下：1You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 解决方案现给出三种： main.js修改 123456789101112131415// 原new Vue(&#123; el: &apos;#app&apos;, router, store, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;)// 修改为如下：new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&apos;#app&apos;) config配置 1234567config.resolve = &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &#125;&#125; 引入路径修改import Vue from &#39;vue&#39;修改为import Vue from &#39;vue/dist/vue.esm.js&#39;同理，在router配置的过程中，也改成以上路径即可。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《蜘蛛侠之英雄远征》随笔]]></title>
    <url>%2F2019%2F07%2F01%2F%E3%80%8A%E8%9C%98%E8%9B%9B%E4%BE%A0%E4%B9%8B%E8%8B%B1%E9%9B%84%E8%BF%9C%E5%BE%81%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[蜘蛛侠：英雄远征 &emsp;&emsp;《蜘蛛侠：英雄远征》在蜘蛛侠系列中比上一部更紧张，也更狠毒，汤姆·赫兰德所饰演的小孩英雄——尴尬又天真，浪漫又多变——非常生动，这是安德鲁·加菲尔德版彼得没做到过的。《蜘蛛侠：英雄远征》在灵魂上向托比·马奎尔版更近了一些。在结束时，这代蜘蛛侠真的找到了自己的强烈感受。《蜘蛛侠：平行宇宙》在前，有着漩涡般令人眩晕的想象力、游戏般的质感和暗门一样的感觉，《蜘蛛侠：英雄远征》则触碰到了漫威典型电影的每一个方面。这并不会让观众脱离这个真实世界。但从结果来看，这一步是走对了。 关于剧情&emsp;&emsp;小蜘蛛在结束大战灭霸之后，恢复到好邻居蜘蛛侠，普通学生彼得·帕克。全剧以假期团建（旅游）为切入点，小蜘蛛在青春迷茫期，一心想要追求表白自己喜欢的女孩米歇尔，在旅途中遭遇的种种。当然，从他拒接神盾局局长电话那一刻开始，就注定他的旅途不会平凡。&emsp;&emsp;首先在威尼斯遇到了水怪，协助神秘客KO掉此怪。接着在布拉格，遇到了四大怪中最强的火元素乖。再次协助神秘客，清理掉此怪。“顺利”刷怪完毕之后，神秘客约小蜘蛛去酒吧喝一杯，然后故事正式进入主线……&emsp;&emsp;作为钢铁侠下一代“传人”，小蜘蛛收到了礼物——“眼镜”。然后在清怪结束后，在神秘客带上眼镜那一刻，小蜘蛛动摇，仿佛觉得眼前的神秘客才应该是传承者。无可厚非，神秘客演技太棒，以至于如果不是剧情太过完美，还真的无法怀疑他的身份。可惜小蜘蛛一心只想撩妹，对神秘客百分信任，毫无察觉。&emsp;&emsp;在小蜘蛛和米歇尔两人约会过程中，无意间发现了“无人机”触发的特效，将剧情推入正题：神秘客有问题。之后便是受到一波又一波死亡威胁。在”越狱“之后，回到主战场，大战无人机，靠着“蜘蛛一机灵”打爆神秘客。至此，由于团建的每个地方都有威胁发生，团建活动也至此结束。 两个彩蛋1. 蜘蛛侠背锅&emsp;&emsp;小蜘蛛和女友约会，一波极限飞行走位操作之后，与女友分别之时，路口电视大屏幕的新闻播放：无人机由小蜘蛛控制，并且试图对人类造成威胁，而神秘客是为阻止蜘蛛侠而死。小蜘蛛强行背锅。 2. 神盾局局长&emsp;&emsp;神盾局局长在开车时，显露原型——斯克鲁人。而真正的神盾局却在斯克鲁群中远程听报告，享受生活…… 随笔&emsp;&emsp;小蜘蛛接过漫威接力棒。整部剧中，有小蜘蛛成长的迷茫，恋爱的酸甜以及责任的承担，也从好邻居小蜘蛛逐渐成长起来。在飞机上改装战衣的时候，颇有钢铁侠的影子，想来也是致敬。从前，就表示要成为钢铁侠那样的人，而钢铁侠也表示：“你要成为比我更优秀的人。”&emsp;&emsp;在场景中，有几个镜头还是很有看点：首先是全息影像暴揍小蜘蛛，镜头感染力很足，虐心但也精彩；改装战衣，颇有托尼风范；大战无人机，镜头感十足；最后彩蛋，很棒，十分钟值得等。&emsp;&emsp;另，全剧127分钟，加上之前漫威系列电影，总长3000分钟，意味着什么想必不用多说。嗯，i love you three thousand.]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>电影</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《月亮与六便士》随笔]]></title>
    <url>%2F2019%2F06%2F18%2F%E3%80%8A%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[追逐梦想就是追逐自己的厄运，在满地都是六便士的街上，他抬起头看到了月光。 简介 &emsp;&emsp;《月亮与六便士》是英国小说家威廉· 萨默赛特·毛姆的创作的长篇小说，成书于1919年。&emsp;&emsp;作品以法国印象派画家保罗·高更的生平为素材，描述了一个原本平凡的伦敦证券经纪人思特里克兰德，突然着了艺术的魔，抛妻弃子，绝弃了旁人看来优裕美满的生活，奔赴南太平洋的塔希提岛，用圆笔谱写出自己光辉灿烂的生命，把生命的价值全部注入绚烂的画布的故事。&emsp;&emsp;贫穷的纠缠，病魔的折磨他毫不在意，只是后悔从来没有光顾过他的意识。作品表现了天才、个性与物质文明以及现代婚姻、家庭生活之间的矛盾，有着广阔的生命视角，用散发着消毒水味道的手术刀对皮囊包裹下的人性进行了犀利地解剖，混合着看客讪笑的幽默和残忍的目光。 作者&emsp;&emsp;作者依然是毛姆(英国小说家威廉· 萨默赛特·毛姆)，我也是读了书才知道的。上次读的《面纱》，依旧目前还未读的《人性的枷锁》，都是偶然买的，没想到作者是同一人。&emsp;&emsp;毛姆的家庭不太美满。从小父母双亡，而后自身条件也不太好，身材矮小、口吃等，经常受到欺负，以至于后来在心灵上的创伤以及性格的孤僻和内向。他的婚姻状况也不太美满，可能由于需要创作，冷落妻子时有发生。当然最后也导致了婚姻的裂变。他年少从医，后来参加过世界大战，也周游列国，被誉为“世界旅行家”。 佳句关于理想 世界上只有少数人能够最终达到自己的理想。 满地都是六便士，他却抬头看见了月亮。 月亮是头顶上的理想，而现实是脚下的六便士。只顾着捡便士容易忘记抬头看看月光，他们不容易理解追月的人。但如果你选择追月，渐渐地你就会飞起来啦。 关乎爱情 爱让一个人比原来的自己更丰富，同时又更贫乏。 为什么漂亮的女人总嫁给无趣的男人？因为有脑子的男人不娶漂亮女人。 她只差一点儿就称得起是个美人，但是正因为就差这一点儿，却连漂亮也算不上了。 女人们不断为了爱情而自寻短见，但是一般来说她们总是做得很小心，不让自杀成为事实。通常这只是为了引起她们情人的怜悯或者恐怖而做的一个姿态。 男人同女人的区别是：女人能够整天整夜谈恋爱，而男人却只能有时有晌儿地干这件事。 爱情要占据一个人莫大的精力，它要一个人离开自己的生活专门去做一个爱人。 关于社会人情 老是诉说自己的不幸，人们很快就会厌烦，总是摆着一副可怜相也不会讨人喜欢。 安之若素的外表下分明有某些截然相反的戏剧性东西。 那时警句、格言还没有完全被笨拙的人拿来附庸风雅，交谈中突然冒出几句，立刻显得妙趣横生。 文明社会这样消磨自己的心智，把短促的生命浪费在无聊的应酬上实在令人莫解。 文明人践行一种奇怪的才智，他们把短暂的生命，浪费在烦琐的事务上。 仿佛是从巴尔扎克笔下走出的老式人物，凭借着人性弱点赚钱的各色男女。 如果你不在乎某一个人对你的看法，一群人对你有什么意见又有什么关系？ 我们每个人生在世界上都是孤独的。每个人都被囚禁在一座铁塔里，只能靠一些符号同别人传达自己的思想，而这些符号并没有共同的价值，因此它们的意义是模糊的、不确定的……因此我们只能孤独地行走，尽管身体互相依傍却并不在一起，既不了解别人也不能为别人所了解。 随笔&emsp;&emsp;追逐梦想就是追逐自己的厄运，在满地都是六便士的街上，他抬起头看到了月光。 随想&emsp;&emsp;《月亮与六便士》小说时间线及内容相当明确，就是描述了斯特里克兰的一生，放弃了虽然平淡但是幸福的生活和家庭，孤身一人跑到巴黎去画画，要知道他毫无基础。而后生存艰难，对家人、朋友及认不认识的所有人都恶语相撞，对世俗毫不在乎，睡了朋友的妻子，导致最终朋友妻子自杀。然后继续颠沛流离，最终到一座小岛上，再度娶妻生子。而所有的磨砺，只为追寻原始的渴望，用绘画来表述。&emsp;&emsp;斯特里克兰是谁？主角。一个工薪族——证券经纪人，有这很是体面的工作，贤惠的妻子以及一个孩子。某年带着妻子及孩子去旅行，然后一夜之间，留下一封信，便只身去往了巴黎。家人亲戚朋友极其震惊，一致认为斯特里克兰是着了某个小妖精的道，拿钱跟小三私奔了。而真实情况是只身一人，住着寒酸的小旅馆，买了一些颜料及画板，开始了自己的绘画生涯。要知道，在此之前，画画只是他的一项爱好，并且毫无基础。然后，朋友劝阻，他却恶语相迎；朋友接济，他却睡了朋友的妻子，并且占了朋友的房子，直到朋友妻子自杀……基本上毫无人性！为了填饱肚子，为了买些颜料及画板，不得不去做小工，脏活累活无所畏惧，正常人难以忍受的饥寒、疾病，在他眼里却毫不在乎，甚至身体不适自己的，就像自己只是魔鬼，占据了一具凡人之躯而已。随着时间流逝，自己的作品也越来越得心应手，仿佛天生就是为了绘画而生。可一个人要想达到理想，那么只能迎着厄运而上。因此，世界上只有少数人能够达到自己的理想。&emsp;&emsp;在斯特里克兰声明的尽头，由于得了癌症，身体腐烂，行动受限。可这仿佛依然不是自己需要注意的地方，他只关心自己是否达成了理想。最终，自己在家里完成了一整副巧夺天工的画作。当医生想去救治他，为时已晚。可当医生走进他的房间，迎来的气味是恶臭，因为得了该病的人结果都是这样。但是看到的，确实一幅能让人迷失的画作，一幅原始与淫乱结合的画作。然后它还没面世，在斯特里克兰临终遗言里，让自己的妻子把房子烧掉，巨作也付之一炬。&emsp;&emsp;《月亮与六便士》，不如说是理想与现实，在如今物欲横流的社会中，仿佛没有钱，就会一事无成，活不出来滋味。极大多数情况下，真的是这样。其实现在每个人的心里都可能会有一种声音，属于自己的声音。当自己工作不顺心，感情、亲情都处于冰冻状态时，那个声音或许怂恿过自己，与现实冲突、唱反调，可无论自己做怎样的抉择，那个声音却始终相随。或许，它也是自己的理想代表。&emsp;&emsp;每个人都有理想。在平淡的生活中，可能偶尔也会想过为了理想任性一次，纯粹一次。所以有的人走了出去，不再畏惧世俗，不再担心没有六便士的生活。有的人却是“冷静”下来，将理想之火瞬间扑灭，如我，如你，如芸芸众生。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>读书笔记</tag>
        <tag>毛姆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[切换模块下划线跟随效果]]></title>
    <url>%2F2019%2F06%2F13%2F%E5%88%87%E6%8D%A2%E6%A8%A1%E5%9D%97%E4%B8%8B%E5%88%92%E7%BA%BF%E8%B7%9F%E9%9A%8F%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[效果 *&emsp;&emsp;经常看到一些网页的导航栏点击切换时，不仅改变当前样式，同时下划线会跟随鼠标点击的标签栏缓慢滑到相应位置，那么这个简单而又好看的效果是如何实现的呢？ 实现 环境/依赖 分析 代码 1. 环境/依赖 原生JavaScript / jQuery 2. 分析&emsp;&emsp;首先给出基本布局（如下）。html及css都是基础布局，active样式则是当点击某个li标签时动态添加即可。那么下划线我们如何处理呢？12345678910111213141516// html&lt;ul class=&quot;menu&quot;&gt; &lt;li&gt;Hey&lt;/li&gt; &lt;li&gt;ClickMe&lt;/li&gt; &lt;li&gt;I&apos;mIndex&lt;/li&gt; &lt;li&gt;AboutMe&lt;/li&gt; &lt;li&gt;MyCultureWall&lt;/li&gt;&lt;/ul&gt;// css&lt;style&gt; ul&#123;display: inline-block;text-align: center;padding: 0;position: relative;list-style: none;transition: all .4s ease-in;&#125; ul li&#123;display: inline-block;cursor: pointer;padding: 5px 10px;transition: all .5s ease-in;&#125; .active&#123;color: deepskyblue;transition: all .5s ease-in;&#125;&lt;/style&gt; &emsp;&emsp;第一反应肯定是使用border-bottom。如果仅仅是切换，那么它完全可以满足需求，但是前面我们提到了，要动起来，显然，border暂时还做不到这一步。&emsp;&emsp;此路不通，next one.如果我们用一个新的div来绑定到当前ul上，是否能满足需求呢？have a try.我在li标签同级增加一个div元素，给出一个定高不定宽的线段，宽度则跟随当前所点击的li标签走。然后定位在ul下方，这样视觉效果则是下划线位置。思路明确了，接下来要做的就是在js中来获取想要的宽度和定位左边距即可。 3. 代码12345678910111213141516171819202122232425262728293031// html&lt;ul class=&quot;menu&quot;&gt; &lt;li&gt;Hey&lt;/li&gt; &lt;li&gt;ClickMe&lt;/li&gt; &lt;li&gt;I&apos;mIndex&lt;/li&gt; &lt;li&gt;AboutMe&lt;/li&gt; &lt;li&gt;MyCultureWall&lt;/li&gt;++ &lt;div class=&quot;slider&quot;&gt;&lt;/div&gt;&lt;/ul&gt;// css&lt;style&gt; ul&#123;display: inline-block;text-align: center;padding: 0;position: relative;list-style: none;transition: all .4s ease-in;&#125; ul li&#123;display: inline-block;cursor: pointer;padding: 5px 10px;transition: all .5s ease-in;&#125; .active&#123;color: deepskyblue;transition: all .5s ease-in;&#125;++ .slider&#123;width: 0;height: 3px;position: relative;transition: all .5s ease-in;&#125;&lt;/style&gt;// js&lt;script&gt;$(&apos;.menu&apos;).on(&apos;click&apos;, &apos;li&apos;, function () &#123; // 获取所需要的 宽、左边距， 此处新增一个随机色 let liWidth = $(this).width(), offsetLeft = $(this).offset().left, color = `rgba($&#123;Math.floor(Math.random()*255)&#125;,$&#123;Math.floor(Math.random()*255)&#125;,$&#123;Math.floor(Math.random()*255)&#125;,0.9)`; // 点击时，当前标签添加active样式，‘下划线’也随之变化 $(this).addClass(&apos;active&apos;).siblings().removeClass(&apos;active&apos;); $(&apos;.slider&apos;).css(&#123;&apos;width&apos;: `$&#123;liWidth&#125;px`,&apos;left&apos;: `$&#123;offsetLeft&#125;px`,&apos;background&apos;: `$&#123;color&#125;`&#125;);&#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>下划线跟随</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秒懂——惹人烦恼的this指向]]></title>
    <url>%2F2019%2F06%2F11%2F%E7%A7%92%E6%87%82-%E6%83%B9%E4%BA%BA%E7%83%A6%E6%81%BC%E7%9A%84this%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[关于 This 它是JS关键字，在JS中具有特殊意义，代表一个空间地址； this是执行的主体，谁执行的这个函数谁就是this。 惹人烦恼的this&emsp;&emsp;This是什么？什么是this指针？this指针指向哪里？何时使用this？use or not use, that is a question.&emsp;&emsp;其中至关重要的this指向问题，不仅自身麻烦，而且各类层出不穷的相关面试题更是让人应接不暇。既然这么麻烦，难倒无数js开发er，我们到底要做怎样的挣扎才能记住呢？且听下回…哦不，且往下看。 THIS&emsp;&emsp;首先，我们介绍下关于this。 1. 什么是this指针？this指针指向哪里？何时使用this？ &emsp;&emsp;在JavaScript中，在创建函数时，系统默认会生成的两个隐式参数：this和arguments。函数执行时，自动生成的一个内部对象，只能在函数内部使用。this指针指向与该函数调用进行隐式关联的一个对象，该对象被称为“函数上下文”。this是js的一个关键字，随着函数使用场合不同，this的值会发生变化。&emsp;&emsp;this永远指向其所在函数的真实调用者（谁调用的就指向谁，）如果没有所有者时，指向全局对象window。 &emsp;&emsp;接着，我们来看一下常见函数调用方式 2. 常见函数调用方式 直接调用: 12345function fn (n) &#123; ...&#125;fn(n); 作为对象方法调用: 12345678var obj = &#123; a: 1, fn: function (n) &#123; ... &#125;&#125;obj.fn(n); call/apply 12345function fn (n)&#123; ...&#125;fn.call(context, n); 3. 变幻&emsp;&emsp;观察 2 中的几种常见方式，其实前几种都与最后一种密不可分。原因是前两种都是第三种方式的简写（语法糖）。当然，前两种方式也可以转变为第三种： fn(n) =&gt; fn.call(undefined, n) obj.fn(n) =&gt; obj.fn.call(obj, n) &emsp;&emsp;因此，我们函数调用归根就是一种：fn.call(context, n) 4. 结论&emsp;&emsp;可是我们总结以上，跟this有什么关系呢？其实答案已经呼之欲出了！context就是this所指向！当context为null或undefined时，也可省略不写，并且this指向window。那么这时我们再来看看，就发现this指向很是明了了。&emsp;&emsp; 当转换为标准写法时，this指向context。当context为null或undefined时，也可省略不写，并且this指向window。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this指向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电商放大镜及动态边框效果]]></title>
    <url>%2F2019%2F06%2F02%2F%E7%94%B5%E5%95%86%E6%94%BE%E5%A4%A7%E9%95%9C%E5%8F%8A%E5%8A%A8%E6%80%81%E8%BE%B9%E6%A1%86%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[序 &emsp;&emsp;大家在网购的时候一定没少用过此功能吧~某宝某猫某东，在PC端所有商品的展示均是如此：鼠标放在缩略图上，旁边便会有细节图展示出来，并随鼠标移动展示相应缩略图细节。下面我用js(jq)来展示一下，并且加入一丢丢的动态边框效果。 效果 环境及语言 html css js / jq 思路 放大镜 缩略图及细节图布局 鼠标划入事件：鼠标放在缩略图，出现小的蒙层和细节图；当鼠标移动，细节图随之变化 鼠标及蒙层边界判断处理 鼠标移除事件：隐藏蒙蒙层及细节图 动态边框 鼠标悬浮，边框出现 鼠标移除，边框消失那么问题来了，细节图怎么随鼠标变化？边框以何种形式展现？ 实现由浅入深，我先来实现动态边框 1. 动态边框效果 思路看到该效果，一般思路有二： 设置border 周边4个div &emsp;&emsp;但是以上两个思路均有问题。如果设置border，如何使其边框动画？如果周边设置4个div，那么不仅是需要js操控，并且无形之中增加了许多复杂度，与编程思想背道而驰。&emsp;&emsp;那么我们还有别的办法来处理使边框动起来吗？首先，动画是一定要有的。其次，如果不能用border，那么用background怎么样呢？just do it. 新属性 linear-gradient() 函数 inear-gradient函数作为css3新属性，用于创建一个线性渐变的“图像”。你还要定义终止色。终止色就是你想让Gecko去平滑的过渡，并且你必须指定至少两种，当然也会可以指定更多的颜色去创建更复杂的渐变效果。 代码1234567891011121314151617181920212223242526// html &lt;div class=&quot;transBorder&quot;&gt; here&lt;/div&gt;// css.transBorder &#123; margin: 0 15px; cursor: pointer; display: block; width: 200px; height: 200px; text-align: center; line-height: 200px; transition: ease-in .4s; background: linear-gradient(0, #108b96 2px, #009606 2px) no-repeat, linear-gradient(-90deg, #96645f 2px, #961478 2px) no-repeat, linear-gradient(-180deg, #869660 2px, #544996 2px) no-repeat, linear-gradient(-270deg, #439638 2px, #308e96 2px) no-repeat; background-size: 0 2px, 2px 0, 0 2px, 2px 0; background-position: left top, right top, right bottom, left bottom;&#125;.transBorder:hover &#123; border-radius: 20%; background-size: 100% 5px , 5px 100%, 100% 5px, 5px 100%;&#125; 2. 放大镜效果 思路 鼠标移入 显示蒙层及细节图 指定蒙层位置 为蒙层及细节图做相关计算，如蒙层中心、细节图走向等 鼠标及蒙层边界判断及处理 细节图展示及变化 鼠标移除 蒙层及细节图隐藏 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// html &lt;div class=&quot;small&quot;&gt; &lt;div id=&quot;small&quot;&gt; &lt;img src=&quot;./img/small.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt; &lt;div id=&quot;modal&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;big&quot;&gt; &lt;img src=&quot;./img/big.png&quot; alt=&quot;&quot; id=&quot;bigImg&quot;&gt;&lt;/div&gt;// css// ...略// js$(&apos;#small&apos;).mousemove((e) =&gt; &#123; // 显示大图区域 $(&apos;#big, #modal&apos;).fadeIn(500); // 指定蒙层位置，随鼠标变化 let x = e.clientX - $(&apos;#small&apos;).offset().left - $(&quot;#modal&quot;).width() / 2 + &apos;px&apos;; var y = e.clientY - $(&quot;#small&quot;).offset().top - $(&quot;#modal&quot;).height() / 2 + &apos;px&apos;; $(&apos;#modal&apos;).css(&#123;&apos;top&apos;: y, &apos;left&apos;: x&#125;); // 小图和蒙层的宽高差 let maxW = $(&apos;#small&apos;).width() - $(&apos;#modal&apos;).width(); let maxH = $(&apos;#small&apos;).height() - $(&apos;#modal&apos;).height(); // 蒙层距离小图边界值 var l = $(&apos;#modal&apos;).offset().left - $(&apos;#small&apos;).offset().left; // 蒙层距离左边界距离 var t = $(&apos;#modal&apos;).offset().top - $(&apos;#small&apos;).offset().top; // 蒙层距离上边界距离 // 边界判断 // 到达左边距 固定left if (l &lt; 0)&#123; $(&apos;#modal&apos;).css(&apos;left&apos;, &apos;0&apos;); &#125; // 到达上边距 固定top if (t &lt; 0)&#123; $(&apos;#modal&apos;).css(&apos;top&apos;, &apos;0&apos;); &#125; // 到达右边距 固定left if (l &gt;= maxW)&#123; $(&apos;#modal&apos;).css(&apos;left&apos;, maxW); &#125; // 到达下边距 固定top if (t &gt;= maxH)&#123; $(&apos;#modal&apos;).css(&apos;top&apos;, maxH); &#125; // 鼠标滑动轨迹及大图相应变化 let l1 = ($(&apos;#modal&apos;).offset().left - $(&apos;#small&apos;).offset().left) &lt; 0 ? 0 : ($(&apos;#modal&apos;).offset().left - $(&apos;#small&apos;).offset().left); let t1 = ($(&apos;#modal&apos;).offset().top - $(&apos;#small&apos;).offset().top) &lt; 0 ? 0 : ($(&apos;#modal&apos;).offset().top - $(&apos;#small&apos;).offset().top); let scaleX = (l1 / maxW) * ($(&apos;#big&apos;).width() - $(&apos;#bigImg&apos;).width()) + &apos;px&apos;; let scaleY = (t1 / maxW) * ($(&apos;#big&apos;).height() - $(&apos;#bigImg&apos;).height()) + &apos;px&apos;; $(&apos;#bigImg&apos;).css(&#123;&apos;left&apos;: scaleX,&apos;top&apos;: scaleY&#125;);&#125;).mouseleave(() =&gt; &#123; // 鼠标离开小图，大图消失 $(&apos;#big, #modal&apos;).fadeOut(500);&#125;)]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jquery</tag>
        <tag>电商放大镜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue弹窗屏蔽滑动的两种解决方案]]></title>
    <url>%2F2019%2F05%2F28%2Fvue%E5%BC%B9%E7%AA%97%E5%B1%8F%E8%94%BD%E6%BB%91%E5%8A%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[序&emsp;&emsp;在开发过程中，我们经常会遇到要加弹窗的需求，而如果当前页的展示数据一屏展示不完，则在打开弹窗后，有滑动操作时，页面也会随之滑动。那么如何处理这一问题呢？ 常见问题&emsp;&emsp;我们开发过程中，最常见的问题上文已叙述：打开弹窗后，有滑动操作时，页面也会随之滑动。问题示意图如下： 最终效果我们来看一波正确示范 解决方案&emsp;&emsp;两种解决方案，针对两种不同情况： 弹框数据少，无需滑动 弹框内数据需要滑动展示 1. 无需滑动弹窗a. 思路 思路：vue自带修饰符可解决该问题—— @touchmove.prevent 此方案重点在将@touchmove.prevent绑定到弹窗模块，然后动态控制弹窗显示隐藏即可。 b. 效果 c. 代码1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=&quot;modalTest&quot;&gt; &lt;!-- 按钮组 --&gt; &lt;div class=&quot;btn&quot;&gt; &lt;el-button type=&quot;success&quot; size=&quot;small&quot; @click=&quot;modalSign1 = true&quot;&gt;弹窗1&lt;/el-button&gt; &lt;/div&gt; &lt;!-- 背景数据 --&gt; &lt;div class=&quot;listBG&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in 50&quot;&gt;这是第&#123;&#123;item&#125;&#125;条背景数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 弹框1 --&gt; &lt;div class=&quot;modalBox&quot; v-if=&quot;modalSign1&quot; @touchmove.prevent @click.self=&quot;modalSign1 = false&quot;&gt; &lt;div class=&quot;modal&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in 8&quot;&gt;这是第&#123;&#123;item&#125;&#125;条数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; modalSign1: false, // 弹窗是否打开 &#125; &#125; &#125;&lt;/script&gt; 2. 弹框内数据需要滑动展示a. 思路&emsp;&emsp;首先，我们使用正常的vue操作，比如刚才的修饰符/语法糖进行操作时，虽然可以屏蔽掉背景数据滑动，但是该事件同时会将弹框内的滑动也阻止掉，我们则无法完成该需求。如果这个不行，我们还有别的方法来完成需求吗？&emsp;&emsp;我考虑到一种方案，但是属于DOM操作，与vue的初衷可能不太符合。不过此方案也不矢为一种能够有效解决问题的办法。 思路：利用cssposition: fixed以及top: x px来固定位置。步骤分解如下： 写一个样式放到公共css中备用； 点击按钮，控制弹窗显示隐藏； 两个方法，一个控制将步骤1写的css动态添加到body上，另外一个则控制移除该效果； 添加方法：①获取当前页面距离顶部高度，保存到data中；②给body添加步骤1的css；③设置body的高度为刚才获取到的高度。 移除方法： ①将刚才冬天给body添加的css移除；②当前滑动高度设置为data中存储的高度。 b. 效果 c. 两个案例完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;template&gt; &lt;div class=&quot;modalTest&quot;&gt; &lt;!-- 按钮组 --&gt; &lt;div class=&quot;btn&quot;&gt; &lt;el-button type=&quot;success&quot; size=&quot;small&quot; @click=&quot;modalSign1 = true&quot;&gt;弹窗1&lt;/el-button&gt; &lt;br&gt; &lt;el-button type=&quot;danger&quot; size=&quot;small&quot; @click=&quot;openModal&quot;&gt;弹窗2&lt;/el-button&gt; &lt;/div&gt; &lt;!-- 背景数据 --&gt; &lt;div class=&quot;listBG&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in 50&quot;&gt;这是第&#123;&#123;item&#125;&#125;条背景数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 弹框1 --&gt; &lt;div class=&quot;modalBox&quot; v-if=&quot;modalSign1&quot; @touchmove.prevent @click.self=&quot;modalSign1 = false&quot;&gt; &lt;div class=&quot;modal&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in 8&quot;&gt;这是第&#123;&#123;item&#125;&#125;条数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 弹框2 --&gt; &lt;div class=&quot;modalBox&quot; v-if=&quot;modalSign2&quot; @click.self=&quot;closeModal&quot;&gt; &lt;div class=&quot;modal&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in 20&quot;&gt;这是第&#123;&#123;item&#125;&#125;条数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; modalSign1: false, // 弹窗是否打开 modalSign2: false, // 弹窗是否打开 scrollTop: undefined, // 距离顶端的值 className: &apos;modalOpen&apos;, // 类名 &#125; &#125;, methods: &#123; // 打开弹层 要做的事 afterOpen () &#123; this.scrollTop = document.scrollingElement.scrollTop; document.body.classList.add(this.className); document.body.style.top = `-$&#123;this.scrollTop&#125;px`; &#125;, // 弹层关闭之前 要做的事 beforeClose () &#123; document.body.classList.remove(this.className); document.scrollingElement.scrollTop = this.scrollTop; &#125;, // 打开弹窗 openModal () &#123; this.modalSign2 = true; this.afterOpen(); &#125;, // 关闭弹窗 closeModal () &#123; this.modalSign2 = false; this.beforeClose(); &#125; &#125;, mounted() &#123; &#125; &#125;&lt;/script&gt;&lt;style type=&quot;text/scss&quot; lang=&quot;scss&quot; scoped&gt; .modalTest&#123; width: 100%; min-height: 100vh; overflow: scroll; .btn&#123; padding: 10px; position: fixed; top: 0; left: 0; z-index: 10; &amp;&gt;button&#123; margin: 10px 0; &#125; &#125; .listBG&#123; text-align: center; line-height: 50px; &#125; .modalBox&#123; width: 100vw; height: 100vh; overflow: hidden; position: fixed; top: 0; left: 0; background: rgba(0,0,0,0.4); z-index: 999; .modal&#123; width: 220px; height: 280px; overflow: scroll; background: #fff; border-radius: 10px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); -moz-box-shadow:10px 10px 9px #332A0D; -webkit-box-shadow:10px 10px 9px #332A0D; box-shadow:10px 10px 9px #332A0D; padding: 30px 0 0; ul&#123; text-align: center; li&#123; list-style: none; line-height: 30px; &#125; &#125; &#125; &#125; &#125;&lt;/style&gt; d. 备注.modalOpen的css样式，放在公共样式中，因为我们要改变的是body的样式，因此在组件中写的样式可能会失效。例如，我将样式放在了src/assets/css/common.css123456/*弹层*/body.modalOpen &#123; -webkit-overflow-scrolling:touch; position: fixed; width: 100%;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>弹窗</tag>
        <tag>滑动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中引入并使用markdown编辑器]]></title>
    <url>%2F2019%2F05%2F23%2Fvue%E4%B8%AD%E5%BC%95%E5%85%A5%E5%B9%B6%E4%BD%BF%E7%94%A8markdown%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[效果 开篇&emsp;&emsp;不知道各位是否对markdown熟悉。它算是一门标记语言，但是语法简单，却本领强大。例如本篇博客，便是用markdown语法编写，然后根据不同的环境及依赖生成各种我想要的样式，比如直接生成本篇博客样式或者使用一些依赖或者工具赋之更加美观的样式。同样，一般在CMS后台管理系统中，也经常会用到编辑器来编写一些文章材料。其中最常用的还是markdown编辑器和富文本编辑器。 Markdown 介绍1. 什么是Markdown&emsp;&emsp;首先，各位框架玩家一定不会陌生，因为无论是在各类框架下还是开源项目中，都会有一个.md的文件，该文件一般是项目说明文件，不仅语法简洁，而且所生成的“页面”也要比普通标记语言更加整洁明了。那么它到底是什么呢？&emsp;&emsp;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。&emsp;&emsp;Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 2. Markdown用途&emsp;&emsp;Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。&emsp;&emsp;用于编写说明文档，并且以“README.md”的文件名保存在软件的目录下面。除此之外，由于我们有了RStudio这样的神级编辑器，我们还可以快速将Markdown转化为演讲PPT、Word产品文档、LaTex论文甚至是用非常少量的代码完成最小可用原型。在数据科学领域，Markdown已经广泛使用，极大地推进了动态可重复性研究的历史进程。 vue 中如何使用注： 本示例选用的是mavon-editor很明显，所有组件逃不过三步走原则： 安装 引入、配置 使用 1. 安装安装mavon-editor:npm install mavon-editor --save 2. 引入、配置在要使用markdown编辑器的组件内操作：12345&lt;script&gt;// 导入组件 及 组件样式import &#123; mavonEditor &#125; from &apos;mavon-editor&apos;import &apos;mavon-editor/dist/css/index.css&apos;&lt;/script&gt; 3. 使用 注意： 绑定model 实时改变：将markdown实时转化为html 在要使用markdown编辑器的组件内操作:1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div&gt; &lt;mavon-editor v-model=&quot;content&quot; ref=&quot;md&quot; @change=&quot;change&quot; style=&quot;min-height: 600px&quot; /&gt; &lt;button @click=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // 注册 components: &#123; mavonEditor, &#125;, data() &#123; return &#123; content:&apos;&apos;, // 输入的markdown html:&apos;&apos;, // 及时转的html &#125; &#125;, methods: &#123; // 所有操作都会被解析重新渲染 change(value, render)&#123; // render 为 markdown 解析后的结果[html] this.html = render; &#125;, // 提交 submit()&#123; console.log(this.content); console.log(this.html); &#125; &#125;, mounted() &#123; &#125;&#125;&lt;/script&gt; 问题那么，在常用的操作里面，例如各级标题、表格、加粗加斜、标记、图文……图？此时，我们发现一个问题：如何添加本地图片呢？ Q在某些IDE里面使用markdown时，可以自由的插入本地图片，那我们在页面中使用此编译器组件如何添加图片呢？ A监听。没错，就是监听输入框变化。如果监听到有图片插入，那么我们可以先将图片上传至服务器，然后获取到线上url，拿到该url再插入到该位置。那么具体过程就很明显了： 选择本地图片，插入 监听到有图片插入 将该图上传至服务器 获取到服务器返回的图片url 将该线上url冬天插入到输入框中 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div class=&quot;markdown&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;mavon-editor v-model=&quot;content&quot; ref=&quot;md&quot; @imgAdd=&quot;$imgAdd&quot; @change=&quot;change&quot; style=&quot;min-height: 600px&quot;/&gt; &lt;button @click=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; mavonEditor &#125; from &apos;mavon-editor&apos; import &apos;mavon-editor/dist/css/index.css&apos; export default &#123; name: &quot;&quot;, props: [], components: &#123; mavonEditor, &#125;, data() &#123; return &#123; content:&apos;&apos;, html:&apos;&apos;, configs: &#123;&#125; &#125; &#125;, methods: &#123; // 将图片上传到服务器，返回地址替换到md中 $imgAdd(pos, $file)&#123; let formdata = new FormData(); this.$upload.post(&apos;/上传接口地址&apos;, formdata).then(res =&gt; &#123; console.log(res.data); this.$refs.md.$img2Url(pos, res.data); &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125;, // 所有操作都会被解析重新渲染 change(value, render)&#123; // render 为 markdown 解析后的结果[html] this.html = render; &#125;, // 提交 submit()&#123; console.log(this.content); console.log(this.html); this.$message.success(&apos;提交成功，已打印至控制台！&apos;); &#125; &#125;, mounted() &#123; &#125; &#125;&lt;/script&gt; 后&emsp;&emsp;到这里，vue中使用markdown编辑器教程结束。那么更为大众广泛使用的富文本编辑器如何使用呢？且看下回~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[520特辑———旋转爱]]></title>
    <url>%2F2019%2F05%2F20%2F520%E7%89%B9%E8%BE%91%E2%80%94%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E7%88%B1%2F</url>
    <content type="text"><![CDATA[序&emsp;&emsp;520：网络情人节是信息时代的爱情节日，定于每年的5月20日和5月21日。该节日源于歌手范晓萱的《数字恋爱》中“520”被喻成“我爱你” ，以及音乐人吴玉龙的网络歌曲中“我爱你”与“网络情人”的紧密联系。后来，“521”也逐渐被情侣们赋予了“我愿意、我爱你”的意思。“网络情人节”又被称为“结婚吉日”、“表白日”、“撒娇日”、“求爱节”。&emsp;&emsp;那么，作为程序员，如何通过专业技能向自己的另一半表达爱意呢？ 效果 技术栈 技术栈[及环境] 版本 vue-cli 3.x vue 2.x element-ui 2.x sass scss 实现分析 不难看出，页面分为三个部分：背景、旋转导航花瓣及弹框； 6个花瓣对应对个导航栏，每个导航栏颜色及打开弹窗的背景色相同； 弹窗共用，动态展示不同的弹窗内容区域及改变标题即可； 动画：这里动画均有原生css3的@keyframes完成，在animation里调用。 功能点 导航切换 旋转动画 走马灯（相册轮播） 标签切换（足迹中标签） table表格（说说） 时间轴（时刻） 弹幕效果（留言） 缩放效果（中心图片点击缩放） 项目一览项目结构如下：12345678910111213141516├── README.md // 项目说明├── babel.config // babel配置├── package.json // 包配置├── public│ ├── favicon.ico // 放在title前的页面logo│ └── index.html // 主页面├── src│ ├── assets│ │ ├── css // 自定义配置css│ │ └── love // 图片资源│ ├── love│ │ └── love.vue // 520主题组件│ ├── App.vue│ ├── router.js // 路由│ └── main.js // 主配置└── vue.config.js // vue自定义配置 其中，项目重点在love.vue组件中 功能点简述1. 导航及切换 首先，6个导航位，文字不同，icon不同；其次，点击菜单需要有旋转效果，菜单旋转缩小，弹框旋转放大展示；最后，判断/写入弹框卡片(下简称卡片)背景色。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// template 部分&lt;div class=&quot;leafs&quot;&gt; &lt;div v-for=&quot;(item, index) in menuList&quot; :key=&quot;item.name&quot; class=&quot;leaf&quot; @click=&quot;runCircle(item.name, index)&quot; :class=&quot;`leaf$&#123;index+1&#125;`&quot;&gt; &lt;img :src=&quot;item.url&quot; alt=&quot;&quot;&gt; &lt;span class=&quot;nameSpain&quot;&gt;&lt;i :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;!-- 小心心 --&gt; &lt;div class=&quot;heart&quot; :class=&quot;&#123;heartScale: heartScaleSign&#125;&quot; @click=&quot;heartScale&quot;&gt; &lt;img src=&quot;../assets/love/heart.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/div&gt;// script部分data() &#123; return &#123; show: false, runCircleSign: false, // 旋转变小 heartScaleSign: false, // 心 变大缩小 cardMiss: false, // 卡片动画消失 showCard: false, // 卡片显示状态 cardName: &apos;&apos;, // 卡片title cardChange: -1, //切换卡片 cardGround: &apos;&apos;, // 卡片背景色 menuList: [ &#123; url: require(&apos;../assets/love/leaf1.png&apos;), icon: &apos;el-icon-picture-outline&apos;, name: &apos;相册&apos; &#125;, &#123; url: require(&apos;../assets/love/leaf2.png&apos;), icon: &apos;el-icon-location&apos;, name: &apos;足迹&apos; &#125;, &#123; url: require(&apos;../assets/love/leaf3.png&apos;), icon: &apos;el-icon-edit&apos;, name: &apos;说说&apos; &#125;, &#123; url: require(&apos;../assets/love/leaf4.png&apos;), icon: &apos;el-icon-date&apos;, name: &apos;时刻&apos; &#125;, &#123; url: require(&apos;../assets/love/leaf5.png&apos;), icon: &apos;el-icon-news&apos;, name: &apos;留言&apos; &#125;, &#123; url: require(&apos;../assets/love/leaf6.png&apos;), icon: &apos;el-icon-printer&apos;, name: &apos;影集&apos; &#125; ], cardType: 0, menuIndex: -1, activeName: &apos;first&apos;, // 当前标签 &#125;&#125;,methods: &#123; // 菜单缩放 runCircle (name, index) &#123; let _this = this; // 缩放 this.runCircleSign = ! this.runCircleSign; this.menuIndex = index; // 赋值名称 this.cardName = name; // 显示卡片 this.showCard = true; // 卡片颜色 switch (index) &#123; case 0: _this.cardGround = &apos;rgba(129,15,175,0.4)&apos;; _this.cardType = 0; break; case 1: _this.cardGround = &apos;rgba(12,136,145,0.6)&apos;; _this.cardType = 1; break; case 2: _this.cardGround = &apos;rgba(255,235,45,0.6)&apos;; _this.cardType = 2; break; case 3: _this.cardGround = &apos;rgba(196,0,83,0.6)&apos;; _this.cardType = 3; break; case 4: _this.cardGround = &apos;rgba(87,174,157,0.6)&apos;; _this.cardType = 4; break; case 5: _this.cardGround = &apos;rgba(255,125,0,0.6)&apos;; _this.cardType = 5; break; &#125; &#125;, // 心 缩放 heartScale () &#123; this.heartScaleSign = ! this.heartScaleSign; &#125;, // 消失卡片 &amp;&amp; 菜单复原 backSign () &#123; let _this = this; _this.cardMiss = true; _this.runCircleSign = ! _this.runCircleSign; setTimeout(() =&gt; &#123; _this.showCard = false; _this.cardMiss = false; &#125;, 3000) &#125;,&#125;, 2. 弹幕效果 1.输入内容；2.循环展示；3.随即高度及标签颜色；4.利用本地存储持久化;5.动画漂移效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// template&lt;div class=&quot;haveWords&quot;&gt; &lt;!-- 展示内容 --&gt; &lt;div class=&quot;cont&quot;&gt; &lt;el-tag v-for=&quot;el in ku&quot; :key=&quot;el.id&quot; class=&quot;fly&quot; :type=&quot;el.type&quot; :style=&quot;&#123;top:el.top + &apos;px&apos;&#125;&quot; &gt; &#123;&#123; el.msg &#125;&#125; &lt;/el-tag&gt; &lt;/div&gt; &lt;!-- 输入内容 --&gt; &lt;div class=&quot;dealBox&quot;&gt; &lt;el-input type=&quot;textarea&quot; :autosize=&quot;&#123; minRows: 2, maxRows: 5&#125;&quot; placeholder=&quot;请输入留言&quot; v-model.trim=&quot;msg&quot; size=&quot;small&quot;&gt; &lt;/el-input&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; @click=&quot;sendData&quot;&gt;Biu~&lt;/el-button&gt; &lt;/div&gt;&lt;/div&gt;// scriptdata() &#123; return &#123; msg: null, //缓存 ku: JSON.parse(localStorage.kuArr), //存取数据 msgKu: [] &#125;&#125;,methods: &#123; // 弹幕 sendData () &#123; // 5中标签模式 let typeArr = [&apos;&apos;,&apos;success&apos;,&apos;info&apos;,&apos;warning&apos;,&apos;danger&apos;]; let localArr = this.ku; //判空 不为空则继续 为空则提示输入 if(this.msg !== &apos;&apos; &amp;&amp; this.msg !== null) &#123; let num1 = Math.random() * 500; let num2 = Math.random() * 5; let arrMark = Math.floor(num2); let top = Math.floor(num1); let obj = &#123;msg:this.msg,top:top,type:typeArr[arrMark]&#125;; localArr.push(obj); localStorage.kuArr = JSON.stringify(localArr); this.msg = &quot;&quot;; &#125; else &#123; this.$message.warning(&apos;要先输入哦~&apos;); &#125; &#125;,&#125;, &emsp;&emsp;别的功能点基本上都是element-ui中组件自带或基于组件开发的，熟悉element-ui的小伙伴应该极为熟悉。有感兴趣的朋友可自行去element-ui官网学习。element飞机票 后&emsp;&emsp;有对本demo感兴趣的或者想要作者源码的可以关注公众号流眸，回复“520源码”拿到代码哦~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js页面全屏]]></title>
    <url>%2F2019%2F05%2F13%2Fjs%E9%A1%B5%E9%9D%A2%E5%85%A8%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[需求 背景&emsp;&emsp;在做前端PC端项目中，我们经常会遇到让页面全屏的需求。大多情况下，这样可以使得用户在该页面更加专注，屏蔽掉该页面之外的干扰。 需求分析 状态判断 事件操作1. 状态判断首先，我们需要给出一个默认状态，即非全屏。然后，在此基础上我们进行DOM操作，每次用户进行操作时，我们先判断当前状态，进行相应的操作，操作过后改变当前状态即可。2. 事件操作注：下表中de代表document.documentElement 操作 浏览器 代码 全屏 W3C de.requestFullscreen() 全屏 CHROME de.webkitRequestFullScreen() 全屏 FIREFOX de.mozRequestFullScreen() 全屏 IE de.msRequestFullscreen() 还原 W3C document.exitFullscreen 还原 CHROME document.webkitCancelFullScreen 还原 FIREFOX document.mozCancelFullScreen 还原 IE document.msExitFullscreen 代码注： 本demo在vue中使用。如果使用正常.html，自行将@click转为正常点击事件(如onclick)即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445// html&lt;div @click=&quot;handleFullScreen&quot;&gt; 一个按钮&lt;/div&gt;// jsdata() &#123; return &#123; fullscreen: false // 是否全屏 &#125;&#125;,methods: &#123; // 全屏事件 handleFullScreen()&#123; let element = document.documentElement; // 判断是否已经是全屏 // 如果是全屏，退出 if (this.fullscreen) &#123; if (document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if (document.webkitCancelFullScreen) &#123; document.webkitCancelFullScreen(); &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if (document.msExitFullscreen) &#123; document.msExitFullscreen(); &#125; console.log(&apos;已还原！&apos;); &#125; else &#123; // 否则，进入全屏 if (element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if (element.webkitRequestFullScreen) &#123; element.webkitRequestFullScreen(); &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if (element.msRequestFullscreen) &#123; // IE11 element.msRequestFullscreen(); &#125; console.log(&apos;已全屏！&apos;); &#125; // 改变当前全屏状态 this.fullscreen = !this.fullscreen; &#125;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>全屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 3.x 打包白屏、清除console及IE白屏问题解决]]></title>
    <url>%2F2019%2F05%2F06%2Fvue-cli-3-x-%E6%89%93%E5%8C%85%E7%99%BD%E5%B1%8F%E3%80%81%E6%B8%85%E9%99%A4console%E5%8F%8AIe%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[问题 打包白屏 IE白屏 打包后清除控制台所有console信息 js\css压缩问题 解决问题1. 打包白屏描述npm run build打包后，生成dist文件夹。从该文件夹打开dist/index.html页面，发现页面空白，且控制台报错。原因是路径配置有问题。方案根目录打开/新建vue.config.js，配置路径：1234module.exports = &#123; // 基本路径配置 publicPath: &apos;./&apos;&#125; 重新打包验证，问题得以解决。 问题2. IE白屏描述在打包完成之后，如果是pc项目，或者移动端低版本兼容项目，则会有许多问题，其中白屏问题困扰着很多开发者，在安卓4.0、IE多个版本环境中体现的尤为别致。方案 下载相关插件 1npm install @babel/core @babel/plugin-transform-runtime @babel/preset-env es6-promise babel-polyfill --save-dev-dev 根目录新建文件.babelrc： 123456&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;], &quot;plugins&quot;: [ &quot;@babel/plugin-transform-runtime&quot; ]&#125; [注: 基于vue-cli 3.x] 修改根目录下的文件babel.config.js： 123456789101112131415161718192021222324// ... some other codes// 打包时删除consoleconst plugins = [];if ([&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV)) &#123; plugins.push(&quot;transform-remove-console&quot;)&#125;module.exports = &#123; presets: [ [ &apos;@vue/app&apos;, &#123; &quot;useBuiltIns&quot;: &quot;entry&quot;, polyfills: [ &apos;es6.promise&apos;, &apos;es6.symbol&apos; ] &#125; ] ], plugins: plugins&#125; 创建/修改根目录下的文件vue.config.js： 123456789module.exports = &#123; // 显式转义依赖 transpileDependencies: [&apos;webpack-dev-server/client&apos;], chainWebpack: config =&gt; &#123; // 指定入口 es6转es5 config.entry.app = [&apos;babel-polyfill&apos;, &apos;./src/main.js&apos;]; &#125;&#125; 入口引入相关插件src/main.js 1234// 解决ie白屏问题import &apos;@babel/polyfill&apos;import Es6Promise from &apos;es6-promise&apos;Es6Promise.polyfill() 重启服务/重新打包页面正常显示，控制台无报错信息。问题解决。 问题3. 打包后清除控制台所有console信息描述在开发环境中，我们调试过程中会添加些许的console.log或者debugger相关代码，来帮助我们完成开发。但是有时候此类代码太多或者马虎了，上线前没有删除干净，那么打包后生产环境中就会在控制台留下相关信息。那么为了避免这一不友好行为，我们采取插件来在打包时，清除所有打印信息。方案 安装插件 1npm install uglifyjs-webpack-plugin --save-dev 配置vue.config.js 1234567891011121314151617181920212223242526272829// 去除consoleconst UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);const env = process.env.NODE_ENV;module.exports = &#123; // ... other codes // 去除console configureWebpack: (config) =&gt; &#123; if (env !== &apos;development&apos; || env !== &apos;test&apos;) &#123; config.plugins.push( new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_debugger: true, // 注释console drop_console: true, pure_funcs:[&apos;console.log&apos;] // 移除console &#125;, &#125;, sourceMap: false, parallel: true, &#125;), ); &#125; &#125;,&#125; 重新打包配置完成后，重新打包npm run build，打开dist/index.html验证，console全部清除。 问题4. js\css压缩问题描述在打包成功后，为了缩小包体积，提高页面响应速度，一般会对包进行压缩，此处主要针对js\css来处理。方案 安装插件 1npm install compression-webpack-plugin --save-dev 配置vue.config.js中的configureWebpack 123456789101112131415// 压缩css、jsconst CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;);// 要压缩的文件const productionGzipExtensions = [&apos;js&apos;, &apos;css&apos;];configureWebpack: (config) =&gt; &#123; if (env !== &apos;development&apos; || env !== &apos;test&apos;) &#123; config.plugins.push(new CompressionWebpackPlugin(&#123; algorithm: &apos;gzip&apos;, test: new RegExp(`\\.($&#123;productionGzipExtensions.join(&apos;|&apos;)&#125;)$`), threshold: 10240, minRatio: 0.8, &#125;)); &#125;&#125; 重启服务完成陪之后重启服务/重新打包，处理完成，搞定收工！ 附赠这里附上基于vue-cli3的一些简单配置文件 vue.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124const path = require(&apos;path&apos;);const resolve = dir =&gt; path.resolve(__dirname, dir);// const IS_PROD = [&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV);// const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;// 去除consoleconst UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);// 压缩css、jsconst CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;);// 要压缩的文件const productionGzipExtensions = [&apos;js&apos;, &apos;css&apos;];// const productionGzipExtensions = /\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i;const env = process.env.NODE_ENV;module.exports = &#123; // 基本路径配置 publicPath: &apos;./&apos;, // 显式转义依赖 transpileDependencies: [&apos;webpack-dev-server/client&apos;], // 配置less css: &#123; loaderOptions: &#123; less: &#123; javascriptEnabled: true, &#125; &#125; &#125;, configureWebpack: (config) =&gt; &#123; if (env !== &apos;development&apos; || env !== &apos;test&apos;) &#123; config.plugins.push(new CompressionWebpackPlugin(&#123; algorithm: &apos;gzip&apos;, test: new RegExp(`\\.($&#123;productionGzipExtensions.join(&apos;|&apos;)&#125;)$`), threshold: 10240, minRatio: 0.8, &#125;)); config.plugins.push( new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_debugger: true, // 注释console drop_console: true, pure_funcs:[&apos;console.log&apos;] // 移除console &#125;, &#125;, sourceMap: false, parallel: true, &#125;), ); &#125; &#125;, chainWebpack: config =&gt; &#123; // 指定入口 es6转es5 config.entry.app = [&apos;babel-polyfill&apos;, &apos;./src/main.js&apos;]; // 修复HMR config.resolve.symlinks(true); // //修复 Lazy loading routes Error // config.plugin(&apos;html&apos;).tap(args =&gt; &#123; // args[0].chunksSortMode = &apos;none&apos;; // return args; // &#125;); // 添加别名 config.resolve.alias .set(&apos;@&apos;, resolve(&apos;src&apos;)) .set(&apos;assets&apos;, resolve(&apos;src/assets&apos;)) .set(&apos;static&apos;, resolve(&apos;src/static&apos;)); // //压缩图片 // config.module // .rule(&quot;images&quot;) // .use(&quot;image-webpack-loader&quot;) // .loader(&quot;image-webpack-loader&quot;) // .options(&#123; // mozjpeg: &#123;progressive: true, quality: 65&#125;, // optipng: &#123;enabled: false&#125;, // pngquant: &#123;quality: &quot;65-90&quot;, speed: 4&#125;, // gifsicle: &#123;interlaced: false&#125;, // webp: &#123;quality: 75&#125; // &#125;); // // 打包分析 // if (process.env.IS_ANALYZ) &#123; // config.plugin(&apos;webpack-report&apos;) // .use(BundleAnalyzerPlugin, [&#123; // analyzerMode: &apos;static&apos;, // &#125;]); // &#125; &#125;, // 是否使用包含运行时编译器的 Vue 构建版本 // runtimeCompiler: true, // 去除打包.map后缀文件 // productionSourceMap: false, // devServer: &#123;//跨域 // port: 8080,// 端口号 // open: true, //配置自动启动浏览器 // proxy: &#123;// 配置跨域处理 可以设置多个 // &apos;/api&apos;: &#123; // target: &apos;&apos;, // ws: true, // changeOrigin: true // &#125;, // &#125; // &#125;&#125; babel.config.js123456789101112131415161718192021222324252627282930// 打包时删除consoleconst plugins = [];if ([&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV)) &#123; plugins.push(&quot;transform-remove-console&quot;)&#125;module.exports = &#123; presets: [ [ &apos;@vue/app&apos;, &#123; &quot;useBuiltIns&quot;: &quot;entry&quot;, polyfills: [ &apos;es6.promise&apos;, &apos;es6.symbol&apos; ] &#125; ] ], // 配置babel-plugin-import, 用于按需加载组件代码和样式 plugins: [ [ &quot;import&quot;, &#123; libraryName: &quot;ant-design-vue&quot;, libraryDirectory: &quot;es&quot;, style: true &#125; ] ],&#125; .babelrc123456&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;], &quot;plugins&quot;: [ &quot;@babel/plugin-transform-runtime&quot; ]&#125; main.js123456789101112131415161718192021222324import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;import router from &apos;./router&apos;import store from &apos;./store&apos;// 解决ie白屏问题import &apos;@babel/polyfill&apos;import Es6Promise from &apos;es6-promise&apos;Es6Promise.polyfill()// 使用antd-vue Button组件import &#123; Button &#125; from &apos;ant-design-vue&apos;// Button组件Vue.component(Button.name, Button);Vue.config.productionTip = falsenew Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&apos;#app&apos;)]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3.x及相关配置]]></title>
    <url>%2F2019%2F05%2F05%2Fvue-cli3-x%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[vue-cli 3.x1.安装123npm install -g @vue/cli# ORyarn global add @vue/cli 2.环境(windows)1234567891011E:\stydy&gt;node -vv8.12.0E:\stydy&gt;webpack -v4.29.6E:\stydy&gt;npm -v6.4.1E:\stydy&gt;vue -V3.7.0 3.创建项目我在此处想使用ant-design-vue，所以创建了一个antd的项目：1vue create antd 4.项目配置我选择的项目配置如下：12345678Vue CLI v3.7.0? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors? Use history mode for router? (Requires proper server setup for index fallback in production) Yes? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Less? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files? Save this as a preset for future projects? No? Pick the package manager to use when installing dependencies: NPM 5.运行依赖安装完成后，cd到该项目路径下，运行：1234567891011$ cd antd $ npm run serveDONE Compiled successfully in 4229ms App running at: - Local: http://localhost:8080/ - Network: http://192.168.100.111:8080/ Note that the development build is not optimized. To create a production build, run npm run build. 此时浏览器会访问 http://localhost:8080/ ，看到 Welcome to Your Vue.js App 的界面就算成功了。 6.目录结构12345678910111213141516├── README.md├── babel.config├── package.json├── package-lock.json├── postcss.config.js├── public│ ├── favicon.ico│ └── index.html├── src│ ├── assets│ │ └── logo.png│ ├── components│ │ └── HelloWorld.vue│ ├── App.vue│ └── main.js└── .gitignore 使用ant-design-vue由于在实际开发工程中，加载全部样式/组件会影响前端性能，因此我们直接采取按需加载组件及样式。 1.安装123npm install ant-design-vue --save-devnpm install less less-loader --save-dev 2.引入src/main.js123// 以 Button 组件为例import &#123; Button &#125; from &apos;ant-design-vue&apos;Vue.component(Button.name, Button); 3.组件使用12345&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;a-button type=&quot;danger&quot;&gt;Danger&lt;/a-button&gt; &lt;/div&gt;&lt;/template&gt; 4.babel-plugin-import4.1安装1npm install babel-plugin-import --save-dev 4.2修改babel.config.js123456789101112module.exports = &#123; presets: [ &apos;@vue/app&apos;, ], // 配置babel-plugin-import, 用于按需加载组件代码和样式 plugins: [ [ &quot;import&quot;, &#123; libraryName: &quot;ant-design-vue&quot;, libraryDirectory: &quot;es&quot;, style: true &#125; ] ],&#125; 4.3报错解决方案此时重启项目，会遇到报错情况。以下两种方案任选其一即可。两种方案： 配置vue.config.js在根目录下新建vue.config.js： 12345678910module.exports = &#123; // 配置less css: &#123; loaderOptions: &#123; less: &#123; javascriptEnabled: true, &#125; &#125; &#125;,&#125; 修改babel.config.js 1234567// ...plugins: [ [ &quot;import&quot;, &#123; libraryName: &quot;ant-design-vue&quot;, libraryDirectory: &quot;es&quot;, style: &apos;css&apos; &#125; ]] 4.4完成保存，重启项目：1npm run serve 可以看到，antd 组件的 js 和 css代码都会按需加载。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《复联4之终局之战》随笔]]></title>
    <url>%2F2019%2F05%2F02%2F%E3%80%8A%E5%A4%8D%E8%81%944%E4%B9%8B%E7%BB%88%E5%B1%80%E4%B9%8B%E6%88%98%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;复仇者联盟4：终局之战（Avengers: Endgame）是安东尼·罗素和乔·罗素执导的美国科幻电影，改编自美国漫威漫画，漫威电影宇宙（Marvel Cinematic Universe，缩写为MCU）第22部影片，由小罗伯特·唐尼、克里斯·埃文斯、克里斯·海姆斯沃斯、马克·鲁法洛、斯嘉丽·约翰逊、杰瑞米·雷纳、保罗·路德、布丽·拉尔森、唐·钱德尔、凯伦·吉兰、乔什·布洛林等主演。 ###]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>电影</tag>
        <tag>复仇者联盟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js模拟信号灯]]></title>
    <url>%2F2019%2F04%2F29%2Fjs%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E7%81%AF%2F</url>
    <content type="text"><![CDATA[效果图 需求给出一个div元素块，模拟一个如下条件的交通信号灯： 绿灯亮x毫秒，转黄灯 黄灯亮y毫秒，转红灯 红灯亮z毫秒，转绿灯 无限循环执行 需求分析&emsp;&emsp;首先，div元素块设置css变圆；其次，每隔一定时间，转换元素块背景色；接着，控制显示时长；然后，将上两步组合；最后，无限循环执行。 应用技术栈 css border-radius background js setTimeout Promise async/await while 技术栈分析 类别 技术 用途 样式 border-radius 元素形状 样式 background 元素背景色 脚本 setTimeout 定时器 脚本 Promise 处理回调 脚本 async/await 配合使用 脚本 while 循环 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// html&lt;div id=&quot;signal-lamp&quot;&gt;&lt;/div&gt;&lt;button class=&quot;btn&quot; onclick=&quot;run()&quot;&gt;执行&lt;/button&gt;&lt;span id=&quot;showText&quot;&gt;&lt;/span&gt;// css#signal-lamp &#123; width: 100px; height: 100px; border-radius: 50%; border: 1px solid #ffcecc;&#125;// js// 定义函数sleepfunction sleep(ms)&#123; // 返回一个Promise实例 return new Promise(function(resolve)&#123; setTimeout(resolve, ms); &#125;)&#125;// 改变颜色 等待参数时间 （时间及颜色均为参数）async function ChangeColor(ms, color)&#123; // 改变颜色 document.getElementById(&quot;signal-lamp&quot;).style.background = color; // 打印出显示时间 document.getElementById(&quot;showText&quot;).innerText = `$&#123;color&#125;:显示$&#123;ms&#125;ms`; // 睡眠ms毫秒 await sleep(ms);&#125;// 循环依次执行async function run()&#123; // while 循环 while (true) &#123; // 绿灯 1.8s await ChangeColor(1800,&quot;green&quot;); // 黄灯 0.8s await ChangeColor(800, &quot;yellow&quot;); // 红灯 1.2s await ChangeColor(1200, &quot;red&quot;); &#125;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Promise</tag>
        <tag>信号灯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js执行——Promise]]></title>
    <url>%2F2019%2F04%2F28%2Fjs%E6%89%A7%E8%A1%8C%E2%80%94%E2%80%94Promise%2F</url>
    <content type="text"><![CDATA[Promise Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理且更强大。它最早由社区提出并实现，ES6将其写进了语言标准，统一了用法，并原生提供了Promise对象。 特点 对象的状态不受外界影响 （3种状态） Pending状态（进行中） Fulfilled状态（已成功） Rejected状态（已失败） 一旦状态改变就不会再变 （两种状态改变：成功或失败） Pending -&gt; Fulfilled Pending -&gt; Rejected 用法创建Promise实例123456789var promise = new Promise(function(resolve, reject)&#123; // ... some code if (/* 异步操作成功 */) &#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;) &emsp;&emsp;Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。&emsp;&emsp;resolve作用是将Promise对象状态由“未完成”变为“成功”，也就是Pending -&gt; Fulfilled，在异步操作成功时调用，并将异步操作的结果作为参数传递出去；而reject函数则是将Promise对象状态由“未完成”变为“失败”，也就是Pending -&gt; Rejected，在异步操作失败时调用，并将异步操作的结果作为参数传递出去。 then&emsp;&emsp;Promise实例生成后，可用then方法分别指定两种状态回调参数。then 方法可以接受两个回调函数作为参数： Promise对象状态改为Resolved时调用 （必选） Promise对象状态改为Rejected时调用 （可选） 基本用法示例123456function sleep(ms) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(resolve, ms); &#125;)&#125;sleep(500).then( ()=&gt; console.log(&quot;finished&quot;)); &emsp;&emsp;这段代码定义了一个函数sleep，调用后，等待了指定参数(500)毫秒后执行then中的函数。值得注意的是，Promise新建后就会立即执行。 执行顺序&emsp;&emsp;接下来我们探究一下它的执行顺序，看以下代码：12345678910let promise = new Promise(function(resolve, reject)&#123; console.log(&quot;AAA&quot;); resolve()&#125;);promise.then(() =&gt; console.log(&quot;BBB&quot;));console.log(&quot;CCC&quot;)// AAA// CCC// BBB &emsp;&emsp;执行后，我们发现输出顺序总是 AAA -&gt; CCC -&gt; BBB。表明，在Promise新建后会立即执行，所以首先输出 AAA。然后，then方法指定的回调函数将在当前脚本所有同步任务执行完后才会执行，所以BBB 最后输出。 与定时器混用&emsp;&emsp;首先看一个实例：123456789101112let promise = new Promise(function(resolve, reject)&#123; console.log(&quot;1&quot;); resolve();&#125;);setTimeout(()=&gt;console.log(&quot;2&quot;), 0);promise.then(() =&gt; console.log(&quot;3&quot;));console.log(&quot;4&quot;);// 1// 4// 3// 2 &emsp;&emsp;可以看到，结果输出顺序总是：1 -&gt; 4 -&gt; 3 -&gt; 2。1与4的顺序不必再说，而2与3先输出Promise的then，而后输出定时器任务。原因则是Promise属于JavaScript引擎内部任务，而setTimeout则是浏览器API，而引擎内部任务优先级高于浏览器API任务，所以有此结果。 拓展 async/awaitasync&emsp;&emsp;顾名思义，异步。async函数对 Generator 函数的改进，async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。特点体现在以下四点： 内置执行器 更好的语义 更广的适用性 返回值是 Promise await&emsp;&emsp;顾名思义，等待。正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象。 混合使用&emsp;&emsp;先看示例：123456789101112131415function sleep(ms) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(resolve,ms); &#125;)&#125;async function handle()&#123; console.log(&quot;AAA&quot;) await sleep(5000) console.log(&quot;BBB&quot;)&#125;handle();// AAA// BBB (5000ms后) &emsp;&emsp;我们定义函数sleep，返回一个Promise。然后在handle函数前加上async关键词，这样就定义了一个async函数。在该函数中，利用await来等待一个Promise。 Promise优缺点 优点 缺点 解决回调 无法监测进行状态 链式调用 新建立即执行且无法取消 减少嵌套 内部错误无法抛出]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
        <tag>Promise</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue吸顶效果]]></title>
    <url>%2F2019%2F04%2F26%2Fvue%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[关于吸顶 吸顶效果在使得用户在滑动读取数据的时候把产品需要持续展示的控件及信息一直固定在屏幕上方，以便用户操作和交互。 产生背景&emsp;&emsp;随着技术不断更新与用户审美不断提升，一些App中/浏览器中的常用交互也在对用户更加友好，在某些数据展示较多页面或者导航栏页面，为了将栏目划分，使得视图模块更加明显，吸顶效果便在此背景下孕育而生。&emsp;&emsp;那么，我们如何在web端来做一个吸顶效果呢？ 切入正题——吸顶简单效果展示 需求分析 有了效果图，首先我们要分析一下结构： 吸顶上方数据 需要吸顶的元素 吸顶下方数据 接着我们逻辑走一下：(我们设吸顶元素为X) 在页面滑动距离 &lt;= 吸顶元素距离顶端距离时，不吸顶 否则，吸顶 有了这个大前提，继续考虑，如何做到吸顶呢？ 设置该元素的position为fixed属性 动态控制是否展示该样式 扩展：加点动画效果(这里以渐变为示例) 代码及注释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// html&lt;template&gt; &lt;div class=&quot;scrollFixed&quot;&gt; &lt;!-- 上方数据 --&gt; &lt;div class=&quot;sTop&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(ietm, index) in 10&quot;&gt;这是吸顶上方的第&#123;&#123;index + 1&#125;&#125;条数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 吸顶元素 --&gt; &lt;nav class=&quot;nav&quot; id=&quot;searchBar&quot; :class=&quot;scrollFixed === true ? &apos;isFixed&apos; :&apos;&apos;&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/nav&gt; &lt;!-- 下方数据 --&gt; &lt;div class=&quot;sBottom&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(ietm, index) in 30&quot;&gt;这是吸顶下方的第&#123;&#123;index + 1&#125;&#125;条数据&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;// js&lt;script&gt; export default &#123; data() &#123; return &#123; text: &apos;需要吸顶&apos;, scrollFixed: false, offsetTop: 0 &#125; &#125;, methods: &#123; windowScroll () &#123; // 滚动条顶部 距 滚动原点的高度 let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; /** * 三目运算 * 两个高度比较 * 如果滑动距离 &gt; 吸顶元素到页面顶端距离 动态添加 */ scrollTop &gt;= this.offsetTop ? (this.scrollFixed = true, this.text = &apos;已吸顶&apos;) : (this.scrollFixed = false, this.text = &apos;需要吸顶&apos;); &#125; &#125;, mounted() &#123; // 需吸顶元素 距 离浏览器顶端的高度 this.offsetTop = document.querySelector(&apos;#searchBar&apos;).offsetTop; // 滚动监听 window.addEventListener(&apos;scroll&apos;, this.windowScroll); &#125;, destroyed () &#123; // 关闭 销毁监听 window.removeEventListener(&apos;scroll&apos;, this.windowScroll); &#125; &#125;&lt;/script&gt;&lt;style scoped type=&quot;text/scss&quot; lang=&quot;scss&quot;&gt;.isFixed&#123; position:fixed; top:0; left: 0; z-index:999; background: #12d168; transition: all 1s; color: #7511ff;&#125;// 基本样式略// ......&lt;/style&gt; 备注&emsp;&emsp;此demo在流行浏览器中运行问题不大，但是没有详测兼容性。如果要在生产上运用，务必做好各端兼容。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>吸顶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[v-html指令渲染出的内容如何添加样式]]></title>
    <url>%2F2019%2F04%2F22%2Fv-html%E6%8C%87%E4%BB%A4%E6%B8%B2%E6%9F%93%E5%87%BA%E7%9A%84%E5%86%85%E5%AE%B9%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[关于v-html&emsp;&emsp;在vue使用中，指令v-html渲染页面经常用到，类似于jQuery的$(‘x’).html()去渲染。通过指令v-html渲染出来的内容还会带有原来的标签及其样式，如果需要修改或者重设其样式，应该如何去做吗？ 采坑&emsp;&emsp;首先，我在style中用子级选择器去选中并修改样式，经过猛如虎的操作后，并没生效。F12打开Elements调试，发现在style里面样式根本没加载上去，没有class中也没有类名出现。除此之外，渲染非该指令元素时，所有的类名会跟有[data-v-xxxxxx]的东西。 爬坑解决方案现给出3中方案来解决此问题： 去掉style中的scoped; watch监测数据变化; 深度选择器&gt;&gt;&gt; 方案1实践 去掉style中的scoped &emsp;&emsp;在vue组件中，我们写style时，为了防止页面样式冲突，在每个组件中会加上scoped属性。经测试，去掉该属性即可渲染样式成功。但是在组件过多或者项目中大时，经常会出现页面样式冲突，因此该方法不建议使用。 方案2实践 watch监测数据变化 &emsp;&emsp;在script &gt; export default中,watch属性可监听v-html所绑定值的变化。如果是后台请求的数据，那么可以在watch中监听改数据变化，当数据发生改变驱动视图后，动态绑定一个class来改变子级元素样式。此方法有一定局限性。 方案3实践 深度选择器 &gt;&gt;&gt; &emsp;&emsp;此时，深度选择器的应用则脱颖而出。深度选择器&gt;&gt;&gt;，可深度改变子级样式。例：12345678910111213&lt;template&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;// ***&lt;/script&gt;&lt;style scoped&gt; .test &gt;&gt;&gt; *&#123; width: 100%; &#125;&lt;/style&gt; &emsp;&emsp;如果使用scss或者less等css扩展语言，则用/deep/替代：1234567&lt;style scoped type=&quot;text/scss&quot; lang=&quot;scss&quot;&gt; .test&#123; /deep/ *&#123; width: 100%; &#125; &#125;&lt;/style&gt; tips&emsp;&emsp;scoped属性导致css仅对当前组件生效，而html绑定渲染出的内容可以理解为是子组件的内容，一般情况下子组件不会被加上对应的属性，所以不会应用带有scoped的css。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>样式渲染</tag>
        <tag>v-html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue嵌套路由]]></title>
    <url>%2F2019%2F04%2F20%2Fvue%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[关于嵌套路由&emsp;&emsp;在实际项目中，多个前端页面由于需求而通常由多层嵌套的组件组合而成,尤其是多导航界面。此时，路由嵌套(vue-router)的优点则表现了出来。嵌套路由就是在一个被路由过来的页面下，可以继续使用路由来加载新的组件。所谓嵌套，也可以理解成父子路由。 应用场景 各样式导航栏切换； 标签/选项卡切换； 案例&emsp;&emsp;此处以常用布局F形导航当作分析案例： 1.效果 2.解析12345678/App/about/blog /App/about/msg +------------------+ +-----------------+| about | | about || +--------------+ | | +-------------+ || | blog | | +------------&gt; | | msg | || | | | | | | || +--------------+ | | +-------------+ |+------------------+ +-----------------+ 3.目录拆分观察效果图，容易得出可将图拆分为多个组件。在主要vue中挂载首页和关于组件，然后在关于组件中再次挂载子路由博客和信息组件。项目中src目录拆分如下：1234567891011├── src │ ├── page │ │ ├── index.vue // 主页组件│ │ ├── about.vue // 关于组件│ │ ├── about │ │ │ ├── blog.vue // 博客子组件│ │ │ ├── msg.vue // 信息子组件│ ├── router │ │ ├── index.js │ ├── App.vue │ ├── main.js 4.通用代码从目录中可以轻易的看出每个组件及所代表的模块。其中，index &amp; blog &amp; msg 三个组件均为一个带文字描述的块级元素，此处给出一个示例，不再赘述。12345&lt;template&gt; &lt;div&gt; 这是xx模块内容 &lt;/div&gt;&lt;/template&gt; 5.路由管理router/index.js进行路由管理，代码如下。此处使用懒加载模式处理。开篇已经描述，嵌套路由可以理解为父子路由，不仅如此描述，事实上我们在做路由管理也是这么处理的。注：在children中的path不必再添加/，否则会出错。123456789101112131415161718192021222324252627import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;Vue.use(VueRouter)export default new VueRouter(&#123; routes: [ &#123; path: &apos;/index&apos;, component: resolve =&gt; require([&apos;@/page/index&apos;],resolve), &#125;, &#123; path: &apos;/about&apos;, component: resolve =&gt; require([&apos;@/page/about&apos;],resolve), children: [ &#123; path: &apos;blog&apos;, component: resolve =&gt; require([&apos;@/page/about/blog&apos;],resolve), &#125;, &#123; path: &apos;msg&apos;, component: resolve =&gt; require([&apos;@/page/about/msg&apos;],resolve), &#125; ] &#125;, ]&#125;) 6.根组件配置App.vue需要挂载首页组件和关于组件。值得一提的是，由于在点击关于的时候，应该直接跳往第一项子级项，也就是博客，因此注意路由路径。此外，切记to:”[路径]” 中的[路径]一定要加上/，否则多次路由会出现路由重复而无法正确找到路由问题。123456789101112131415161718192021&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;router-link to=&quot;/index&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/about/blog&quot;&gt;关于&lt;/router-link&gt; &lt;/header&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;App&apos;, &#125;&lt;/script&gt;&lt;style type=&quot;text/scss&quot; lang=&quot;scss&quot;&gt; /*略*/&lt;/stylle&gt; 7.about组件配置所谓嵌套，或者说父子路由，在此组件表现出来，也就是将此组件当成父组件，再次挂载两个(或多个)子组件。同样，要注意路径一定要加上/。如下：12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div class=&quot;about&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;router-link to=&quot;/about/blog&quot;&gt;博客&lt;/router-link&gt; &lt;router-link to=&quot;/about/msg&quot;&gt;信息&lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;about&quot; &#125;&lt;/script&gt;&lt;style scoped type=&quot;text/scss&quot; lang=&quot;scss&quot;&gt; .about&#123; display: flex; .left&#123; width: 100px; border-right: 1px solid #aaa; height: calc(100vh - 46px); display: flex; flex-direction: column; a&#123; line-height: 40px; text-align: center; font-size: 12px; text-decoration: none; color: #6260ff; &#125; &#125; .right&#123; flex: 1; &#125; &#125;&lt;/style&gt; 8.完成其实步骤就这么多，不过在实际项目中还是要多加动脑灵活运用，理解嵌套路由含义及路由配置规则，一切就会变得简单起来~ 注&emsp;&emsp;有几点注意事项，包括上面也有提到过： 子路由要写在children下； router-link 中，to中的路径要加/，代表根路径； 每一个子路由都可以嵌套多个组件； style中加入scoped属性，防止样式互相干扰。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios全局拦截器配置]]></title>
    <url>%2F2019%2F04%2F17%2Faxios%E5%85%A8%E5%B1%80%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于请求拦截器&emsp;&emsp;项目中，我们经常遇到请求后台接口时要做后天返回的code码验证判断。code码通常是一个特定的数值，比如一般返回200作为正常请求，返回其他作为数据异常或者请求异常等。如果接口量足够大，那么每一个接口都需要做正常/异常处理。为满足统一管理，那么在全局请求拦截器便应劫而出。 作用 统一管理 路由请求拦截 =&gt; request 路由响应拦截 =&gt; response 实例1.安装axios及qs123npm install axios --save-dev //安装axiosnpm install qs --save-dev //安装qs 2.新建一个js文件123456789101112131415161718192021├── project │ ├── build │ ├── config│ ├── node_modules │ ├── src │ │ ├── assets │ │ │ ├── request.js // 我在这里新建了一个js文件来配置拦截器│ │ ├── components │ │ ├── router │ │ ├── App.vue │ │ ├── main.js │ ├── static │ ├── test │ ├── .babelrc │ ├── .editorconfig │ ├── .gitignore │ ├── .postcssrc.js │ ├── index.html │ ├── package-lock.json │ ├── package.json │ ├── README.md 3.js拦截器配置如下：123456789101112131415161718192021222324252627282930313233343536import axios from &apos;axios&apos; //引入axiosimport qs from &apos;qs&apos; //引入qs qs可将数据转换为FormData格式// axios默认配置axios.defaults.timeout = 10000; // 超时时间axios.defaults.baseURL = &apos;https://www.demo.com&apos;; // 公用地址// 路由请求拦截// http request 拦截器axios.interceptors.request.use((config) =&gt; &#123; // 数据格式化 config.data = qs.stringify(config.data); // 给请求头加键值对 config.headers[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; return config;&#125;, (error ) =&gt; &#123; // 错误信息 return Promise.reject(error.response);&#125;);// 路由响应拦截// http response 拦截器axios.interceptors.response.use( (response) =&gt; &#123; if (response.data.code !== 200) &#123; // 异常请求要做的事 &#125; else &#123; // 正常请求要做的事 &#125; &#125;,(error) =&gt; &#123; // 返回接口返回的错误信息 return Promise.reject(error.response) &#125;);export default axios; 4.main.js配置12345// 引入该配置文件import axios from &apos;./assets/axiosRequest&apos;// 注册到全局Vue.prototype.$axios = axios; 5.使用1234567891011121314// 要发送的数据let params = &#123; name: &apos;AAA&apos;, number: &apos;10100110&apos;, age: &apos;18&apos;&#125;;// post请求为例 url不用写公共部分，直接写后面即可this.$axios.post(&apos;/test&apos;,params).then((res) =&gt; &#123; debugger;&#125;).catch((error) =&gt; &#123; debugger;&#125;) 总结&emsp;&emsp;http全局拦截器配置完毕，不仅可在response中统一管理返回状态，而且可在request中动态添加request headers，在实际项目中有很大的运用空间。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue之data中数组改变如何驱动视图]]></title>
    <url>%2F2019%2F04%2F09%2Fvue%E4%B9%8Bdata%E4%B8%AD%E6%95%B0%E7%BB%84%E6%94%B9%E5%8F%98%E5%A6%82%E4%BD%95%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;熟悉vue的小伙伴们都知道vue属于MVVM框架，数据可以驱动视图。一般来说，vue中的data发生变化，视图中绑定的data值也会随之发生变化。然而还是有特殊情况的，例如关于数组|对象的某些操作。&emsp;&emsp;根据官方文档定义： 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。 问题&emsp;&emsp;例：data中有一对象数组arr，如下：123456789101112131415161718192021222324252627282930313233343536// html&lt;ul&gt; &lt;li v-for=&quot;(item, index) in arr&quot;&gt; &#123;&#123; index + 1 &#125;&#125; - &#123;&#123; item &#125;&#125; &lt;button @click=&quot;change(index)&quot;&gt;change&lt;/button&gt; &lt;/li&gt;&lt;/ul&gt;// jsdata: &#123; arr: [ &#123; id: 0, son: [ &#123; name: &apos;son1&apos; &#125;, &#123; name: &apos;son2&apos; &#125; ] &#125;, &#123; id: 1, son: [ &#123; name: &apos;son1&apos; &#125;, &#123; name: &apos;son2&apos; &#125; ] &#125; ],&#125; &emsp;&emsp;在将数据绑定到视图中以后，点击change将当前点击的数组子项添加了一个id：12345678// ...methods: &#123; change (index) &#123; this.arr[index].son.forEach((item, index) =&gt; &#123; item.id = index + 1; &#125;); &#125;,&#125; &emsp;&emsp;点击之后，data中的arr数组发生了改变，按理说即将出现的效果应是数据更新后的视图，但是惊讶的发现视图并没有改变。那么如何解决此问题呢？ 解决方案&emsp;&emsp;使用Vue.set可得到解决。 this.$set(this.data, index, obj)// this.data: 要改变的数据// index: 下标// obj: 修改后的对象 &emsp;&emsp;如刚才所举之例，解决如下：123456change (index) &#123; this.arr[index].son.forEach((item, index) =&gt; &#123; item.id = index + 1; this.$set(this.arr[index].son, index, item); &#125;);&#125;, &emsp;&emsp;此时，点击change按钮，则视图实时改变。&emsp;&emsp;问题得以解决。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目搭建及基本配置]]></title>
    <url>%2F2019%2F03%2F27%2Fvue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言注：适用于windows系统本文讲述要点： vue-cli项目搭建基本环境配置； 常用插件描述及分享； 项目运行、调试及打包； 项目配置及优化； 适用人群： vue小白； 有html\css\js编程基础； vue项目整体优化（打包后压缩空间）； 一、准备阶段准备阶段会将项目环境配置完毕,包含node、npm、webpack和vue-cli。已经完成的小伙伴可以跳过此步骤看第二阶段。 1.安装node及npm&emsp;&emsp;从node.js中文网下载并安装nodejs点击下载.msi的32/64位安装包，然后双击本地文件一路点击下一步完成nodeJs的安装即可。注意安装8.10以上版本哟!安装完成后，打开命令行工具，输入node -v，如下：12E:\&gt;node -vv8.12.0 //版本号 顺便在此处继续输入npm -v12E:\&gt;npm -v6.4.1 //版本号 你会惊讶的发现npm已经神奇的安装完成了。这是因为npm在安装nodeJs的时候顺带已经装好了。 2.安装webpack注：以下所有npm操作，由于国内速度较慢甚至出现失败，可用淘宝镜像cnpm替代。下列所有npm命令，用cnpm替代即可。方式如下：1npm install -g cnpm --registry=https://registry.npm.taobao.org &emsp;&emsp;继续刚才的命令行工具，输入npm install webpack -g，-g代表全局安装。安装完成后继续输入webpack -v，出现相应版本号，代表安装成功。我在安装时出现如下状况：12345One CLI for webpack must be installed. These are recommended choices, delivered as separate packages: - webpack-cli (https://github.com/webpack/webpack-cli) The original webpack full-featured CLI.We will use &quot;npm&quot; to install the CLI via &quot;npm install -D&quot;.Do you want to install &apos;webpack-cli&apos; (yes/no): 解决方案是：输入npm install webpack-cli -g。安装成功后执行webpack -v查看版本号，如下：12345678910E:\&gt;npm install webpack-cli -g** 安* 装 省* 过 略* 程*E:\&gt;webpack -v4.29.6 //版本号 3.安装vue脚手架vue-cli&emsp;&emsp;继续上面的命令行工具。接下来就是安装配置今天的主角了，vue脚手架工具vue-cli。方法一样，键入命令行npm install vue-cli -g全局安装，然后输入vue -V注：是大写的-V检测是否安装成功。如下：12E:\&gt;vue -V2.9.6 //版本号 4.小结&emsp;&emsp;至此，我们已经完成了准备阶段的工作。主要完成的是node、npm、webpack和vue-cli四个工具的环境配置。目前为止，我们在命令行工具的总结应该是如下：版本号不必一致1234567891011E:\&gt;node -vv8.12.0E:\&gt;npm -v6.4.1E:\&gt;webpack -v4.29.6E:\&gt;vue -V2.9.6 二、项目搭建本阶段讲述vue-cli项目搭建及相关配置，包含创建项目、修改基础配置、项目运行三个模块，可自行选择阅读或跳过。 1.项目创建&emsp;&emsp;建立一个空文件夹，最好以纯英文命名。例，我项目路径为E&gt;stydy。打开命令行工具，cd到该文件目录下，执行vue init webpack name，name可替换为你要创建的项目名。回车之后，会要求输入一系列的信息，大部分可直接回车略过，注释如下，没有注释的回车略过即可：1234567891011121314E:\stydy&gt;vue init webpack blog? Project name blog //项目名? Project description A Vue.js project //项目简介? Author xuan0146 &lt;zxm0146@163.com&gt; //作者? Vue build runtime? Install vue-router? Yes //使用项目路由? Use ESLint to lint your code? No //不开启ESLint语法检测 注意选No? Set up unit tests Yes? Pick a test runner jest? Setup e2e tests with Nightwatch? Yes? Should we run `npm install` for you after the project has been created? (recommended) npm vue-cli · Generated &quot;blog&quot;. 最后一步选择npm或者yarn则会自动执行npm install安装项目所有依赖包。不选择的话，自己安装也是同样效果。安装步骤为： cd到项目路径； 执行npm install； 等待完成安装即可; 2.项目介绍&emsp;&emsp;cd到该项目，或者打开文件夹，项目目录及备注如下：1234567891011121314151617181920212223242526272829303132├── project //项目目录│ ├── build //webpack相关配置│ │ ├── build.js //生产环境构建│ │ ├── check-versions.js //版本检查│ │ ├── utils.js //构建相关工具│ │ ├── vue-loader.conf.js //处理vue文件的配置信息│ │ ├── webpack.base.conf.js //webpack基础配置│ │ ├── webpack.dev.conf.js //webpack开发环境配置│ │ ├── webpack.prod.conf.js //webpack生产环境配置│ ├── config //vue基本配置│ │ ├── dev.env.js //开发环境配置│ │ ├── index.js //主要配置│ │ ├── prod.env.js //生产环境配置│ │ ├── test.env.js //测试环境配置│ ├── node_modules //依赖包 忽略│ ├── src //项目核心文件│ │ ├── assets //静态资源 如公用js\css\image\媒体资源等│ │ ├── components //公用组件│ │ ├── router //项目路由│ │ │ ├── index.js //路由控制文件│ │ ├── App.vue //根组件│ │ ├── main.js //入口文件│ ├── static //静态资源│ ├── test //模拟测试│ ├── .babelrc //babel参数│ ├── .editorconfig //代码格式│ ├── .gitignore //git上传相关配置│ ├── .postcssrc.js //css相关工具│ ├── index.html //主页│ ├── package-lock.json //记录当前状态下实际安装的各个npm package的具体来源和版本号│ ├── package.json //项目信息│ ├── README.md //项目说明 3.启动项目&emsp;&emsp;命令行工具键入npm run dev，等待片刻，直到提示如下，则表示启动成功：1234567E:\stydy\blog&gt;npm run dev* * * * * * * ** 启动过程忽略 ** * * * * * * *Your application is running here: http://localhost:8080 然后复制http://localhost:8080，在浏览器地址栏输入该url，进入如下页面： 4.移动端调试&emsp;&emsp;有的人可能要问了，如果我做移动端项目，不能用localhost去访问了吧？当然不能，只需要稍微改一下配置即可。当然，端口号8080一样可以修改，不过一般不做变动。&emsp;&emsp;用代码工具（自己习惯的IDE）打开本项目。首先查看本机电脑ip,键入命令ipconfig，查看如下：1234567891011E:\stydy\blog&gt;ipconfig* ** *以太网适配器 以太网: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::da7:800d:d148:e06%10 IPv4 地址 . . . . . . . . . . . . : 192.168.200.127 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : fe80::48:5112:9520:564f%10 192.168.200.1 &emsp;&emsp;其中，IPv4 地址即为我们所需要的ip。在项目/config/index.js中，找到host: &#39;localhost&#39;，改成IPv4 地址，例:我的地址为192.168.200.127:123456module.exports = &#123; dev: &#123; host: &apos;192.168.200.127&apos;, //localhost改为ip port: 8080, //端口号 &#125;&#125; &emsp;&emsp;然后，我们重新启动项目。注意上次项目启动后，由于修改了配置文件，因此需要停止项目然后重新启动。停止项目的命令为Ctrl + C。重启项目后，如下：12345E:\stydy\blog&gt;npm run dev* * * * * * * ** 启 动 过 程 ** * * * * * * *Your application is running here: http://192.168.200.127:8080 &emsp;&emsp;注意要在同一网络下&emsp;&emsp;最后，我们复制该地址，即可在所有端PC、手机、pad等查看该项目啦~ 三、常用插件本章节记录一些vue常用插件，如axios、echarts、sass/scss、lib-flexible等等。所有命令均可用cnpm替代。如不需要可直接跳过。 1.sacc/scss用途：可用sass/scss进行css书写代码。命令行工具依次键入如下命令：12npm install node-sass --save-devnpm install sass-loader --save-dev 安装完成后，.vue里的style里添加lang=&quot;scss&quot;来指定语言，即可用sass/scss编写css代码。如下：123&lt;style lang=&quot;scss&quot; scoped&gt;...&lt;/style&gt; 2.axios用途：平时前后端交互使用Ajax，在vue官方，给出vue-resource和axios的作为ajax的替代。在此处使用vue官方推荐首选的axios作为案例讲述。 安装 1npm install axios 全局引入在项目/src/main.js中引入如下代码，然后随意走个请求，发现……报错？并且在页面F12控制台Newwork&gt;Headers里面发现数据并没有Form Data形式提交，如何处理呢？见下一步解决。 1import axios from &apos;axios&apos; 解决数据格式问题 1234567891011121314151617181920212223242526272829//完整请求代码 post为例this.$axios.post(&apos;url&apos;, &#123; //路径 key1: &apos;value&apos;, //参数 key2: &apos;value&apos; //参数&#125;, /* ** 添加如下代码* * * * * * start * * * * * &#123; transformRequest: [function (data) &#123; let ret = &apos;&apos;; for (let it in data) &#123; ret += encodeURIComponent(it) + &apos;=&apos; + encodeURIComponent(data[it]) + &apos;&amp;&apos;; &#125; return ret &#125; ], headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;&#125;/* * * * * * end * * * * *).then((response) =&gt; &#123; //返回数据 console.log(response)&#125;).catch((error) =&gt; &#123; //请求异常捕捉 console.log(error)&#125;) 3.axios解决方案&emsp;&emsp;另外一个axios数据格式问题的解决方案。 重磅推荐★★★★★此方案不仅解决数据格式问题，还顺便解决了跨域问题。第一步当然还是安装axios，同上一步。然后，安装qs，命令行工具键入npm install qs --save-dev。然后在项目/src/main.js中配置如下：12345import axios from &apos;axios&apos;import qs from &apos;qs&apos; Vue.prototype.$axios = axios;Vue.prototype.$qs = qs; 然后在项目/config/index.js中，找到proxyTable，配置及说明如下：12345678910proxyTable: &#123; &apos;/api&apos;: &#123; //设置url公用部分 target: &apos;http://192.168.1.100:8080/&apos;, changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos; //这里理解成用‘/api’代替target里面的地址 &#125; &#125;&#125;, 配置完成之后，在.vue文件中，请求用例如下：12345678910//参数let params = this.$qs.stringify(&#123; key: value&#125;);//请求this.$axios.post(&apos;/api/test&apos;, params).then((response) =&gt; &#123; console.log(response);&#125;).catch((error) =&gt; &#123; console.log(error);&#125;) 最后，键入命令npm run dev，发现请求数据格式已经成为Form Data的格式，并且即使后端不处理跨域问题，也依然正常可用。原因是proxy作为中间层，先将数据请求回本地，此过程是中间层node请求后台，不存在跨域。然后请求过来的数据放在本地，前端再去请求这个数据，就可以解决跨域问题了。 4.echarts可视化&emsp;&emsp;如今相信大家不少项目需要用到数据可视化吧？各种统计图表、炫酷可视化效果等等，都需要一个不错的插件去支撑，比如D3、AnyChart、echarts、HighCharts等等。本案例用百度的echarts作为案例讲解。 安装依赖惯例，先装依赖。命令行工具执行npm install echarts --save-dev。 全局配置安装完成后，全局引入。引入方法：进入项目/src/main.js，如下操作： 123import echarts from &apos;echarts&apos;Vue.prototype.$echarts = echarts 使用在***.vue组件中即可正常使用。我在此处用Hello.vue写示例： 1234567891011121314151617181920212223242526//template&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;//scriptlet myChart = this.$echarts.init(document.getElementById(&apos;demo&apos;)); //初始化//myChart.clear(); //根据需求配置myChart.setOption(&#123; // 图表配置 xAxis: &#123; type: &apos;category&apos;, data: [&apos;Mon&apos;, &apos;Tue&apos;, &apos;Wed&apos;, &apos;Thu&apos;, &apos;Fri&apos;, &apos;Sat&apos;, &apos;Sun&apos;] &#125;, yAxis: &#123; type: &apos;value&apos; &#125;, series: [&#123; data: [820, 932, 901, 934, 1290, 1330, 1320], type: &apos;line&apos;, smooth: true &#125;]&#125;);//style#demo&#123; width: 500px; height: 500px;&#125; 效果图 按需引入试过之后会发现echarts的包很大，会导致打包之后文件过大，因此如果不是刚需的情况下，建议按需引入来完成页面，会节省许多资源及开销。首先，将刚才项目/src/main.js中的两行代码注释掉。接下来，依然以Hello.vue举例，如下：12345678910111213141516//template &amp;&amp; style 不作变动//scriptconst echarts = require(&apos;echarts/lib/echarts&apos;); //基本模板require(&apos;echarts/lib/chart/line&apos;); //折线图组件require(&apos;echarts/lib/component/title&apos;); //标题组件 // 初始化实例let myChart = echarts.init(document.getElementById(&apos;demo&apos;));// 图表配置myChart.setOption(&#123; title: &#123; text: &apos;引入title组件可使用标题&apos; &#125;, * * * * * * * * * 别的配置不变 * * * * * * * * *&#125;); 5.lib-flexible | px2rem-loader&emsp;&emsp;lib-flexible作用在于写页面的时候实现自适应效果，包括文图排本等。需要配合px2rem-loader使用。步骤如下： 安装依赖 123npm i lib-flexible --save-devnpm install px2rem-loader --save-dev 引入项目/src/main.js中做如下配置： 1import &apos;lib-flexible 主页添加视口配置项目/index.html中的head中添加： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; px2rem配置项目/build/utils.js中如下配置，然后重启项目即可： 12345678910111213//自适应字体配置const px2remLoader = &#123; loader: &apos;px2rem-loader&apos;, options: &#123; remUnit: 37.5 //设计稿的宽度除以 10，现阶段一般设计稿的宽度都为750px。如果基于iPhone5设计则为32.0(320 / 10 = 32) &#125;&#125;function generateLoaders (loader, loaderOptions) &#123; const loaders = options.usePostCSS ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader, px2remLoader] * * *&#125; 更多关于px2rem的介绍请移步官网 四、项目打包本章节介绍打包以及去除打包后资源中的.map文件。开发完成后，怎么打包到线上呢？emm…this is a problem. 1.打包命令行工具cd到该项目下，执行npm run build来构建项目：1234567891011121314E:\stydy\blog&gt;npm run build Asset Size Chunks Chunk Names static/js/vendor.38756a8637fc194013f9.js 442 kB 0 [emitted] [big] vendor static/js/app.0b5326236ed4caddb252.js 1.1 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 857 bytes 2 [emitted] manifest static/css/app.26e0081e2c66d97635076ad7fefbb5b6.css 164 bytes 1 [emitted] appstatic/css/app.26e0081e2c66d97635076ad7fefbb5b6.css.map 348 bytes [emitted] static/js/vendor.38756a8637fc194013f9.js.map 2.38 MB 0 [emitted] vendor static/js/app.0b5326236ed4caddb252.js.map 8.47 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js.map 4.97 kB 2 [emitted] manifest index.html 571 bytes [emitted] Build complete. 2.位置打包完成后，去哪儿了呢？然后会发现在项目路径下，出现了一个dist的文件夹，这里面就是所谓的 包 了。如下：123456789101112131415161718├── project │ ├── build │ ├── config │ ├── dist // 包 │ │ ├── static // 压缩后的资源│ │ ├── index.html // 主页│ ├── node_modules │ ├── src │ ├── static │ ├── test │ ├── .babelrc │ ├── .editorconfig │ ├── .gitignore │ ├── .postcssrc.js │ ├── index.html │ ├── package-lock.json │ ├── package.json │ ├── README.md 3.问题&amp;解决细心的你可能发现了，dist/static/css(或js)里面，每个css文件和js文件下有一个同名的.map文件，非常占空间，那它是做什么的呢？又怎么消除呢？ 作用查过资料的小伙伴知道了，.map文件的作用就是：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。有了map就可以像未加密的代码一样，准确的输出是哪一行哪一列有错。 如何解决那么该如何处理这些文件呢？进入项目/config/index.js，定位到productionSourceMap，将其值改为false即可。如下： 1productionSourceMap: false, 重新打包验证在命令行工具重新执行npm run build，发现.map文件已经消失，问题解决。如下： 12345678910E:\stydy\blog&gt;npm run build Asset Size Chunks Chunk Names static/js/vendor.38756a8637fc194013f9.js 442 kB 0 [emitted] [big] vendor static/js/app.3c96ecd23cc6dc073a3e.js 1.05 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 799 bytes 2 [emitted] manifeststatic/css/app.26e0081e2c66d97635076ad7fefbb5b6.css 95 bytes 1 [emitted] app index.html 571 bytes [emitted] Build complete. 五、包优化&emsp;&emsp;在项目逐渐壮大之后，虽然说上面已经讲述过了如何去除.map文件，但是其中许多.js文件的体积也不容小觑。尤其是发布到线上以后，某些css/js单个文件体积极可能超上兆的大小，如果项目服务器带宽不够，但是页面迸发量不低的话，分分钟就可能挂掉。有没有什么方法能进一步将包优化呢？ 1.gzip打包压缩 安装gzip惯例，打开命令行工具，安装gzip 1npm install compression-webpack-plugin@1.1.11 --save-dev 配置项目/config/index.js中，定位到productionGzip，改为true： 1productionGzip: true, 重新打包npm run build走起，会发现打包的文件中多了同名的.gz文件，体积大概压缩了2/3，很棒的体验。如下： 1234567891011E:\stydy\blog&gt;npm run build Asset Size Chunks Chunk Names static/js/vendor.38756a8637fc194013f9.js 442 kB 0 [emitted] [big] vendor static/js/app.3c96ecd23cc6dc073a3e.js 1.05 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 799 bytes 2 [emitted] manifeststatic/css/app.26e0081e2c66d97635076ad7fefbb5b6.css 95 bytes 1 [emitted] app index.html 571 bytes [emitted] static/js/vendor.38756a8637fc194013f9.js.gz 155 kB [emitted] Build complete. nginx配置虽然很给力的节省了许多资源，但是需要运维配合，在gninx.conf配置文件中做如下配置： 1234567891011http &#123; gzip on; gzip_disable &quot;msie6&quot;; gzip_vary on; gzip_proxied any; gzip_comp_level 8; //压缩级别 gzip_buffers 16 8k; #gzip_http_version 1.1; gzip_min_length 100; //不压缩临界值 gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;&#125; 2.采用cdn加速&emsp;&emsp;顾名思义，即将一些比较大的插件放在第三方服务器上去加载，这样不仅快很多，也能更加节约自己的服务器资源及宽带资源。我们一般选用unpkg或者BootCDN来作为第三方。在此处我们使用BootCDN来作为第三方加速使用。想了解更多相关知识请点击unpkg BootCDN。 查找包打开BootCDN，在搜索栏搜索想要的第三方资源。如，我想要替换的是echarts、Vue、axios，则依次搜索echarts…，然后查找我想要的版本，然后复制&lt;script&gt;标签。 插入在项目/index.html中将标签插入，如下： 12345678&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;//插入在这里&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.20/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts-en.common.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; webpack配置打开项目/build/webpack.base.conf.js中，添加externals: 1234567891011module.exports = &#123; context: path.resolve(__dirname, &apos;../&apos;), //.. externals:&#123; &apos;vue&apos;: &apos;Vue&apos;, &apos;vue-router&apos;: &apos;VueRouter&apos;, &apos;echarts&apos;:&apos;echarts&apos;, &apos;axios&apos;:&apos;axios&apos;, &#125;&#125; main配置打开项目/src/main.js，将Vue等注释掉即可。不注释也可。 1// import Vue from &apos;vue&apos; 打包最后，见证奇迹的时刻就要到了~ 1234567891011E:\stydy\blog&gt;npm run build Asset Size Chunks Chunk Names static/js/vendor.1f9d0533037be66c61cf.js 12.3 kB 0 [emitted] vendor static/js/app.912fd568ff845fde7c09.js 1.36 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 799 bytes 2 [emitted] manifeststatic/css/app.edc64bd802cdc531977a30fcc8a9d6e1.css 62 bytes 1 [emitted] app index.html 876 bytes [emitted] static/js/vendor.1f9d0533037be66c61cf.js.gz 4.62 kB [emitted] Build complete. 搞定上次打包，vendor大小为442kB，本次打包，疯狂缩小至12.3kB。神不神奇~厉不厉害~ 结语&emsp;&emsp;到这里，vue项目从环境配置、项目搭建，到结构介绍、常用插件依赖安装使用做了比较详细的介绍，最后将项目优化也做了一定的补充。&emsp;&emsp;学而时习之，温故而知新。至此，以上。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《面纱》随笔]]></title>
    <url>%2F2019%2F03%2F25%2F%E3%80%8A%E9%9D%A2%E7%BA%B1%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[简介面纱 （英国毛姆创作长篇小说） &emsp;&emsp;《面纱》是英国作家威廉·萨默塞特·毛姆创作的一部长篇小说，首次出版于1925年。&emsp;&emsp;小说的故事发生在英国的殖民地香港和中国内陆一个叫“湄潭府”的地方。女主人公凯蒂·费恩因为和香港助理布政司查理通奸，被丈夫瓦尔特（香港政府的细菌学家）发现后胁迫她去了霍乱横行的湄潭府，最终瓦尔特不幸染病死去，凯蒂回到香港，重投查理怀抱后羞愧不已，最终回到英国和父亲和解，并和父亲同往巴哈马群岛生活。&emsp;&emsp;从《面纱》一书中，读者能看到一个表面漠然中立的叙事者背后的模糊性和矛盾性：作为帝国叙事的一分子，作者的面纱之下隐藏着东方主义的政治文化观；作为一个关注人性的个体作家，他的面纱之下隐藏着他对爱的怀疑和渴求、对人性的嘲讽和宽容。 内容&emsp;&emsp;女主人公凯蒂是生活于伦敦名利场的一位富家小姐，她容貌娇美，但精神空虚；她向往爱情，但爱慕虚荣；她待字闺中，但处处受到母亲的责备与“逼婚”。面对这种种“危机”，她决定给自己的爱情来一次“历险”：匆匆嫁给了性格孤僻、沉默寡言但却深爱着她的医生瓦尔特，并随其来到了英国的殖民地——香港。冲动的历险为其婚后的出轨埋下了伏笔。婚前，凯蒂对幸福美满的生活充满了憧憬，但丈夫的刻板严肃、疯狂工作和乏味无趣，使她顿觉寂寞、孤独和失落，不久就被花言巧语、生性多情的有妇之夫查理·唐森俘获，坠入婚外情而迷失自我。奸情败露之后，丈夫的疯狂报复、情人的无情冷落和自己的无限悔恨使凯蒂再次陷入了人生的危机。无望的她决心再次历险：陪丈夫奔赴霍乱肆虐的偏远山村——湄潭府。&emsp;&emsp;在湄潭府，凯蒂经历了绝境下的自省，看清了查理的虚伪，体验了修女的博爱、无私以及对信仰的坚定，得到了宗教与道德的救赎，亲历了丈夫的死亡，彻悟了他的博爱与爱情的狭隘，遭遇了与查理的欲火复燃，经历了对情感本能、人性污点的幡然醒悟，坚定了追寻自我的意志和决心，最后她毅然踏上回家的路，重新开始了一段崭新的人生。 随笔由于看的是译本，不是原本，所以对语言的优美和辞藻的华丽与否暂不做赏析。&emsp;&emsp;《面纱》作者毛姆被很多评论家评论为“二流作家”，原因无他，创新性、逻辑性及技巧性不足够高。艺术来源于生活又高于生活，这部《面纱》我不知道能否到达“艺术”之境界，不知道是否升华于生活，但是它一定是贴切生活，深入到生活中去的。小说中所描述出的爱、责任、被判、救赎与觉醒深入人心，也编织成了全篇小说的脉络。&emsp;&emsp;故事从爱与责任讲起。女主凯蒂从小缺乏疼爱，母亲势力且强势，害怕26岁的自己变成老处女。男主瓦尔特不善言辞、沉默寡言，是一个缺乏生活趣味的细菌学家。从社交舞会上与女主相识，追到手后匆匆结婚。一次偶然发现了奉若上宾的妻子却与他人（沃丁顿）有染，随后给妻子凯蒂两个选择，要么离婚要么陪同自己到湄潭府瘟疫区，这个地方可以说九死一生。随后二人到香港霍乱区开始“新”生活。男主在湄潭府疯狂工作，尝试用工作去洗刷与妻子情感的污垢，而妻子凯蒂则终日彷徨，浑浑噩噩，直到那一天，走进了教堂。&emsp;&emsp;走进教堂的那一天，是自我救赎的开始。以前，自己容貌娇美，但精神空虚；向往爱情，但爱慕虚荣；待字闺中，却被“逼婚”…种种因果，造成了当下不可逆转之局势后，直到这天，在教堂帮忙了一天，蓦然回首，才开始自省。之后便成了教堂的常客，甚至工作于此。在这里，凯蒂体验了修女的博爱、无私以及对信仰的坚定，甚至后来得知丈夫对于霍乱区的贡献，以及丈夫染上霍乱也未曾停歇，直至生命的尽头，理解了丈夫瓦尔特的博爱以及对爱情的不圆满，甚至狭隘。在此过程中，女主凯蒂内心逐渐完成自我救赎，看到光亮，理解生活的意义。在男主病逝后，女主凯蒂回到香港（当时香港是英国殖民地），随后又遇到了查理。在欲火复燃之后，沃丁顿妻子出现。沃丁顿妻子是一位满洲格格，外貌特征符合西方对东方宫廷女性的想象与审美。与她见面却没有直接的言语对白，只有“心理交流”，但是却让自己感受到了这位格格身上所代表的的灿烂文明。与此同时，自己算是经历了一场领悟，坚定了追寻自我的意志和决心。最后毅然踏上回家的路，与父亲和好，走向新的人生。 关于爱与责任&emsp;&emsp;对于男主瓦尔特来讲，从原文我知道你愚蠢、轻佻、头脑空虚，然而我爱你。我知道你的企图、你的理想，你势力、庸俗，然后我爱你。我知道你是个二流货色，然而我爱你。开始，已是深情告白，而女主凯蒂却不为所动。对于沃尔特来说，自己的伤悲只有自己可以理解，非常单纯的爱。即使发现妻子不忠，开始唇枪舌战，也依然保持镇定姿态和绅士风度。也同样由于爱之深所以恨之切，从而走向报复道路，去到霍乱区。&emsp;&emsp;瓦尔特却一直深爱凯蒂不肯放手，沃丁顿深爱满洲格格（他的妻子），唐森深爱自己妻子，修道院姐们们走在前线与病魔抗争，一系列的周边情感感染着凯蒂，渐渐地凯蒂也有了希望和勇气，学会慈悲与爱，放下心魔。 关于人格觉醒&emsp;&emsp;某乎上有话题：为什么永远不要去考验人性？而其中高票回答：因为大多数时候，人是选择做一个好人，而不是本性如此。小说中女主从最开始的人格为精神空虚、爱慕虚荣，此后与男主结婚后，依然是处于精神空虚状态，因而让得第三者沃尔顿有机可乘。东窗事发之后，由于沃尔顿的劝告甚至不想卷入其中，导致精神萎靡不振、浑浑噩噩。去到霍乱区之后，更加严重。到修道院开始，内心仿佛有了些许光亮。进而经常去修道院帮忙之后，从修女姐妹们的日常生活中得到救赎，找到了一些生活的意义以及开始忠于内心。神秘的面纱一角被掀开之后，开始审视自己，自我救赎，最终完成内心的升华。 作品评价&emsp;&emsp;贴切生活，以故事的尖锐以及矛盾来铺垫人物的内心世界，加上道德冲突、人性考验，不矢为一部杰作。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种境界]]></title>
    <url>%2F2019%2F03%2F24%2F%E4%B8%89%E7%A7%8D%E5%A2%83%E7%95%8C%2F</url>
    <content type="text"><![CDATA[前言古今之成大事业、大学问者，罔不经过三种之境界。 三种境界123昨夜西风凋碧树。独上高楼，望尽天涯路。衣带渐宽终不悔，为伊消得人憔悴。众里寻他千百度，回头蓦见，那人正在灯火阑珊处。 原文 &emsp;&emsp;古今之成大事业、大学问者，罔不经过三种之境界：“昨夜西风凋碧树。独上高楼，望尽天涯路。”此第一境界也。“衣带渐宽终不悔，为伊消得人憔悴。”此第二境界也。“众里寻他千百度，回头蓦见（当作‘蓦然回首’），那人正（当作‘却’）在灯火阑珊处。”此第三境界也。此等非大词人不能道。然遽依此意解释诸词，恐为晏、欧诸公所不许也。 译文&emsp;&emsp;古今那些成就大事业、大学问的人，都必然经历三种境界：“昨夜西风凋碧树。独上高楼，望尽天涯路。”这是第一层境界。“衣带渐宽终不悔，为伊消得人憔悴。”这是第二层境界。“众里寻他千百度，回头蓦见，那人正在灯火阑珊处。”这是第三种境界。像这样的语言，只有大词人才讲得出来。但是，我竟然这样来解释上面的词，恐怕晏殊、欧阳修这些大词人是不会同意的吧。 赏析&emsp;&emsp;《人间词话》赖以成名的数段话中，这一段毫无疑问占据了一个重要位置。这段话比喻贴切，佳句宛如浑然天成般镶嵌其中，让人称绝。王老先生正是“成大学问者”，说的这些话也正是他的切身感触。&emsp;&emsp;昨夜西风凋碧树。独上高楼，望尽天涯路。第一境界即入门前茫无头绪、求索无门的疑惑与痛苦。王国维最得意的学问在于史学、古文学和美学。这几门学问千头万绪，典籍浩如烟海，那种想要入门之前的彷徨、痛苦与渴求，用独上高楼，望尽天涯路来比喻，实在是再贴切不过。&emsp;&emsp;衣带渐宽终不悔，为伊消得人憔悴。第二境界是叩门时以苦做舟、以勤为径、上下求索的执着于忍耐。古往今来的大师无不经历过此阶段。不执着，无以成。既已入门，注定将为心中的伊人把此生消磨。王国维在乱世之中，一心治学，那种执着、悲愤、孤苦的心境，恐怕不是现代人所能理解的。唯有这种执着于隐忍，才成就了他在近代史上第一无二的大师地位。&emsp;&emsp;众里寻他千百度，回头蓦见，那人正在灯火阑珊处。第三境界则是功夫到处，灵犀一点、参透真谛、已入门中的喜悦与释然。以勤为径，很多人都如此，但是要攀上顶峰，就不是一般人能做到了。那种灵犀一点参透真谛的大智慧、大喜悦，也只有古今中外各个领域中的天才们感悟得到。这种顿悟就好比掉在牛顿身边的那个苹果，释迦牟尼眼前的那颗菩提，一切的一切忽然间都豁然开朗，往西追寻之中的种种艰辛苦楚，在这一瞬间都得到了完美补偿。&emsp;&emsp;当然，这些都不可能是词作者的愿意，所以王国维接着又说：此等非大词人不能道。然遽依此意解释诸词，恐为晏、欧诸公所不许也。这段话鞭辟入里，贴切浑融，其深致款曲已经不止于词话的范围了，即使晏、欧诸公在世，香叶不容置喙，不得不叹服王氏的才情与睿智吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js监测页面滑至底部响应事件]]></title>
    <url>%2F2019%2F03%2F18%2Fjs%E7%9B%91%E6%B5%8B%E9%A1%B5%E9%9D%A2%E6%BB%91%E8%87%B3%E5%BA%95%E9%83%A8%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[需求&emsp;&emsp;页面滑动至底部时候，触发响应 应用场景 服务协议滑动完毕可点击同意按钮; 页面滑至底部加载更多(新闻、列表等); 自动加载下一页等… 分析&emsp;&emsp;首先，既然是监听，则首要条件便是监听页面滑动(滚动)事件；其次，由于一般页面不会一屏展示完，因此需要依赖BOM来辅助完成一些计算。最后，达到某种条件，触发方法。 代码12345678910111213 window.onscroll = function()&#123; //滚动条滚动时，距离顶部的距离 let scrollTop = document.documentElement.scrollTop||document.body.scrollTop; //可视区的高度 let windowHeight = document.documentElement.clientHeight || document.body.clientHeight; //滚动条的总高度 let scrollHeight = document.documentElement.scrollHeight||document.body.scrollHeight; //滚动条到底部的条件 if(scrollTop + windowHeight &gt;= scrollHeight)&#123; //此处触发响应事件 ... &#125;&#125; 附录12345678910111213网页可见区域宽：document.body.clientWidth网页可见区域高：document.body.clientHeight网页可见区域宽：document.body.offsetWidth (包括边线的宽)网页可见区域高：document.body.offsetHeight (包括边线的高)网页正文全文宽：document.body.scrollWidth网页正文全文高：document.body.scrollHeight网页被卷去的高：document.body.scrollTop网页被卷去的左：document.body.scrollLeft//对应的dom元素的宽高有以下几个常用的：元素的实际高度：document.getElementById(&quot;div&quot;).offsetHeight元素的实际宽度：document.getElementById(&quot;div&quot;).offsetWidth元素的实际距离左边界的距离：document.getElementById(&quot;div&quot;).offsetLeft元素的实际距离上边界的距离：document.getElementById(&quot;div&quot;).offsetTop]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《惊奇队长》随笔]]></title>
    <url>%2F2019%2F03%2F10%2F%E3%80%8A%E6%83%8A%E5%A5%87%E9%98%9F%E9%95%BF%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[简介 &emsp;&emsp;卡罗尔·丹弗斯（布丽·拉尔森饰）是克里人的精英部队一员，但她挣扎着回忆过去，对于怎么获得超能力、以及之前的人生等超能力之前的人生，她只在梦中有片段不成章的记忆，这层困扰引起的情绪波动也进而影响她对超能力的掌控。所幸，在星际战队指挥官（裘德·洛饰）的调教之下，卡罗尔·丹弗斯学会如何控制自己的超能力。&emsp;&emsp;一次外星任务中，卡罗尔·丹弗斯因故来到了地球，并遇到还是低阶探员的尼克·弗瑞（塞缪尔·杰克逊饰），卡罗尔·丹弗斯与尼克·弗瑞一起追捕在地球惹事的变形人塔罗斯（本·门德尔森饰），同时，也发现自己如何获得超能力。 起&emsp;&emsp;时间回到前天(2019年3月8日18:00:00)。这是不寻常的一天，不仅仅是女神节，更是跟基友约好看惊奇队长首映的日子。&emsp;&emsp;下午6点，准备下班。但是作为猿，按时下班显然不是我们的风格，于是噼里啪啦一顿操作又改了个产品刚提出的优化，并且自测完毕。ok，天儿也不早了，赶紧挤地铁回家准备观影去吧。没想到的是，为了一场电影，会有一场场刺激等待着我们。 Then&emsp;&emsp;19:35，超市购物了一波回到家，小憩了一下下，喝点酸奶补补体力。&emsp;&emsp;20:35，嘀嘀了一辆优享专车，下楼跟基友等车。&emsp;&emsp;上车。&emsp;&emsp;堵车。&emsp;&emsp;司机人很nice，一个看起来有修养的大龄先生。&emsp;&emsp;两分钟后，我们在后排毫无感觉，司机下了车，前面司机也下了车。&emsp;&emsp;嗯，追尾。&emsp;&emsp;ok,下车，换车。&emsp;&emsp;重新嘀嘀。&emsp;&emsp;“耐心”等待中…&emsp;&emsp;上车。&emsp;&emsp;驾驶过堵车区，一路飞……额，红灯。&emsp;&emsp;“铃铃铃铃铃铃”电话响起来~&emsp;&emsp;“…………”&emsp;&emsp;基友：“完了，一个需求忘记处理”&emsp;&emsp;“……看急不急，不急了明天上午公司处理”&emsp;&emsp;下车。&emsp;&emsp;取票。&emsp;&emsp;21:03，等待进场。&emsp;&emsp;21:05，开始检票。&emsp;&emsp;21:06,，“不行，我得回去先处理需求去了……”。&emsp;&emsp;于是，检票只检了一张，有了下图： So&emsp;&emsp;被迫一个人看完了整场。 随笔关于剧情&emsp;&emsp;一向的漫威思维，并且在女神节这么个档期，祭出目前最强大的主角英雄，且为女英雄，应景至极。前半篇在不停的铺垫，以及给出一些断断续续的女主回忆。从女主发现自己被骗之后，一系列举动将剧情推向高潮。&emsp;&emsp;故事发生于上世纪90年代，在此之时，复仇者联盟尚未建立。居中也道出了神盾局局长独眼的原因以及建立复仇者联盟的初心。&emsp;&emsp;斯克鲁人怕猫，检测猫为“噬元兽”，克里人怕尬舞。然而关键时刻，猫吞噬“魔方”，吞噬“敌军”，真的救了神盾局长。 关于彩蛋&emsp;&emsp;很多评论说，又是“看彩蛋送电影”，第一个彩蛋比正片好看。确实，在漫威宇宙中，自打复联出来之后，新出的超级英雄好像都与复联有着密不可分的联系，甚至都是为了复联去添砖加瓦。但是在多方面关于复联四的猜测中，惊奇队长却是救世中不可或缺且极为重要的一环。如果只是粗略的一笔带过，进而在复联四中直接使用其几乎藐视现阶段复联所有人所有技能的特殊能力，那在复联四中将会显得极为仓促且莫名其妙。因此，此英雄作为一部新的超级英雄，极有必要对齐以及复联历史进行一些必要的补充，以及填坑。 关于斯坦●李&emsp;&emsp;老爷子去年过世，与东方的金庸大侠先后将生命挪出了时间。至此，东方再无江湖，漫威再无宇宙。&emsp;&emsp;剧中老爷子作为路人，在公交车上看书，与惊奇队长偶遇。上一次同样是在公交车看书，遇到了奇异博士。&emsp;&emsp;所以是不是为我们敲响警钟，多出门，多读书，不要总在家里宅着，说不定也能偶遇超级英雄呢。 猜测&emsp;&emsp;《蚁人2》片尾彩蛋中，蚁人进入量子域，在入口处，小女友及其父母随着灭霸的响指化为了灰烬，因此是否在复联四中也会贡献在即的一份力量呢？ 等待ing复联四…]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>电影</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js/vue输入联想功能]]></title>
    <url>%2F2019%2F03%2F04%2Fjs-vue%E8%BE%93%E5%85%A5%E8%81%94%E6%83%B3%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[实现功能如下 介绍&emsp;&emsp;最近需求要有一个输入框模糊搜索功能，且需要匹配输入字符联想。从网上看了一些demo，总结出来一套思路，配合vue将其开发并稍做优化处理。 思路基础： 1.一个输入框（输入字符）、一个ul框（展示匹配数据） 2.将输入字符与列表中字符比对 3.新建空数组，将比对结果匹配项放入此数组中 4.将数组数据铺到ul中 优化： 5.鼠标滑入某一项变更背景色 6.点击选中数据展示到input框中 7.键盘上下键控制上一个下一个 8.回车键将选中项目展示到input框中 代码1.HTML1234567891011121314151617//input框 &lt;input type=&quot;text&quot; @keydown.down=&quot;changeDown&quot; //键盘事件 @keydown.up=&quot;changeUp&quot; v-model=&quot;searchVal&quot; //绑定输入的值 @keyup=&quot;searchFn&quot; @keyup.enter=&quot;enter&quot; //回车将选中项目展示到input框中 placeholder=&quot;input name&quot;/&gt; //选项框 判断如果新数组中有值则显示本备选框&lt;ul class=&quot;ulAdd&quot; v-if=&quot;searchResult&quot;&gt; &lt;li v-for=&quot;(item, index) in searchResult&quot; :class=&quot;&#123;bgColor: index === now&#125;&quot; //渲染样式 @click=&quot;alertFn&quot; //点击将选中项目展示到input框中 @mouseenter=&quot;mouseEnter(index)&quot; //渲染鼠标移入/移出样式 @mouseleave=&quot;mouseleave&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 2.数据12345678searchVal: &apos;&apos;, //绑定namesearchResult: [], //匹配结果now: -1, //索引nameList: [ //name列表 &#123;name: &apos;张三&apos;,id: &apos;9001&apos;&#125;, &#123;name: &apos;张四&apos;,id: &apos;9002&apos;&#125;, &#123;name: &apos;李三&apos;,id: &apos;9003&apos;&#125;] 3.事件处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//过滤searchFn (e) &#123; let val = e.target.value; //输入的值 this.searchResult = []; //清空存结果的数组 if (val) &#123; this.nameList.forEach(function(item) &#123; let pattern = new RegExp(&apos;&apos;+val, &apos;g&apos;); //正则校验 if (pattern.test(item.name)) &#123; this.searchResult.push(&#123;name: item.name,id: item.id&#125;); &#125; &#125;.bind(this)); // 绑定当前实例对象 &#125;&#125;//将选中项目展示到input框中alertFn () &#123; this.searchVal = this.searchResult[this.now].agentname; this.searchResult = [];&#125;,//按键盘↓键changeDown () &#123; this.now ++; if(this.now == this.searchResult.length) &#123; this.now = -1; &#125;&#125;,//按键盘↑键changeUp () &#123; this.now --; if (this.now === -2) &#123; this.now = this.searchResult.length; &#125;&#125;,//回车将选中项目展示到input框中enter () &#123; this.searchVal = this.searchResult[this.now].agentname; this.searchResult = [];&#125;,//清空结果deleteList () &#123; this.searchResult = [];&#125;,//鼠标移入mouseEnter (index) &#123; this.now = index;&#125;,//鼠标移出mouseleave (index) &#123; this.now = -1;&#125; 注&emsp;&emsp;样式自定义即可。 总结功能实现，且完成了一定的优化，但存在一定的不足： 数组循环可用新语法； 多个方法可合并； 可以进一步优化，做出输入字母也同样联想。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>输入框联想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目打包后资源路径与背景图路径问题]]></title>
    <url>%2F2019%2F02%2F28%2Fvue%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%90%8E%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E4%B8%8E%E8%83%8C%E6%99%AF%E5%9B%BE%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言本文主要解决基于vue/vuex打包后经常出现的两个问题： 静态资源路径错位问题 css背景图路径错位问题 问题的出现&emsp;&emsp;一般通过vue-cli脚手架开发的时候，开发模式使用npm run dev进行开发，一切配置正常。但是当打包后会出现各种问题，其中两个最为常见且致命的问题莫过于上述的两个资源路径错位问题，但是当我们分析后，发现依旧是配置问题。尤其是当好多猿把assetsPublicPath: &#39;/&#39;的&#39;/&#39;改为&#39;./&#39;后，一般的资源路径包括css、js、图片音视频等都能校正，然而唯独css设置的背景图却全部失效。接下来请看此bug图。 bug图：1. 资源路径4042. 背景图路径404可以看到背景图的路径错且重复。 解决方案1. 静态资源路径错位问题解决方案：在项目/config/index.js中找到module.exports中的build，其中的assetsPublicPath项改为：1assetsPublicPath: &apos;./&apos;, //解决静态资源路径错位问题 2. css背景图路径错位问题解决方案：在项目/build/utils.js中找到ExtractTextPlugin.extract，追加publicPath: &#39;../../&#39;：代码片段为：12345return ExtractTextPlugin.extract(&#123; use: loaders, fallback: &apos;vue-style-loader&apos;, publicPath: &apos;../../&apos; //解决css背景图路径错位问题 &#125;) 测试结果：ok，配置完毕，打包测试下~npm run build 倒数10个数：10,9,8,7,6…控制台空空如也~完美！]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[to 2019]]></title>
    <url>%2F2019%2F02%2F25%2Fto-2019%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;2019悄然来袭，且2月将逝。值此春天即醒之际，万物复苏之时，应对2018正式告别，并在充满期待的2019之中完成一些目标来积累沉淀自己。 规划规划大致分为以下四（+1）个大方面： 学习 工作 生活 财务 其他 （愿世界和平） 其详细信息将通过X-Mind作导图式的png图片展示，如下： 规则 完成后做“√”标记； 定期更新：月更，更新文本及感受类图文；季更，更新图片及日期； 不定期更新： 完成后更新； 更新准则：上传新图，标明日期； 训练自律;随心所欲的日子里，大部分时候都怅然若失。 更新0226完成 可乐鸡翅，招待朋友songleitravel,于2019.02.16完成； 建站，GitHub+Hexo+nexT，于2019.02.20完成； 发表博文，包括读书随笔与技术随笔； 小结&emsp;&emsp;本月前期学习阮一峰老师的《ES6》，后期项目压力上来，暂搁一旁。这种行为不可取，在此反思。另，本季度读书及笔记均会在本站博客中体现，已完成《小狗钱钱1》随想。 更新0401本期更新主要如下： 读书篇 《小狗钱钱1》随想 《面纱》随笔 工作篇 es6学习 博客更新，包括如下： 文章 更新时间 Vue打包后map文件处理 02-22 vue-cli自适应/flexible屏幕字体自适应布局及配置 02-23 vue中axios跨域问题 02-24 vue项目打包后资源路径与背景图路径问题 02-28 js/vue输入联想功能 03-04 js监测页面滑至底部响应事件 03-18 post_link vue项目搭建及基本配置 03-27 生活篇 影音娱乐 《惊奇队长》随笔 《探清水河》小调 做菜 红烧肉 麻婆豆腐 可乐鸡翅 财务篇 存款达到目标1/3； 被动收益达到目标1/5； 公益方面利用支付宝月捐，按月自动捐出； 蚂蚁森林领养两棵树，完成全年2/3 小结完成度尚可，但是1个/月的训练项目未完成。继续努力！ 更新0705读书篇&emsp;&emsp;二季度，读书《月亮与六便士》，《流血的仕途》。其中，《月亮与六便士》发表博文。传送门：《月亮与六便士》随笔。 博客更新&emsp;&emsp;博客更新，包括如下： 文章 更新时间 vue之data中数组改变如何驱动视图 04-09 axios全局拦截器配置 04-17 vue路由嵌套 04-20 v-html指令渲染出的内容如何添加样式 04-22 vue吸顶效果 04-26 js执行——Promise 04-28 《复联3之终局之战》随笔 05-02 vue-cli3.x及相关配置 05-05 vue-cli3.x打包白屏、清除console及IE白屏问题解决 05-06 520特辑——旋转爱 05-20 vue中引入并使用markdown编辑器 05-23 vue弹窗屏蔽滑动两种解决方案 05-28 电商放大镜及动态边框 06-02 秒懂——惹人烦恼的this指向 06-11 切换模块下划线跟随效果 06-13 《月亮与六便士》随笔 06-18 生活篇 《复联四》 《蜘蛛侠之英雄远征》 财务 存款方面，完成3/8； 被动收益，完成1/2； 公益方面，月捐在坚持，公益时涨到5； 期望方便，MacBook Pro完成； 思维导图如下 全年完成度2019结束了。断更半年，补上2019年全年完成度： 总结时光飞逝，又一年悄悄滑过指尖，从指缝中溜走。2019，仿佛每天匆匆忙忙，又浑浑噩噩。得到了什么，失去了什么？才华？技能？知识？财富？韶华易逝啊。转眼来到2020，虽然在跨年时，我们信誓旦旦，我们拥有美好祝愿，但是你我都知道，所谓跨年，不过是人类将时间的连续划分出来的格子而已，看似我们从一个格子跳到另外一个格子，实则对于拥有连续性的时间来讲，我们只是从上一个时刻平缓的过渡到了下一个时刻，仅此而已。但也因为有了格子，我们也才得以不在茫茫的时光之海中随处荡漾而迷失自己，才让我们有了方向，有了目标。 关于学习前三个季度保持良好，最后一个季度只看了《曾国藩》，完成度达到及格，不算优秀。 关于工作很明显，项目积累和博客积累都有在努力，唯独自己的专业知识更新度欠缺。需查漏补缺，努力提升自身专业知识是一大突破口。 关于生活并没有想象中的多姿多彩，也谈不上丰富，甚至是平淡、艰辛。娱乐方面，投入精力不少，但是过于杂乱。情感方面保持良好。其他方面做的一般，甚至有些目标并未完成。下次制定计划要量力而行，言必信，行必果。 财务方面存钱计划基本上宣告失败。由于今年家里装修，加上还房贷，年初买了手机，年中买了电脑，因此在年末落得个口袋空空。希望今年年终奖能回回血吧。另外，理财方面收益达到预期，并且开启了定投基金及黄金。20年可适当提高收益目标。 2020，愿世界和平]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中axios跨域问题]]></title>
    <url>%2F2019%2F02%2F24%2Fvue%E4%B8%ADaxios%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言兴冲冲的开始用vue封装组件、自定义指令之后，开始实战。诶，等等，貌似少了……交互？大致研究了一下axios，但是存在以下两个问题： 跨域问题 数据格式问题跨域信息示例：1234Failed to load http://localhost:8080/login:Response to preflight request doesn&apos;t pass access control check:No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://localhost:8080&apos; is therefore not allowed access. 所以针对该问题给出一套解决方案（以post请求为例）： 1.跨域处理cinfig/index.js中对proxyTable做如下配置：123456789proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;https://0.0.0.0:8080/login&apos;, //设置url公用部分，记得加http/https和端口号 changeOrigin: true, pathRewrite: &#123; &apos;^/api&apos;: &apos;/&apos; //这里理解成用‘/api’代替target里面的地址，后面组件中我们掉接口时直接用api代替 比如我要调用&apos;http://40.00.100.100:3002/user/add&apos;，直接写‘/api/user/add’即可 &#125; &#125; &#125;, main.js中引入axios并作为Vue属性使用123import axios from &apos;axios&apos;Vue.prototype.HOST = &apos;/api&apos; 在调取数据组件中，axios配置如下（可以自行封装）：12345678910111213141516getData () &#123; this.$axios(&#123; method: &apos;post&apos;, //请求方式 一般为get\post 此处以post为例 url: this.HOST + &apos;/login&apos;, //url data: &#123; //数据 loginId: &apos;123456&apos;, password: &apos;123456&apos; &#125;, &#125;).then(function (res) &#123; console.log(res); debugger; &#125;.bind(this)).catch(function (err) &#123; //bind 绑定当前作用域 console.log(err); debugger; &#125;) &#125; ok，保存，然后npm run dev咦？发生了什么？没跨域啊？数据发过去了啊？为什么服务器给我抛异常==、12345&#123; code:100, data: &#123;&#125;, msg: &quot;服务器异常&quot; &#125; 检查发现错误原因：数据发送时没有走formdata，接下来处理该问题。 2.数据格式修正formdata形式提交数据处理方法则是在刚才配置的getData()中的this.$axios()加上一段格式化代码配置即可，代码如下：123456789101112//formdata transformRequest: [function (data) &#123; let ret = &apos;&apos;; for (let it in data) &#123; ret += encodeURIComponent(it) + &apos;=&apos; + encodeURIComponent(data[it]) + &apos;&amp;&apos;; &#125; return ret &#125;],//头信息 headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125; 注：说明步骤2 formdata形式提交数据，可直接解决跨域问题，不用执行步骤1完整axios的post配置如下：1234567891011121314151617181920212223242526getData () &#123; this.$axios(&#123; method: &apos;post&apos;, //请求方式 一般为get\post 此处以post为例 url: &apos;http://localhost:8080/login&apos;, data: &#123; //数据 loginId: &apos;123456&apos;, password: &apos;123456&apos; &#125;, transformRequest: [function (data) &#123; let ret = &apos;&apos;; for (let it in data) &#123; ret += encodeURIComponent(it) + &apos;=&apos; + encodeURIComponent(data[it]) + &apos;&amp;&apos;; &#125; return ret &#125;], headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125; &#125;).then(function (res) &#123; console.log(res); debugger; &#125;.bind(this)).catch(function (err) &#123; console.log(err); debugger; &#125;)&#125; 继续测试：保存之后npm run dev完美~~，接下来看返回数据： ok，解决方案到此结束，希望对大家有所帮助。继续快乐的采坑吧各位~]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli自适应|flexible屏幕字体自适应布局及配置]]></title>
    <url>%2F2019%2F02%2F23%2Fvue-cli%E8%87%AA%E9%80%82%E5%BA%94-flexible%E5%B1%8F%E5%B9%95%E5%AD%97%E4%BD%93%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言：很多前端小伙伴在写页面尤其是移动端页面的时候，要求页面布局以及字体大小随屏幕宽度变化而随之按比例自适应【注：非响应式】，那么，在vue-cli脚手架中应该如何去实现呢？ 1.安装flexible库12//在项目库下运行：npm i lib-flexible --save-dev 2.引入项目入口文件main.js中引入lib-flexible:12//main.js中：import &apos;lib-flexible&apos; 3.配置meta在项目index.html的head中配置meta`：12&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 4.安装px2rem-loader12//在项目库下运行npm install px2rem-loader --save-dev 5.配置px2rem编译器在build/utils.js中，将px2rem-loader添加到cssLoaders中：123456789101112131415//自适应字体配置const px2remLoader = &#123; loader: &apos;px2rem-loader&apos;, options: &#123; remUnit: 37.5 //设计稿的宽度 除以 10，现阶段一般设计稿的宽度都为750px。如果基于iPhone5设计则为32.0(320 / 10 = 32) &#125;&#125;// generate loader string to be used with extract text plugin function generateLoaders (loader, loaderOptions) &#123; const loaders = options.usePostCSS ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader, px2remLoader] /** *其余的不用改 */ &#125; 6.启动项目1npm run dev 后语：启动项目之后会惊讶的发现已经完美解决了，即使在PC端也是适用的哦~想要了解更多关于px2rem的想伙伴可以戳下方飞机票去官方看介绍：点击飞机票：px2rem]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《小狗钱钱1》随想]]></title>
    <url>%2F2019%2F02%2F23%2F%E3%80%8A%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B11%E3%80%8B%E9%9A%8F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;相信大家都买过基金吧，比如支付宝的余额宝就是一种货币基金。我的钱一直也在支付宝存放。但是从去年（2018年）年初开始，收益好像走了下坡路。为了追求更高的收益，我便把目光转向了支付宝里面的基金市场，然后再零理财基础的情况下辛辛苦苦选了好几个（我认为）收益高的基金，结果一天掉一百多块……不到半个月 差不多赔了小一千，因此觉得开始学习并积累一些理财知识，但是迟迟没有行动。直到规划本年度（2019）目标时，才想起此事，并提上日程。一顿操作猛如虎，找到了一本理财的启蒙书《小狗钱钱》，并且用了一下午3小时26分钟的时间通读了一遍，由此感悟颇深。&emsp;&emsp;读书不写笔记犹如过眼云烟，学习重在输出。 介绍&emsp;&emsp;《小狗钱钱》讲述的是一个童话故事：有一天，吉娅发现一只受伤的猎狗，并把它带回了家。可是，有谁会想到，这只普通的四脚动物却是一个真正的理财天才呢？吉娅和小狗成为了朋友，并从它那里得知，原来所有的愿望都是可以实现的。&emsp;&emsp;从这个童话故事里可以了解一些金钱的秘密和真相，以及投资、理财的办法。这个故事描述了在实施这些方法的过程中可能遇到的挑战，并且说明了一些令人难以置信的结果。 钱钱语录 金钱有一些秘密和规律，要想了解这些秘密和规律，前提条件是，你自己必须真的有这个愿望。 如果你只是带着试试看的心态，那么你最后只会以失败而告终，你会一事无成。尝试纯粹是一种借口，你还没有做，就已经给自己想好退路了。不能试验。你只有两个选择：做，或者不做。 你是否能挣到钱，最关键的因素并不在于你是不是有一个好点子。你有多聪明也不是主要原因，决定因素是你的自信程度。 一个人把精力集中在自己所能做的，知道的和拥有的东西上的那一天起，他的成功就已经拉开了序幕。这也使得一个孩子完全有能力比成人挣到更多的钱。 你最好想清楚，你喜欢做什么，然后再考虑你怎么用它来挣钱。 你要每天不间断地去做对称的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。 欠债的人应当毁掉所有的信用卡。 应当尽可能少地偿还贷款。 应当将不用于生活的那部分钱中的一半存起来，另一半用于还债。最好不要申请消费贷款。 每次借债前问自己：“这真的有必要吗？” 当你定下了大目标的时候，就意味着你必须付付出比别人多得多的努力。 假如我没有了我的“鹅”，我就总是得为了赚钱而工作，但是一旦我有了属于自己的“鹅”，我的钱就会自动为我工作了。 幸运其实只是充分准备加上努力工作的结果。 钱只令留在那些为之付出努力的人身边，用非法手段取得不义之财的人，反而会比没钱的时候感觉更糟糕。 恐惧总是在我们设想事情会如何不顺的时候出现。我们对失败的可能性想得越多，就越害怕。而当你朝看积极的目标去思考的时候，就不会心生畏惧。 关于投资 确定自己希望获得财务上的成功。 自信，有想法，做自己喜欢做的事。 把钱分成日常开销、梦想目标和金鹅账户三部分。 进行明智的投资。 享受生活。 如果你没有做今天这件事情，你就永远不会知道，给自己一些压力之后，你能够做到些什么。一个人觉得最引以为自豪的事情，往往是那些做起来最艰难的事情。 挑选基金时的注意事项： 基金应该至少有十年历史。假如它在这么长时间内一直有丰厚的盈利，那我们可以认为，它在未来也会运作良好。 应该选择大型的跨国股票基金，这种基金在世界各地购买股票，以此分做风险，所以十分安全。 对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终获利最好。用72除以投资的年收益率的百分比，得出的数字就是这笔钱翻一倍所要的年数。 每当冬天过后，春天就来了，接着是夏天，每个夏天之后又跟着是秋天，然后又是冬天，年年如此。跟大自然的变化一样，交易所里也总有四季更替，循环往复。 最主要的是，在人们眼中钱应该是一种再自然、再普通不过的东西了。 感悟&emsp;&emsp;故事新颖，通俗易懂，并且道出挣钱的终极目的：让钱变得不再重要。&emsp;&emsp;对啊，曾几何时，我们为了生活奔波，打拼，一切都是为了钱。有人说，不忘初心。那货币的本质是一般等价物，一定程度上代替了以物易物。一路发展而来，初心早已更改，到如今的世道上已经完全演变为了“没钱万万不能”的时代。什么世外桃源，田间小居，都是在经济支撑下才能完成的愿望。&emsp;&emsp;书中也提到适量的方法、态度以及对理财中多个名词的通俗解释，都是让理财新人能够快速接受且消化的，不得不说作者是下了大工夫的。书中主人公吉娅以及其家庭遇到的问题相信在大多数人的生活中都有存在，比如： 是否遇到问题的时候经常说，我试着…… 从小被教导，金钱是万恶之源…… 常听父母说，小孩子不用想钱的事儿…… 是否常常入不敷出…… 是否用着信用卡，每个月都在大笔的分期付款…… 是否心里曾有过宏大的目标（精神或者物质），但又告诉自己这不大可能实现…… 是否做什么事情，在没行动前总想着，我没有这个条件，这个事情不能成功…… 是否每个月仍有结余，但是仅仅是存在银行里…… 是否不够自信，但又不知道怎么去提高……等等问题。吉娅出现的每一个问题，都与我们极其相似，但是我们常常只是想想，然后迷茫，彷徨，不自信，忘记。我们却能从这本书里学习到如何想，如何做，一步一步，一个个的习惯养成，大有裨益。 &emsp;&emsp;关于金钱的意义。钱是中性的，没有善恶之分。但是往往金钱能使人性的阴暗面暴露出来，因此怎么有钱，有了钱如何使用，便是一个很大的课题，终究取决于学习，修善，成长等。在此之前，我应该先考虑钱的用途，以及自己要成为怎样的人。 &emsp;&emsp;关于“小金鹅”。故事是这样的： &emsp;&emsp;从前有一个年轻的农夫，他每天的愿望就是从鹅笼里捡一个鹅蛋当早饭。有一天，他竟然在鹅笼里发现了一只金蛋。当然，一开始他不相信这是真的。他想，也许是有人在捉弄他。为了谨慎起见，他把金蛋拿去让金匠看，可是金匠向他保证说，这只蛋完全是纯金铸成的。于是农夫卖了这只金蛋，然后举行了一个盛大的庆祝会。&emsp;&emsp;第二天清晨，他起了个大早，赶到鹅笼处一看，那里果真又放着一个金蛋。这样的情况延续了好几天。&emsp;&emsp;可是这个农夫是一个贪婪的人，他对自己的鹅，非常不满意，因为鹅没法向他解释是怎么下出金蛋的，否则也许他自己就可以制造金蛋了。他还气呼呼地想，这只懒惰的鹅每天至少应该下两只金蛋，现在这样的速度太慢了。他的怒火越来越大，最后，他终于怒不可遏地把鹅揪出鹅笼，劈成两半。从那以后，他再也得不到金蛋了。 &emsp;&emsp;其实，理财不是针对有资产的人，而是所有人。《小狗钱钱》一书中，“养鹅”一事贯穿全文。鹅代表你的钱，如果你存钱，就会得到利息，利息就是金蛋。穷人越穷，每天鸡蛋都生不出来，富人越富，每天有金蛋甚至会有越来越多的鹅。两极分化不是没有道理的。书中将赚到的钱，分成三个账户，分别是“日常开销”、“梦想目标”、“金鹅账户”，并以此达到开源节流的目的。 关于72定理 用72除以年收益率百分比，得出的数字就是这笔钱翻一倍的年数。 在通货膨胀率下，我们的钱在多长时间贬值一半，用72除以通胀率，即可得知多少年后你的钱是现在的一半。 假如目前存（投）一笔1万人民币，年收益为12%，那么72 / 12 = 6年时间就可以翻倍本金。当然，至于如何达到年收益12%甚至更高，则需要继续努力学习相关知识并且不断的实践并积累了。假定以后每年通货膨胀率6%，那么在72 / 6 = 12年后你的钱将只能买到现在购买力能买的的一半。 结语《小狗钱钱》带来最大的收获便是让我获得了一把打开新世界的钥匙。后续需要持续学习不断提高，跑赢通货膨胀，养一只能下优质蛋的鹅。好在年轻即资本，生命不息，学习不止。 后记财商决定后半生是否富裕]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue打包后map文件处理]]></title>
    <url>%2F2019%2F02%2F22%2FVue%E6%89%93%E5%8C%85%E5%90%8Emap%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言最近踩坑vue，打包之后js中，会自动生成一些map文件，无形之中就增大了dist包的体积，可能会增加服务器压力。那我们怎么把它去掉呢？ 1.找到productionSourceMap在项目下进入目录：项目包/config/index.js找到productionSourceMap123456 /** * Source Maps */productionSourceMap: true,// https://webpack.js.org/configuration/devtool/#productiondevtool: &apos;#source-map&apos;, 2.改为false将productionSourceMap的true改为false即可123productionSourceMap: false,// https://webpack.js.org/configuration/devtool/#productiondevtool: &apos;#source-map&apos;, 3.打生产包打包:npm run build12345678910111213141516171819202122Hash: 450e46e5a578d8ed5832Version: webpack 3.12.0Time: 19211ms Asset Size Chunks Chunk Names static/js/2.f45baf9afd59da355a2c.js 17.9 kB 2 [emitted] static/img/healthIcon2.0a76940.png 21.7 kB [emitted] static/img/healthIcon1.7f9e278.png 21 kB [emitted] static/img/healthIcon3.a2530d6.png 20.3 kB [emitted] static/js/0.2623d3f24b6cb900e249.js 182 kB 0 [emitted] static/js/1.68a7b37dd5366d3385bc.js 62.6 kB 1 [emitted] static/img/healthIcon4.42cd92c.png 18.9 kB [emitted] static/js/3.dd658b712540b545b1a8.js 6.57 kB 3 [emitted] static/js/vendor.ed30b6e3d0cfb8529feb.js 962 kB 4 [emitted] [big] vendor static/js/app.ab727f325a694968cc20.js 1.22 kB 5 [emitted] app static/js/manifest.bad9ce278a16a20c8817.js 1.48 kB 6 [emitted] manifeststatic/css/app.e93cb55eadaef6e12f4bccfcc6e2e3cc.css 35.6 kB 5 [emitted] app index.html 555 bytes [emitted] Build complete. Tip: built files are meant to be served over an HTTP server. Opening index.html over file:// won&apos;t work. 4.解决打包成功，看项目/dist/static/js/xxxx.js已经没有各种.map文件，问题解决。 【注】.map文件的作用：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。有了map就可以像未加密的代码一样，准确的输出是哪一行哪一列有错。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮世三千]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%B5%AE%E4%B8%96%E4%B8%89%E5%8D%83%2F</url>
    <content type="text"><![CDATA[浮世三千，吾爱有三：日、月与卿。日为朝、月为暮，卿为朝朝暮暮 我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
